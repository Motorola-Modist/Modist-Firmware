
out/boot_hdk.elf:     file format elf32-littlearm

SYMBOL TABLE:
08000000 l    d  .flash_vector	00000000 .flash_vector
20000000 l    d  .reset	00000000 .reset
20000188 l    d  .text	00000000 .text
200066b0 l    d  .ARM.extab	00000000 .ARM.extab
200066b0 l    d  .ARM.exidx	00000000 .ARM.exidx
200066b8 l    d  .data	00000000 .data
200066c8 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 out/startup_stm32l476xx.o
f1e0f85f l       *ABS*	00000000 BootRAM
0800001a l       .flash_vector	00000000 LoopCopyTextROInit
08000012 l       .flash_vector	00000000 CopyTextROInit
08000032 l       .flash_vector	00000000 LoopCopyDataInit
0800002a l       .flash_vector	00000000 CopyDataInit
08000046 l       .flash_vector	00000000 LoopFillZerobss
08000040 l       .flash_vector	00000000 FillZerobss
0800004e l       .flash_vector	0000000e Reset_Handler
0800005a l       .flash_vector	00000000 LoopForever
20005680 l       .text	00000000 Infinite_Loop
08000000 l     O .flash_vector	00000000 g_flashVectors
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 main.c
20005db8 l     O .text	00000008 bootmode_flag
200066c8 l     O .bss	00000004 epid
200066cc l     O .bss	00000004 tvid
200066d0 l     O .bss	00000004 flash_reason
20005e9c l     O .text	00000008 flashing_flag
200066d4 l     O .bss	00000004 tpid
200066d8 l     O .bss	00000004 evid
00000000 l    df *ABS*	00000000 system_stm32l4xx.c
00000000 l    df *ABS*	00000000 stm32l4xx_hal_msp.c
00000000 l    df *ABS*	00000000 stm32l4xx_it.c
20000810 l     F .text	00000020 stm32_exti_multi_isr
00000000 l    df *ABS*	00000000 stm32l4xx_flash.c
2000088c l     F .text	00000038 GetPage
200008c4 l     F .text	00000054 GetBank
00000000 l    df *ABS*	00000000 utils.c
00000000 l    df *ABS*	00000000 gbcore.c
20000b1e l     F .text	00000056 greybus_send_message
200066bc l     O .data	00000002 greybus_id_count
00000000 l    df *ABS*	00000000 ctrl.c
200066dc l     O .bss	00000001 manifest_fetched
00000000 l    df *ABS*	00000000 modsctrl.c
20000cc8 l     F .text	00000018 modsctrl_null_resp
00000000 l    df *ABS*	00000000 gbfirmware.c
20000dfc l     F .text	00000002 gbfw_ready_to_boot_cb
20000e00 l     F .text	000000a0 gbfw_next_stage
20000ea0 l     F .text	00000018 gbfw_ap_ready_cb
200066e4 l     O .bss	00000001 tftf_header_received
200066e8 l     O .bss	00000014 fw_flash_data
200066fc l     O .bss	00000002 section_index
200066fe l     O .bss	00000001 _gbfw_stage
200066ff l     O .bss	00000200 tftf_buff
200068ff l     O .bss	00000004 firmware_size_response
20006903 l     O .bss	00000001 _gbfw_updated_count
00000000 l    df *ABS*	00000000 network.c
00000000 l    df *ABS*	00000000 tftf.c
00000000 l    df *ABS*	00000000 mnfb.c
200062cd l     O .text	00000164 manifest
00000000 l    df *ABS*	00000000 stm32l4xx_muc.c
20006904 l     O .bss	00000070 huart
00000000 l    df *ABS*	00000000 stm32l4xx_mod_device.c
00000000 l    df *ABS*	00000000 stm32l4xx_hal_mod.c
00000000 l    df *ABS*	00000000 dl_spi.c
20001ac0 l     F .text	0000001c dl_call_sent_cb
20001adc l     F .text	0000000c dl_bus_config_cb
20001ae8 l     F .text	0000007c dump
20001b64 l     F .text	00000094 ack_handler.part.0
20001bf8 l     F .text	00000094 Error_Handler
200066be l     O .data	00000008 resp.7979
20006974 l     O .bss	00000064 gb_hspi
200069d8 l     O .bss	00000018 g_spi_data
00000000 l    df *ABS*	00000000 spi_write_w25q40.c
20001f48 l     F .text	0000000c spi_flash_finish
20001f54 l     F .text	00000014 spi_flash_get_capacity
20001f68 l     F .text	00000010 spi_flash_get_erase_size
20001f78 l     F .text	00000026 spi_flash_wait_for_not_busy
20001f9e l     F .text	0000003a spi_flash_write_enable
20001fd8 l     F .text	00000024 spi_flash_erase_all
20001ffc l     F .text	00000070 spi_flash_init
2000206c l     F .text	00000038 spi_flash_write_address
200020a4 l     F .text	00000068 spi_flash_verify
2000210c l     F .text	00000094 spi_flash_write
200021a0 l     F .text	00000068 spi_flash_erase
200064c4 l     O .text	00000048 SPI_FLASH_DEVICES
200069f0 l     O .bss	00000004 spi_flash_device
00000000 l    df *ABS*	00000000 spi_flash.c
20002208 l     F .text	00000058 Error_Handler
200069f4 l     O .bss	00000004 total_section_length
200069f8 l     O .bss	00000004 wTransferState
200069fc l     O .bss	00000004 dst
20006a00 l     O .bss	00000064 hspi_flash
00000000 l    df *ABS*	00000000 stm32l4xx_hal_rcc.c
20002520 l     F .text	00000084 RCC_SetFlashLatencyFromMSIRange
00000000 l    df *ABS*	00000000 stm32l4xx_hal_rcc_ex.c
200030ac l     F .text	000000ac RCCEx_PLLSAI1_ConfigNP
20003158 l     F .text	000000ac RCCEx_PLLSAI2_ConfigNP
20003204 l     F .text	000000b0 RCCEx_PLLSAI1_ConfigNQ
00000000 l    df *ABS*	00000000 stm32l4xx_hal.c
20006a64 l     O .bss	00000004 uwTick
00000000 l    df *ABS*	00000000 stm32l4xx_hal_cortex.c
00000000 l    df *ABS*	00000000 stm32l4xx_hal_gpio.c
00000000 l    df *ABS*	00000000 stm32l4xx_hal_spi.c
20003c84 l     F .text	000000a0 SPI_WaitFifoStateUntilTimeout
20003d24 l     F .text	0000008c SPI_WaitFlagStateUntilTimeout
20003db0 l     F .text	0000002e SPI_EndRxTxTransaction
20003dde l     F .text	0000006a SPI_EndRxTransaction
20003e48 l     F .text	00000178 HAL_SPI_TransmitReceive_DMA.part.5
200040f2 l     F .text	00000022 SPI_DMAError
200040dc l     F .text	0000000a SPI_DMAHalfReceiveCplt
200040e8 l     F .text	0000000a SPI_DMAHalfTransmitReceiveCplt
20004114 l     F .text	000000c2 SPI_DMAReceiveCplt
200041d6 l     F .text	000000c4 SPI_DMATransmitReceiveCplt
00000000 l    df *ABS*	00000000 stm32l4xx_hal_dma.c
00000000 l    df *ABS*	00000000 stm32l4xx_hal_flash.c
20004cd4 l     F .text	000000d4 FLASH_SetErrorCode
20004da8 l     F .text	00000030 FLASH_Program_Fast
00000000 l    df *ABS*	00000000 stm32l4xx_hal_flash_ex.c
20004f18 l     F .text	0000002c FLASH_MassErase
00000000 l    df *ABS*	00000000 stm32l4xx_hal_pwr_ex.c
00000000 l    df *ABS*	00000000 debug.c
00000000 l    df *ABS*	00000000 stm32l4xx_hal_uart.c
20006659 l     O .text	0000000d CSWTCH.36
20006666 l     O .text	00000004 CSWTCH.35
00000000 l    df *ABS*	00000000 ramlog.c
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 bpabi.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 lib_a-memcpy.o
00000000 l    df *ABS*	00000000 /usr/lib/gcc/arm-none-eabi/4.9.3/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 /usr/lib/gcc/arm-none-eabi/4.9.3/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 mod_ids.c
00000000 l    df *ABS*	00000000 
20006684 l       *ABS*	00000000 __fini_array_end
00000000 l       *UND*	00000000 malloc
4000cd90 l       .bss	00000000 __bss_start__
00000000 l       *UND*	00000000 HAL_PWR_PVDCallback
00000000 l       *UND*	00000000 __deregister_frame_info
00000000 l       *UND*	00000000 end
00000000 l       *UND*	00000000 _ITM_registerTMCloneTable
4000f244 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 _ITM_deregisterTMCloneTable
20006684 l       *ABS*	00000000 __fini_array_start
00000000 l       *UND*	00000000 HAL_PWR_EnableBkUpAccess
00000000 l       *UND*	00000000 __end__
00000000 l       *UND*	00000000 __libc_fini
00000000 l       *UND*	00000000 HAL_PWR_DisableBkUpAccess
00000000 l       *UND*	00000000 _Jv_RegisterClasses
00000000 l       *UND*	00000000 __register_frame_info
00000000 l       *UND*	00000000 free
08000080 l     F .flash_vector	00000010 __main_veneer
08000090 l     F .flash_vector	00000010 __SystemInit_veneer
080000a0 l     F .flash_vector	00000010 ____libc_init_array_veneer
20005680  w    F .text	00000002 RTC_Alarm_IRQHandler
20006651 g     O .text	00000008 APBAHBPrescTable
20005680  w    F .text	00000002 EXTI2_IRQHandler
20005680  w    F .text	00000002 TIM8_TRG_COM_IRQHandler
20005680  w    F .text	00000002 TIM8_CC_IRQHandler
200056e4 g     F .text	0000002e .hidden __gnu_uldivmod_helper
20003b28 g     F .text	0000012c HAL_GPIO_DeInit
200050e2 g     F .text	00000024 dbgprinthex32
20005680  w    F .text	00000002 DebugMon_Handler
20001928 g     F .text	00000048 device_spi_flash_init
20001630 g     F .text	00000058 MX_GPIO_Init
20005718 g     F .text	0000029c .hidden __divdi3
200015b4 g     F .text	00000038 MX_USART_UART_Init
20005680  w    F .text	00000002 DFSDM0_IRQHandler
2000429c g     F .text	0000019c HAL_DMA_Init
20002458 g     F .text	00000018 spi_flash_error_handler
20003054 g     F .text	0000002c HAL_RCC_GetPCLK1Freq
2000197c g     F .text	00000010 mods_rfr_set
20005680  w    F .text	00000002 TIM1_CC_IRQHandler
20003898 g     F .text	00000060 HAL_NVIC_SetPriority
20003080 g     F .text	0000002c HAL_RCC_GetPCLK2Freq
20005680  w    F .text	00000002 TSC_IRQHandler
20004dfc g     F .text	00000014 HAL_FLASH_Lock
20005680  w    F .text	00000002 HardFault_Handler
20000b74 g     F .text	00000014 greybus_get_next_id
20000830 g     F .text	0000000e SysTick_Handler
20001c94 g     F .text	0000000c datalink_get_max_payload_size
20003c60 g     F .text	0000000a HAL_GPIO_WritePin
2000057c g     F .text	00000030 HAL_SPI_TxRxCpltCallback
20005680  w    F .text	00000002 TAMP_STAMP_IRQHandler
4000cd70 g       .data	00000000 _sidata
20003020 g     F .text	00000034 HAL_RCC_GetHCLKFreq
20005680  w    F .text	00000002 PendSV_Handler
20005680  w    F .text	00000002 NMI_Handler
200038f8 g     F .text	00000018 HAL_NVIC_EnableIRQ
200066b8 g       *ABS*	00000000 __exidx_end
20000876 g     F .text	00000006 EXTI3_IRQHandler
20002f50 g     F .text	000000d0 HAL_RCC_GetSysClockFreq
20001688 g     F .text	00000014 chip_bootloader_is_readonly
200019a4 g     F .text	00000010 mods_muc_int_set
2000565c g     F .text	00000024 ramlog_reason
20005680  w    F .text	00000002 LPTIM2_IRQHandler
20003c6c g     F .text	00000018 HAL_GPIO_EXTI_IRQHandler
200005f4 g     F .text	00000034 HAL_MspInit
20003960  w    F .text	00000002 HAL_SYSTICK_Callback
2000226c g     F .text	00000020 spi_write_calc_total_len
200066c8 g       *ABS*	00000000 _sbss
2000658c g     O .text	00000020 spi_write_ops
200025a4 g     F .text	00000048 HAL_RCC_DeInit
20005680  w    F .text	00000002 I2C3_ER_IRQHandler
200047e0 g     F .text	0000004a HAL_DMA_Start_IT
20002470 g     F .text	000000ac chip_spi_exchange
200012dc g     F .text	0000001c valid_tftf_type
20007ae4 g     O .bss	00000802 aRxBuffer_spiFlash
20001514 g     F .text	0000002c get_chip_uid
200082e6 g     O .bss	00000802 aTxBuffer_spiFlash
2000396c g     F .text	000001bc HAL_GPIO_Init
20000920 g     F .text	00000028 mod_get_flashmode_addr
2000169c g     F .text	00000090 mods_gpio_clk_enable
200014e4 g     F .text	00000024 chip_reset_irqs
20005c84 g     F .text	00000134 memcpy
20000918 g     F .text	00000008 mod_get_tftf_addr
200019c4 g     F .text	00000004 mods_getms
20005680  w    F .text	00000002 EXTI0_IRQHandler
20005eb4 g     O .text	00000030 MSIRangeTable
20005680  w    F .text	00000002 I2C2_EV_IRQHandler
20005684 g     F .text	00000000 .hidden __aeabi_uldivmod
20005680  w    F .text	00000002 CAN1_RX0_IRQHandler
20005680  w    F .text	00000002 FPU_IRQHandler
2000385c  w    F .text	00000016 HAL_Delay
200066b8 g     O .data	00000004 SystemCoreClock
2000145c g     F .text	0000000c tftf_get_pid
20005680  w    F .text	00000002 TIM1_UP_TIM16_IRQHandler
20006a68 g     O .bss	0000003c hdma_spi2_rx
20005680  w    F .text	00000002 UsageFault_Handler
20005680  w    F .text	00000002 ADC1_2_IRQHandler
20001cf8 g     F .text	00000020 datalink_send
20003c54 g     F .text	0000000c HAL_GPIO_ReadPin
20001998 g     F .text	0000000c mods_wake_n_get
200009c0 g     F .text	0000004c flash_erase
200019c8 g     F .text	00000034 mods_ack_received
200066b8 g       *ABS*	00000000 _sdata
20005680  w    F .text	00000002 SPI1_IRQHandler
20004fc4 g     F .text	000000a8 HAL_FLASHEx_Erase
200018c4 g     F .text	00000018 mod_dev_base_spi_reset
20000a84 g     F .text	00000056 program_flash_data
20005680  w    F .text	00000002 TIM6_DAC_IRQHandler
20005124 g     F .text	000002b8 UART_SetConfig
20001540 g     F .text	00000074 SystemClock_Config
20000a20 g     F .text	00000064 program_flash_dword
20003934 g     F .text	0000002c HAL_SYSTICK_Config
20005680  w    F .text	00000002 TIM8_UP_IRQHandler
20001830 g     F .text	00000044 device_spi_mod_init
20008b60 g     O .bss	0000001c pFlash
200066b0 g       *ABS*	00000000 __exidx_start
20000280 g     F .text	0000009c CheckFlashMode
20003910 g     F .text	00000024 HAL_NVIC_SystemReset
20000188 g     F .text	00000050 __libc_init_array
20001918 g     F .text	00000010 mods_muc_set_spi_sel
20000948 g     F .text	00000008 mod_get_program_start_addr
20005680  w    F .text	00000002 DMA2_Channel2_IRQHandler
200059b4 g     F .text	0000026a .hidden __udivdi3
20000840 g     F .text	0000000c DMA1_Channel4_IRQHandler
20005680  w    F .text	00000002 SAI2_IRQHandler
20001cd8 g     F .text	00000020 dl_exit
20004f7c g     F .text	00000048 FLASH_FlushCaches
2000097c g     F .text	00000044 ErasePage
20003fc0 g     F .text	000000ae HAL_SPI_Init
20006684 g     F .text	00000000 _init
20000628 g     F .text	0000017c HAL_SPI_MspInit
200050a0 g     F .text	00000014 dbgprint
20005680  w    F .text	00000002 USART3_IRQHandler
2000409a g     F .text	00000016 HAL_SPI_TransmitReceive_DMA
20008b7c g       *ABS*	00000000 _ebss
20005680  w    F .text	00000002 DMA1_Channel7_IRQHandler
20000adc g     F .text	0000000c erase_tftf_header
20005680  w    F .text	00000002 CAN1_RX1_IRQHandler
20005680  w    F .text	00000002 LCD_IRQHandler
20004438 g     F .text	000003a8 HAL_DMA_DeInit
20005680  w    F .text	00000002 UART5_IRQHandler
20000950 g     F .text	0000002c mod_get_program_end_addr
20005680  w    F .text	00000002 ADC3_IRQHandler
2000381c g     F .text	00000024 HAL_Init
20005494 g     F .text	0000008a UART_WaitOnFlagUntilTimeout
200014d4 g     F .text	00000010 reset_systick
2000507c g     F .text	00000010 HAL_PWREx_EnableVddIO2
2000406e g     F .text	0000002c HAL_SPI_DeInit
20005680  w    F .text	00000002 TIM4_IRQHandler
200040b0 g     F .text	00000028 HAL_SPI_DMAStop
20005680  w    F .text	00000002 DMA2_Channel1_IRQHandler
200053dc g     F .text	000000b8 UART_AdvFeatureConfig
20000bae g     F .text	00000026 greybus_send_response
20005680  w    F .text	00000002 QUADSPI_IRQHandler
20004e98 g     F .text	00000080 HAL_FLASH_Program
20000528 g     F .text	00000024 HAL_GPIO_EXTI_Callback
20000b94 g     F .text	0000001a greybus_send_request
20005680  w    F .text	00000002 I2C1_EV_IRQHandler
200019fc g     F .text	00000024 mods_ack_transmitted_setup
200014cc g     F .text	00000006 get_manifest_size
200007a4 g     F .text	0000006c HAL_SPI_MspDeInit
20005680  w    F .text	00000002 DMA1_Channel6_IRQHandler
20005680  w    F .text	00000002 UART4_IRQHandler
20005680  w    F .text	00000002 DMA2_Channel4_IRQHandler
20002424 g     F .text	00000028 spi_write_to_flash_finish
20005680  w    F .text	00000002 TIM3_IRQHandler
20005680  w    F .text	00000002 RCC_IRQHandler
20002260 g     F .text	0000000c spi_flash_hal_init
20005680  w    F .text	00000002 DMA1_Channel1_IRQHandler
20000b88 g     F .text	0000000c greybus_get_max_payload_size
20005680 g       .text	00000002 Default_Handler
20004f44 g     F .text	00000038 FLASH_PageErase
20005680  w    F .text	00000002 DMA2_Channel7_IRQHandler
20005ea4 g     O .text	00000010 AHBPrescTable
20001254 g     F .text	0000000c network_get_max_payload_size
20004e10 g     F .text	00000088 FLASH_WaitForLastOperation
2000551e g     F .text	00000050 UART_CheckIdleState
2000482a g     F .text	0000004c HAL_DMA_Abort
20000884 g     F .text	00000008 EXTI15_10_IRQHandler
2000508c g     F .text	00000014 dbgputc
20002d08 g     F .text	00000248 HAL_RCC_ClockConfig
20003874 g     F .text	00000024 HAL_NVIC_SetPriorityGrouping
20000a16 g     F .text	0000000a program_flash_lock
200050b4 g     F .text	0000002e dbgprinthex8
200066e0 g     O .bss	00000004 gbfw_cportid
20005680  w    F .text	00000002 TIM7_IRQHandler
20001d18 g     F .text	0000009c dl_muc_handler
20000ce0 g     F .text	0000011c mods_control_handler
200018f4 g     F .text	00000024 apbe_reset
20005680  w    F .text	00000002 SDMMC1_IRQHandler
20005680  w    F .text	00000002 TIM5_IRQHandler
20000eb8 g     F .text	0000039c fw_cport_handler
20005c20 g     F .text	00000062 memcmp
20001eac g     F .text	0000009c setup_exchange
20005106 g     F .text	0000001a dbgprintx32
20005680  w    F .text	00000002 I2C3_EV_IRQHandler
20005680  w    F .text	00000002 DFSDM2_IRQHandler
20005714  w    F .text	00000002 .hidden __aeabi_ldiv0
2000087c g     F .text	00000008 EXTI9_5_IRQHandler
20005680  w    F .text	00000002 RTC_WKUP_IRQHandler
20001dc8 g     F .text	000000e4 dl_spi_transfer_complete
080000b0 g       *ABS*	00000000 _sf_isrv
20003850  w    F .text	0000000c HAL_GetTick
200018b4 g     F .text	00000010 mods_force_flash_get
20005680  w    F .text	00000002 PVD_PVM_IRQHandler
20005680  w    F .text	00000002 SPI2_IRQHandler
20005680  w    F .text	00000002 DFSDM3_IRQHandler
200001d8 g     F .text	0000009a memset
20005680  w    F .text	00000002 MemManage_Handler
20000390 g     F .text	0000017c main
20001ca0 g     F .text	00000038 dl_init
20000380 g     F .text	0000000e clr_flash_barker
20000b08 g     F .text	00000016 is_constant_fill
20001270 g     F .text	0000006c network_recv
20001970 g     F .text	0000000c mods_muc_set_spi1_cs
20005680  w    F .text	00000002 CAN1_TX_IRQHandler
20001508 g     F .text	0000000a mods_is_spi_csn
20005680  w    F .text	00000002 SVC_Handler
20005680  w    F .text	00000002 DMA2_Channel5_IRQHandler
200040e6  w    F .text	00000002 HAL_SPI_TxRxHalfCpltCallback
20006684 g       *ABS*	00000000 __init_array_end
2000138c g     F .text	000000ac valid_tftf_header
2000198c g     F .text	0000000c mods_rfr_get
20000864 g     F .text	0000000c DMA1_Channel5_IRQHandler
20005680  w    F .text	00000002 EXTI4_IRQHandler
20000a0c g     F .text	0000000a program_flash_unlock
200018dc g     F .text	00000018 mod_dev_is_attached
2000228c g     F .text	00000170 spi_write_to_flash_header
200040d8  w    F .text	00000002 HAL_SPI_RxCpltCallback
20005636 g     F .text	00000026 ramlog_writehex8
200005ac g     F .text	00000048 SystemInit
20001874 g     F .text	00000040 device_dma_init
20005680  w    F .text	00000002 RNG_IRQHandler
200066b8 g       *ABS*	00000000 __read_only_end
20006690 g     F .text	00000000 _fini
20001438 g     F .text	00000024 get_section_index
20005680  w    F .text	00000002 TIM1_TRG_COM_TIM17_IRQHandler
20005120  w    F .text	00000002 HAL_UART_MspInit
2000251c g     F .text	00000004 chip_delay
20001a30 g     F .text	0000002c mods_spi_restore
20000bd4 g     F .text	000000f4 control_cport_handler
20000858 g     F .text	0000000c DMA1_Channel3_IRQHandler
20005680  w    F .text	00000002 COMP_IRQHandler
200037f8  w    F .text	00000024 HAL_InitTick
200015ec g     F .text	00000044 MX_DMA_Init
20003840  w    F .text	00000010 HAL_IncTick
20004878 g     F .text	0000045c HAL_DMA_IRQHandler
20006684 g       *ABS*	00000000 __preinit_array_end
20001c8c g     F .text	00000008 greybus_get_operation_header
20000000 g       .reset	00000000 _sr_isrv
20006ae0 g     O .bss	00000802 aRxBuffer
20005680  w    F .text	00000002 WWDG_IRQHandler
20000ae8 g     F .text	00000020 program_tftf_header
20001260 g     F .text	00000010 network_send
2000669c g     O .text	00000010 _ids
08000008  w    F .flash_vector	00000046 _Start
20001468 g     F .text	0000000c tftf_get_vid
20005680  w    F .text	00000002 LPUART1_IRQHandler
20001db4 g     F .text	00000012 dl_spi_error_handler
20005680  w    F .text	00000002 DMA2_Channel6_IRQHandler
20005680  w    F .text	00000002 TIM2_IRQHandler
20001a5c g     F .text	00000064 SPI_NSS_INT_CTRL_Config
200055d4 g     F .text	0000004c ramlog_addchar
20016fff g       *ABS*	00000000 _estack
2000182c g     F .text	00000002 device_handle_exti
20000870 g     F .text	00000006 EXTI1_IRQHandler
200066c6 g       *ABS*	00000000 _edata
20000334 g     F .text	00000018 get_chip_id
2000506c g     F .text	00000010 HAL_PWREx_GetVoltageRange
20004dd8 g     F .text	00000024 HAL_FLASH_Unlock
20001a20 g     F .text	00000010 mods_ack_transmitted_get
20008ae8 g     O .bss	0000003c hdma_spi1_rx
200023fc g     F .text	00000028 spi_write_to_flash_data
20005680  w    F .text	00000002 USART2_IRQHandler
200025ec g     F .text	0000071c HAL_RCC_OscConfig
200014c4 g     F .text	00000008 get_manifest
2000050c g     F .text	0000001c set_request_flash
200040da  w    F .text	00000002 HAL_SPI_RxHalfCpltCallback
20000000 g     O .reset	00000000 g_pfnVectors
200032b4 g     F .text	00000544 HAL_RCCEx_PeriphCLKConfig
200019b4 g     F .text	00000010 mods_muc_int_get
20005680  w    F .text	00000002 I2C2_ER_IRQHandler
2000084c g     F .text	0000000c DMA1_Channel2_IRQHandler
2000031c g     F .text	00000018 get_board_id
20006aa4 g     O .bss	0000003c hdma_spi2_tx
20001474 g     F .text	0000004e tftf_get_load_addr
20005680  w    F .text	00000002 TIM8_BRK_IRQHandler
20005714  w    F .text	00000002 .hidden __aeabi_idiv0
20006684 g       *ABS*	00000000 __init_array_start
20005680  w    F .text	00000002 CAN1_SCE_IRQHandler
2000054c g     F .text	00000030 HAL_SPI_ErrorCallback
20005680  w    F .text	00000002 FLASH_IRQHandler
20005680  w    F .text	00000002 BusFault_Handler
20005680  w    F .text	00000002 USART1_IRQHandler
20003962 g     F .text	00000008 HAL_SYSTICK_IRQHandler
20005680  w    F .text	00000002 OTG_FS_IRQHandler
20005680  w    F .text	00000002 SPI3_IRQHandler
2000172c g     F .text	00000064 device_console_init
20008b24 g     O .bss	0000003c hdma_spi1_tx
2000556e g     F .text	00000064 HAL_UART_Init
200056b4 g     F .text	0000002e .hidden __gnu_ldivmod_helper
20005680  w    F .text	00000002 I2C1_ER_IRQHandler
20005620 g     F .text	00000016 ramlog_write
20005680  w    F .text	00000002 FMC_IRQHandler
20005680  w    F .text	00000002 SWPMI1_IRQHandler
20005680  w    F .text	00000002 LPTIM1_IRQHandler
20005680  w    F .text	00000002 DFSDM1_IRQHandler
20000274 g     F .text	0000000c get_flash_reason
2000244c g     F .text	0000000c spi_flash_transfer_complete
20006684 g       *ABS*	00000000 __preinit_array_start
20001790 g     F .text	0000009c device_gpio_init
2000034c g     F .text	00000034 set_flashing_flag
20005680  w    F .text	00000002 SAI1_IRQHandler
200012f8 g     F .text	00000094 valid_tftf_section
200072e2 g     O .bss	00000802 aTxBuffer
20005680  w    F .text	00000002 DMA2_Channel3_IRQHandler
20005680  w    F .text	00000002 TIM1_BRK_TIM15_IRQHandler



Disassembly of section .flash_vector:

08000000 <g_flashVectors>:
 8000000:	ff 6f 01 20 09 00 00 08                             .o. ....

08000008 <_Start>:

    .section	.text._Start
	.weak	_Start
	.type	_Start, %function
_Start:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8000008:	f8df d050 	ldr.w	sp, [pc, #80]	; 800005c <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
	movs	r1, #0
 800000c:	2100      	movs	r1, #0
	ldr	r2, =_sr_isrv
 800000e:	4a14      	ldr	r2, [pc, #80]	; (8000060 <LoopForever+0x6>)
	b	LoopCopyTextROInit
 8000010:	e003      	b.n	800001a <LoopCopyTextROInit>

08000012 <CopyTextROInit>:

CopyTextROInit:
	ldr	r3, =_sf_isrv
 8000012:	4b14      	ldr	r3, [pc, #80]	; (8000064 <LoopForever+0xa>)
	ldr	r3, [r3, r1]
 8000014:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8000016:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8000018:	3104      	adds	r1, #4

0800001a <LoopCopyTextROInit>:

LoopCopyTextROInit:
	ldr	r0, =_sr_isrv
 800001a:	4811      	ldr	r0, [pc, #68]	; (8000060 <LoopForever+0x6>)
	ldr	r3, =__read_only_end
 800001c:	4b12      	ldr	r3, [pc, #72]	; (8000068 <LoopForever+0xe>)
	adds	r2, r0, r1
 800001e:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8000020:	429a      	cmp	r2, r3
	bcc	CopyTextROInit
 8000022:	d3f6      	bcc.n	8000012 <CopyTextROInit>

	movs	r1, #0
 8000024:	2100      	movs	r1, #0
	ldr	r2, =_sdata
 8000026:	4a11      	ldr	r2, [pc, #68]	; (800006c <LoopForever+0x12>)
	b	LoopCopyDataInit
 8000028:	e003      	b.n	8000032 <LoopCopyDataInit>

0800002a <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 800002a:	4b11      	ldr	r3, [pc, #68]	; (8000070 <LoopForever+0x16>)
	ldr	r3, [r3, r1]
 800002c:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 800002e:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8000030:	3104      	adds	r1, #4

08000032 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8000032:	480e      	ldr	r0, [pc, #56]	; (800006c <LoopForever+0x12>)
	ldr	r3, =_edata
 8000034:	4b0f      	ldr	r3, [pc, #60]	; (8000074 <LoopForever+0x1a>)
	adds	r2, r0, r1
 8000036:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8000038:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 800003a:	d3f6      	bcc.n	800002a <CopyDataInit>

	ldr	r2, =_sbss
 800003c:	4a0e      	ldr	r2, [pc, #56]	; (8000078 <LoopForever+0x1e>)
	b	LoopFillZerobss
 800003e:	e002      	b.n	8000046 <LoopFillZerobss>

08000040 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8000040:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8000042:	f842 3b04 	str.w	r3, [r2], #4

08000046 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8000046:	4b0d      	ldr	r3, [pc, #52]	; (800007c <LoopForever+0x22>)
	cmp	r2, r3
 8000048:	429a      	cmp	r2, r3
	bcc	FillZerobss
 800004a:	d3f9      	bcc.n	8000040 <FillZerobss>
	b	Reset_Handler
 800004c:	e7ff      	b.n	800004e <Reset_Handler>

0800004e <Reset_Handler>:
 * @param  None
 * @retval : None
*/
Reset_Handler:
/* Call the clock system intitialization function.*/
    bl  SystemInit
 800004e:	f000 f81f 	bl	8000090 <__SystemInit_veneer>
/* Call static constructors */
    bl __libc_init_array
 8000052:	f000 f825 	bl	80000a0 <____libc_init_array_veneer>
/* Call the application's entry point.*/
    bl	main
 8000056:	f000 f813 	bl	8000080 <__main_veneer>

0800005a <LoopForever>:

LoopForever:
    b LoopForever
 800005a:	e7fe      	b.n	800005a <LoopForever>

    .section	.text._Start
	.weak	_Start
	.type	_Start, %function
_Start:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800005c:	20016fff 	.word	0x20016fff

/* Copy the data segment initializers from flash to SRAM */
	movs	r1, #0
	ldr	r2, =_sr_isrv
 8000060:	20000000 	.word	0x20000000
	b	LoopCopyTextROInit

CopyTextROInit:
	ldr	r3, =_sf_isrv
 8000064:	080000b0 	.word	0x080000b0
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyTextROInit:
	ldr	r0, =_sr_isrv
	ldr	r3, =__read_only_end
 8000068:	200066b8 	.word	0x200066b8
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyTextROInit

	movs	r1, #0
	ldr	r2, =_sdata
 800006c:	200066b8 	.word	0x200066b8
	b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8000070:	4000cd70 	.word	0x4000cd70
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
 8000074:	200066c6 	.word	0x200066c6
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit

	ldr	r2, =_sbss
 8000078:	200066c8 	.word	0x200066c8
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 800007c:	20008b7c 	.word	0x20008b7c

08000080 <__main_veneer>:
 8000080:	b401      	push	{r0}
 8000082:	4802      	ldr	r0, [pc, #8]	; (800008c <__main_veneer+0xc>)
 8000084:	4684      	mov	ip, r0
 8000086:	bc01      	pop	{r0}
 8000088:	4760      	bx	ip
 800008a:	bf00      	nop
 800008c:	20000391 	.word	0x20000391

08000090 <__SystemInit_veneer>:
 8000090:	b401      	push	{r0}
 8000092:	4802      	ldr	r0, [pc, #8]	; (800009c <__SystemInit_veneer+0xc>)
 8000094:	4684      	mov	ip, r0
 8000096:	bc01      	pop	{r0}
 8000098:	4760      	bx	ip
 800009a:	bf00      	nop
 800009c:	200005ad 	.word	0x200005ad

080000a0 <____libc_init_array_veneer>:
 80000a0:	b401      	push	{r0}
 80000a2:	4802      	ldr	r0, [pc, #8]	; (80000ac <____libc_init_array_veneer+0xc>)
 80000a4:	4684      	mov	ip, r0
 80000a6:	bc01      	pop	{r0}
 80000a8:	4760      	bx	ip
 80000aa:	bf00      	nop
 80000ac:	20000189 	.word	0x20000189

Disassembly of section .text:

20000188 <__libc_init_array>:
20000188:	b570      	push	{r4, r5, r6, lr}
2000018a:	4e0f      	ldr	r6, [pc, #60]	; (200001c8 <__libc_init_array+0x40>)
2000018c:	4d0f      	ldr	r5, [pc, #60]	; (200001cc <__libc_init_array+0x44>)
2000018e:	1b76      	subs	r6, r6, r5
20000190:	10b6      	asrs	r6, r6, #2
20000192:	bf18      	it	ne
20000194:	2400      	movne	r4, #0
20000196:	d005      	beq.n	200001a4 <__libc_init_array+0x1c>
20000198:	3401      	adds	r4, #1
2000019a:	f855 3b04 	ldr.w	r3, [r5], #4
2000019e:	4798      	blx	r3
200001a0:	42a6      	cmp	r6, r4
200001a2:	d1f9      	bne.n	20000198 <__libc_init_array+0x10>
200001a4:	4e0a      	ldr	r6, [pc, #40]	; (200001d0 <__libc_init_array+0x48>)
200001a6:	4d0b      	ldr	r5, [pc, #44]	; (200001d4 <__libc_init_array+0x4c>)
200001a8:	1b76      	subs	r6, r6, r5
200001aa:	f006 fa6b 	bl	20006684 <_init>
200001ae:	10b6      	asrs	r6, r6, #2
200001b0:	bf18      	it	ne
200001b2:	2400      	movne	r4, #0
200001b4:	d006      	beq.n	200001c4 <__libc_init_array+0x3c>
200001b6:	3401      	adds	r4, #1
200001b8:	f855 3b04 	ldr.w	r3, [r5], #4
200001bc:	4798      	blx	r3
200001be:	42a6      	cmp	r6, r4
200001c0:	d1f9      	bne.n	200001b6 <__libc_init_array+0x2e>
200001c2:	bd70      	pop	{r4, r5, r6, pc}
200001c4:	bd70      	pop	{r4, r5, r6, pc}
200001c6:	bf00      	nop
200001c8:	20006684 	.word	0x20006684
200001cc:	20006684 	.word	0x20006684
200001d0:	20006684 	.word	0x20006684
200001d4:	20006684 	.word	0x20006684

200001d8 <memset>:
200001d8:	b470      	push	{r4, r5, r6}
200001da:	0784      	lsls	r4, r0, #30
200001dc:	d046      	beq.n	2000026c <memset+0x94>
200001de:	1e54      	subs	r4, r2, #1
200001e0:	2a00      	cmp	r2, #0
200001e2:	d041      	beq.n	20000268 <memset+0x90>
200001e4:	b2cd      	uxtb	r5, r1
200001e6:	4603      	mov	r3, r0
200001e8:	e002      	b.n	200001f0 <memset+0x18>
200001ea:	1e62      	subs	r2, r4, #1
200001ec:	b3e4      	cbz	r4, 20000268 <memset+0x90>
200001ee:	4614      	mov	r4, r2
200001f0:	f803 5b01 	strb.w	r5, [r3], #1
200001f4:	079a      	lsls	r2, r3, #30
200001f6:	d1f8      	bne.n	200001ea <memset+0x12>
200001f8:	2c03      	cmp	r4, #3
200001fa:	d92e      	bls.n	2000025a <memset+0x82>
200001fc:	b2cd      	uxtb	r5, r1
200001fe:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
20000202:	2c0f      	cmp	r4, #15
20000204:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
20000208:	d919      	bls.n	2000023e <memset+0x66>
2000020a:	f103 0210 	add.w	r2, r3, #16
2000020e:	4626      	mov	r6, r4
20000210:	3e10      	subs	r6, #16
20000212:	2e0f      	cmp	r6, #15
20000214:	f842 5c10 	str.w	r5, [r2, #-16]
20000218:	f842 5c0c 	str.w	r5, [r2, #-12]
2000021c:	f842 5c08 	str.w	r5, [r2, #-8]
20000220:	f842 5c04 	str.w	r5, [r2, #-4]
20000224:	f102 0210 	add.w	r2, r2, #16
20000228:	d8f2      	bhi.n	20000210 <memset+0x38>
2000022a:	f1a4 0210 	sub.w	r2, r4, #16
2000022e:	f022 020f 	bic.w	r2, r2, #15
20000232:	f004 040f 	and.w	r4, r4, #15
20000236:	3210      	adds	r2, #16
20000238:	2c03      	cmp	r4, #3
2000023a:	4413      	add	r3, r2
2000023c:	d90d      	bls.n	2000025a <memset+0x82>
2000023e:	461e      	mov	r6, r3
20000240:	4622      	mov	r2, r4
20000242:	3a04      	subs	r2, #4
20000244:	2a03      	cmp	r2, #3
20000246:	f846 5b04 	str.w	r5, [r6], #4
2000024a:	d8fa      	bhi.n	20000242 <memset+0x6a>
2000024c:	1f22      	subs	r2, r4, #4
2000024e:	f022 0203 	bic.w	r2, r2, #3
20000252:	3204      	adds	r2, #4
20000254:	4413      	add	r3, r2
20000256:	f004 0403 	and.w	r4, r4, #3
2000025a:	b12c      	cbz	r4, 20000268 <memset+0x90>
2000025c:	b2c9      	uxtb	r1, r1
2000025e:	441c      	add	r4, r3
20000260:	f803 1b01 	strb.w	r1, [r3], #1
20000264:	42a3      	cmp	r3, r4
20000266:	d1fb      	bne.n	20000260 <memset+0x88>
20000268:	bc70      	pop	{r4, r5, r6}
2000026a:	4770      	bx	lr
2000026c:	4614      	mov	r4, r2
2000026e:	4603      	mov	r3, r0
20000270:	e7c2      	b.n	200001f8 <memset+0x20>
20000272:	bf00      	nop

20000274 <get_flash_reason>:
static uint32_t flash_reason;

uint32_t get_flash_reason(void)
{
    return flash_reason;
}
20000274:	4b01      	ldr	r3, [pc, #4]	; (2000027c <get_flash_reason+0x8>)
20000276:	6818      	ldr	r0, [r3, #0]
20000278:	4770      	bx	lr
2000027a:	bf00      	nop
2000027c:	200066d0 	.word	0x200066d0

20000280 <CheckFlashMode>:
  }
  return changed;
}

enum BootState CheckFlashMode(void)
{
20000280:	b538      	push	{r3, r4, r5, lr}
  char *bootModeFlag;
  enum BootState bootState = BOOT_STATE_NORMAL;

  MX_GPIO_Init();
20000282:	f001 f9d5 	bl	20001630 <MX_GPIO_Init>

static inline bool pcard_changed(void)
{
  bool changed = false;

  tftf_header *hdr = (tftf_header *)(mod_get_tftf_addr());
20000286:	f000 fb47 	bl	20000918 <mod_get_tftf_addr>
2000028a:	4605      	mov	r5, r0
  tvid = tftf_get_vid(hdr);
2000028c:	f001 f8ec 	bl	20001468 <tftf_get_vid>
20000290:	4c1a      	ldr	r4, [pc, #104]	; (200002fc <CheckFlashMode+0x7c>)
20000292:	6020      	str	r0, [r4, #0]
  tpid = tftf_get_pid(hdr);
20000294:	4628      	mov	r0, r5
20000296:	f001 f8e1 	bl	2000145c <tftf_get_pid>
  if (!eeprom_get_vid(vid) && !eeprom_get_pid(pid))
      return 0;
#endif

  if (vid) {
    *vid = _ids.board_vid;
2000029a:	4a19      	ldr	r2, [pc, #100]	; (20000300 <CheckFlashMode+0x80>)
{
  bool changed = false;

  tftf_header *hdr = (tftf_header *)(mod_get_tftf_addr());
  tvid = tftf_get_vid(hdr);
  tpid = tftf_get_pid(hdr);
2000029c:	4b19      	ldr	r3, [pc, #100]	; (20000304 <CheckFlashMode+0x84>)
  if (!eeprom_get_vid(vid) && !eeprom_get_pid(pid))
      return 0;
#endif

  if (vid) {
    *vid = _ids.board_vid;
2000029e:	491a      	ldr	r1, [pc, #104]	; (20000308 <CheckFlashMode+0x88>)
{
  bool changed = false;

  tftf_header *hdr = (tftf_header *)(mod_get_tftf_addr());
  tvid = tftf_get_vid(hdr);
  tpid = tftf_get_pid(hdr);
200002a0:	6018      	str	r0, [r3, #0]
  if (!eeprom_get_vid(vid) && !eeprom_get_pid(pid))
      return 0;
#endif

  if (vid) {
    *vid = _ids.board_vid;
200002a2:	6813      	ldr	r3, [r2, #0]
200002a4:	600b      	str	r3, [r1, #0]
  }

  if (pid) {
    *pid = _ids.board_pid;
200002a6:	6851      	ldr	r1, [r2, #4]
200002a8:	4a18      	ldr	r2, [pc, #96]	; (2000030c <CheckFlashMode+0x8c>)
200002aa:	6011      	str	r1, [r2, #0]
  /* Read the eeprom vid/pid, if that fails all we can
   * do is fall back to the base
   */
  get_board_id(&evid, &epid);

  if ((validate_vid && (tvid != evid)) ||
200002ac:	6822      	ldr	r2, [r4, #0]
200002ae:	429a      	cmp	r2, r3
200002b0:	d004      	beq.n	200002bc <CheckFlashMode+0x3c>

  MX_GPIO_Init();

  if (pcard_changed())
  {
      flash_reason = FLASH_REASON_NEW_IDS;
200002b2:	4b17      	ldr	r3, [pc, #92]	; (20000310 <CheckFlashMode+0x90>)
200002b4:	2207      	movs	r2, #7
200002b6:	601a      	str	r2, [r3, #0]
      bootState = BOOT_STATE_REQUEST_FLASH;
      return bootState;
200002b8:	2001      	movs	r0, #1
200002ba:	bd38      	pop	{r3, r4, r5, pc}
  }

  /* Check For Flash Mode Bit */
  bootModeFlag = (char *)mod_get_flashmode_addr();
200002bc:	f000 fb30 	bl	20000920 <mod_get_flashmode_addr>
  if (!memcmp(bootModeFlag, bootmode_flag, sizeof(bootmode_flag)))
200002c0:	4914      	ldr	r1, [pc, #80]	; (20000314 <CheckFlashMode+0x94>)
200002c2:	2208      	movs	r2, #8
      bootState = BOOT_STATE_REQUEST_FLASH;
      return bootState;
  }

  /* Check For Flash Mode Bit */
  bootModeFlag = (char *)mod_get_flashmode_addr();
200002c4:	4605      	mov	r5, r0
  if (!memcmp(bootModeFlag, bootmode_flag, sizeof(bootmode_flag)))
200002c6:	f005 fcab 	bl	20005c20 <memcmp>
200002ca:	b9a0      	cbnz	r0, 200002f6 <CheckFlashMode+0x76>
  {
    flash_reason = FLASH_REASON_BOOTMODE;
200002cc:	4b10      	ldr	r3, [pc, #64]	; (20000310 <CheckFlashMode+0x90>)
200002ce:	2401      	movs	r4, #1
200002d0:	601c      	str	r4, [r3, #0]
    bootState = BOOT_STATE_REQUEST_FLASH;
  }

  if (!memcmp(bootModeFlag, flashing_flag, sizeof(flashing_flag)))
200002d2:	4628      	mov	r0, r5
200002d4:	4910      	ldr	r1, [pc, #64]	; (20000318 <CheckFlashMode+0x98>)
200002d6:	2208      	movs	r2, #8
200002d8:	f005 fca2 	bl	20005c20 <memcmp>
200002dc:	b910      	cbnz	r0, 200002e4 <CheckFlashMode+0x64>
  {
    flash_reason = FLASH_REASON_FLASHING;
200002de:	4b0c      	ldr	r3, [pc, #48]	; (20000310 <CheckFlashMode+0x90>)
200002e0:	2402      	movs	r4, #2
200002e2:	601c      	str	r4, [r3, #0]
    bootState = BOOT_STATE_FLASHING;
  }

  if (mods_force_flash_get() == PIN_SET)
200002e4:	f001 fae6 	bl	200018b4 <mods_force_flash_get>
200002e8:	2801      	cmp	r0, #1
  {
    flash_reason = FLASH_REASON_FLASHPIN;
200002ea:	bf03      	ittte	eq
200002ec:	4b08      	ldreq	r3, [pc, #32]	; (20000310 <CheckFlashMode+0x90>)
200002ee:	2203      	moveq	r2, #3
200002f0:	601a      	streq	r2, [r3, #0]
  {
    flash_reason = FLASH_REASON_FLASHING;
    bootState = BOOT_STATE_FLASHING;
  }

  if (mods_force_flash_get() == PIN_SET)
200002f2:	4620      	movne	r0, r4
200002f4:	bd38      	pop	{r3, r4, r5, pc}
}

enum BootState CheckFlashMode(void)
{
  char *bootModeFlag;
  enum BootState bootState = BOOT_STATE_NORMAL;
200002f6:	2400      	movs	r4, #0
200002f8:	e7eb      	b.n	200002d2 <CheckFlashMode+0x52>
200002fa:	bf00      	nop
200002fc:	200066cc 	.word	0x200066cc
20000300:	2000669c 	.word	0x2000669c
20000304:	200066d4 	.word	0x200066d4
20000308:	200066d8 	.word	0x200066d8
2000030c:	200066c8 	.word	0x200066c8
20000310:	200066d0 	.word	0x200066d0
20000314:	20005db8 	.word	0x20005db8
20000318:	20005e9c 	.word	0x20005e9c

2000031c <get_board_id>:
#ifdef CONFIG_EEPROM_IDS
  if (!eeprom_get_vid(vid) && !eeprom_get_pid(pid))
      return 0;
#endif

  if (vid) {
2000031c:	b110      	cbz	r0, 20000324 <get_board_id+0x8>
    *vid = _ids.board_vid;
2000031e:	4b04      	ldr	r3, [pc, #16]	; (20000330 <get_board_id+0x14>)
20000320:	681b      	ldr	r3, [r3, #0]
20000322:	6003      	str	r3, [r0, #0]
  }

  if (pid) {
20000324:	b111      	cbz	r1, 2000032c <get_board_id+0x10>
    *pid = _ids.board_pid;
20000326:	4b02      	ldr	r3, [pc, #8]	; (20000330 <get_board_id+0x14>)
20000328:	685b      	ldr	r3, [r3, #4]
2000032a:	600b      	str	r3, [r1, #0]
  }

  return 0;
}
2000032c:	2000      	movs	r0, #0
2000032e:	4770      	bx	lr
20000330:	2000669c 	.word	0x2000669c

20000334 <get_chip_id>:

int get_chip_id(uint32_t *mfg, uint32_t *pid)
{
  if (mfg) {
20000334:	b110      	cbz	r0, 2000033c <get_chip_id+0x8>
    /* MIPI Manufacturer ID from http://mid.mipi.org/ */
    *mfg = _ids.chip_mfg;
20000336:	4b04      	ldr	r3, [pc, #16]	; (20000348 <get_chip_id+0x14>)
20000338:	689b      	ldr	r3, [r3, #8]
2000033a:	6003      	str	r3, [r0, #0]
  }

  if (pid) {
2000033c:	b111      	cbz	r1, 20000344 <get_chip_id+0x10>
    *pid = _ids.chip_pid;
2000033e:	4b02      	ldr	r3, [pc, #8]	; (20000348 <get_chip_id+0x14>)
20000340:	68db      	ldr	r3, [r3, #12]
20000342:	600b      	str	r3, [r1, #0]
  }

  return 0;
}
20000344:	2000      	movs	r0, #0
20000346:	4770      	bx	lr
20000348:	2000669c 	.word	0x2000669c

2000034c <set_flashing_flag>:

int set_flashing_flag(void)
{
2000034c:	b510      	push	{r4, lr}
  int ret = 0;
  char *bootModeFlag;

  /* Flash Mode Flag */
  bootModeFlag = (char *)mod_get_flashmode_addr();
2000034e:	f000 fae7 	bl	20000920 <mod_get_flashmode_addr>
  if (memcmp(bootModeFlag, flashing_flag, sizeof(flashing_flag)))
20000352:	490a      	ldr	r1, [pc, #40]	; (2000037c <set_flashing_flag+0x30>)
20000354:	2208      	movs	r2, #8
20000356:	f005 fc63 	bl	20005c20 <memcmp>
2000035a:	b158      	cbz	r0, 20000374 <set_flashing_flag+0x28>
  {
    /* write the flashmode flag */
    program_flash_unlock();
2000035c:	f000 fb56 	bl	20000a0c <program_flash_unlock>
    ret = program_flash_data(mod_get_flashmode_addr(),
20000360:	f000 fade 	bl	20000920 <mod_get_flashmode_addr>
20000364:	2108      	movs	r1, #8
20000366:	4a05      	ldr	r2, [pc, #20]	; (2000037c <set_flashing_flag+0x30>)
20000368:	f000 fb8c 	bl	20000a84 <program_flash_data>
2000036c:	4604      	mov	r4, r0
                             sizeof(flashing_flag),
                             (uint8_t *)&flashing_flag[0]);
    program_flash_lock();
2000036e:	f000 fb52 	bl	20000a16 <program_flash_lock>
20000372:	e000      	b.n	20000376 <set_flashing_flag+0x2a>
  return 0;
}

int set_flashing_flag(void)
{
  int ret = 0;
20000374:	4604      	mov	r4, r0
                             sizeof(flashing_flag),
                             (uint8_t *)&flashing_flag[0]);
    program_flash_lock();
  }
  return ret;
}
20000376:	4620      	mov	r0, r4
20000378:	bd10      	pop	{r4, pc}
2000037a:	bf00      	nop
2000037c:	20005e9c 	.word	0x20005e9c

20000380 <clr_flash_barker>:

void clr_flash_barker(void)
{
20000380:	b508      	push	{r3, lr}
    ErasePage(mod_get_flashmode_addr());
20000382:	f000 facd 	bl	20000920 <mod_get_flashmode_addr>
}
20000386:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return ret;
}

void clr_flash_barker(void)
{
    ErasePage(mod_get_flashmode_addr());
2000038a:	f000 baf7 	b.w	2000097c <ErasePage>
	...

20000390 <main>:
      dbgprint("error programming ids\r\n");
}
#endif

int main(void)
{
20000390:	b573      	push	{r0, r1, r4, r5, r6, lr}
  enum BootState bootState;

  SystemClock_Config();
20000392:	f001 f8d5 	bl	20001540 <SystemClock_Config>
#ifdef CONFIG_EEPROM_PROGRAMMING
  do_eeprom_programming();
#endif
#endif

  bootState = CheckFlashMode();
20000396:	f7ff ff73 	bl	20000280 <CheckFlashMode>
2000039a:	4c49      	ldr	r4, [pc, #292]	; (200004c0 <main+0x130>)

  switch(bootState) {
2000039c:	b120      	cbz	r0, 200003a8 <main+0x18>
2000039e:	2801      	cmp	r0, #1
200003a0:	d12f      	bne.n	20000402 <main+0x72>
    MX_USART_UART_Init();
    flash_reason = Boot2Partition();
    break;
  case BOOT_STATE_REQUEST_FLASH:
    /* Erase the Flash Mode Barker */
    clr_flash_barker();
200003a2:	f7ff ffed 	bl	20000380 <clr_flash_barker>
200003a6:	e02c      	b.n	20000402 <main+0x72>

  bootState = CheckFlashMode();

  switch(bootState) {
  case BOOT_STATE_NORMAL:
    MX_USART_UART_Init();
200003a8:	f001 f904 	bl	200015b4 <MX_USART_UART_Init>
  uint32_t jumpAddress;
  uint32_t imageAddress;
#ifdef CONFIG_MOD_SIGNATURE_VALIDATION
  uint16_t sIndex = 0;
#endif
  tftf_header *tf_header = (tftf_header *)(mod_get_tftf_addr());
200003ac:	f000 fab4 	bl	20000918 <mod_get_tftf_addr>
200003b0:	4605      	mov	r5, r0

  if (!valid_tftf_header(tf_header))
200003b2:	f000 ffeb 	bl	2000138c <valid_tftf_header>
200003b6:	b920      	cbnz	r0, 200003c2 <main+0x32>
  {
     dbgprint("valid_tftf_header failed\r\n");
200003b8:	4842      	ldr	r0, [pc, #264]	; (200004c4 <main+0x134>)
200003ba:	f004 fe71 	bl	200050a0 <dbgprint>
     return FLASH_REASON_INVALID_HDR;
200003be:	2304      	movs	r3, #4
200003c0:	e01e      	b.n	20000400 <main+0x70>
  }

  if (tftf_get_load_addr(tf_header, TFTF_SECTION_RAW_CODE, &imageAddress))
200003c2:	4628      	mov	r0, r5
200003c4:	2101      	movs	r1, #1
200003c6:	aa01      	add	r2, sp, #4
200003c8:	f001 f854 	bl	20001474 <tftf_get_load_addr>
200003cc:	4606      	mov	r6, r0
200003ce:	b9b0      	cbnz	r0, 200003fe <main+0x6e>
    return FLASH_REASON_INVALID_ADDR;

  jumpAddress = *(__IO uint32_t*)(imageAddress + JUMP_ADDRESS_OFFSET);
200003d0:	9b01      	ldr	r3, [sp, #4]
200003d2:	685d      	ldr	r5, [r3, #4]

  if ((jumpAddress >= mod_get_program_start_addr()) &&
200003d4:	f000 fab8 	bl	20000948 <mod_get_program_start_addr>
200003d8:	4285      	cmp	r5, r0
200003da:	d310      	bcc.n	200003fe <main+0x6e>
      (jumpAddress <= mod_get_program_end_addr()))
200003dc:	f000 fab8 	bl	20000950 <mod_get_program_end_addr>
  if (tftf_get_load_addr(tf_header, TFTF_SECTION_RAW_CODE, &imageAddress))
    return FLASH_REASON_INVALID_ADDR;

  jumpAddress = *(__IO uint32_t*)(imageAddress + JUMP_ADDRESS_OFFSET);

  if ((jumpAddress >= mod_get_program_start_addr()) &&
200003e0:	4285      	cmp	r5, r0
200003e2:	d80c      	bhi.n	200003fe <main+0x6e>
      dbgprint("validate_image_signature failed\r\n");
      return FLASH_REASON_INVALID_SIGN;
    }
#endif
    /* Return Clock Configuration to Default before booting */
    HAL_RCC_DeInit();
200003e4:	f002 f8de 	bl	200025a4 <HAL_RCC_DeInit>
    reset_systick();
200003e8:	f001 f874 	bl	200014d4 <reset_systick>
    chip_reset_irqs();
200003ec:	f001 f87a 	bl	200014e4 <chip_reset_irqs>

    \param [in]    priMask  Priority Mask
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
200003f0:	f386 8810 	msr	PRIMASK, r6

    __set_PRIMASK(0);

    /* Initialize the Stack Pointer */
    __set_MSP(*(__IO uint32_t*)imageAddress);
200003f4:	9b01      	ldr	r3, [sp, #4]
200003f6:	681b      	ldr	r3, [r3, #0]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
200003f8:	f383 8808 	msr	MSP, r3

    pJumpToFunction = (Function_Pointer)jumpAddress;
    pJumpToFunction();
200003fc:	47a8      	blx	r5
  }
  return FLASH_REASON_INVALID_ADDR;
200003fe:	2306      	movs	r3, #6
  bootState = CheckFlashMode();

  switch(bootState) {
  case BOOT_STATE_NORMAL:
    MX_USART_UART_Init();
    flash_reason = Boot2Partition();
20000400:	6023      	str	r3, [r4, #0]
  default:
    break;
  }

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
20000402:	f003 fa0b 	bl	2000381c <HAL_Init>
  return bootState;
}

static void _init(bool stay_in_bl)
{
  SystemClock_Config();
20000406:	f001 f89b 	bl	20001540 <SystemClock_Config>

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
2000040a:	f001 f911 	bl	20001630 <MX_GPIO_Init>
  MX_USART_UART_Init();
2000040e:	f001 f8d1 	bl	200015b4 <MX_USART_UART_Init>

  if (stay_in_bl)
  {
    MX_DMA_Init();
20000412:	f001 f8eb 	bl	200015ec <MX_DMA_Init>

#ifdef CONFIG_APBE_FLASH
    spi_flash_hal_init();
20000416:	f001 ff23 	bl	20002260 <spi_flash_hal_init>
#endif
    /* Config SPI NSS in interrupt mode */
    SPI_NSS_INT_CTRL_Config();
2000041a:	f001 fb1f 	bl	20001a5c <SPI_NSS_INT_CTRL_Config>

    dl_init();
2000041e:	f001 fc3f 	bl	20001ca0 <dl_init>
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  _init(true);

  dbgprint("\r\n--[MuC Loader v" CONFIG_VERSION_STRING ":" CONFIG_VERSION_BUILD "]\r\n");
20000422:	4829      	ldr	r0, [pc, #164]	; (200004c8 <main+0x138>)
20000424:	f004 fe3c 	bl	200050a0 <dbgprint>
  dbgprintx32("-Flash Mode (", flash_reason, ")\r\n");
20000428:	4828      	ldr	r0, [pc, #160]	; (200004cc <main+0x13c>)
2000042a:	6821      	ldr	r1, [r4, #0]
2000042c:	4a28      	ldr	r2, [pc, #160]	; (200004d0 <main+0x140>)
2000042e:	f004 fe6a 	bl	20005106 <dbgprintx32>
  if (flash_reason == FLASH_REASON_NEW_IDS) {
20000432:	6823      	ldr	r3, [r4, #0]
20000434:	2b07      	cmp	r3, #7
20000436:	d120      	bne.n	2000047a <main+0xea>
      dbgprint("        TFTF    BOOTLOADER  CHECKED    \r\n");
20000438:	4826      	ldr	r0, [pc, #152]	; (200004d4 <main+0x144>)
2000043a:	f004 fe31 	bl	200050a0 <dbgprint>
      dbgprintx32("VID: 0x", tvid, "\t"); dbgprintx32("0x", evid, "");
2000043e:	4b26      	ldr	r3, [pc, #152]	; (200004d8 <main+0x148>)
20000440:	4826      	ldr	r0, [pc, #152]	; (200004dc <main+0x14c>)
20000442:	6819      	ldr	r1, [r3, #0]
20000444:	4a26      	ldr	r2, [pc, #152]	; (200004e0 <main+0x150>)
20000446:	f004 fe5e 	bl	20005106 <dbgprintx32>
2000044a:	4b26      	ldr	r3, [pc, #152]	; (200004e4 <main+0x154>)
2000044c:	4a26      	ldr	r2, [pc, #152]	; (200004e8 <main+0x158>)
2000044e:	6819      	ldr	r1, [r3, #0]
20000450:	4826      	ldr	r0, [pc, #152]	; (200004ec <main+0x15c>)
20000452:	f004 fe58 	bl	20005106 <dbgprintx32>
      if (validate_vid)
          dbgprint("   YES\r\n");
20000456:	4826      	ldr	r0, [pc, #152]	; (200004f0 <main+0x160>)
20000458:	f004 fe22 	bl	200050a0 <dbgprint>
      else
          dbgprint("   NO\r\n");
      dbgprintx32("PID: 0x", tpid, "\t"); dbgprintx32("0x", epid, "");
2000045c:	4b25      	ldr	r3, [pc, #148]	; (200004f4 <main+0x164>)
2000045e:	4826      	ldr	r0, [pc, #152]	; (200004f8 <main+0x168>)
20000460:	6819      	ldr	r1, [r3, #0]
20000462:	4a1f      	ldr	r2, [pc, #124]	; (200004e0 <main+0x150>)
20000464:	f004 fe4f 	bl	20005106 <dbgprintx32>
20000468:	4b24      	ldr	r3, [pc, #144]	; (200004fc <main+0x16c>)
2000046a:	4820      	ldr	r0, [pc, #128]	; (200004ec <main+0x15c>)
2000046c:	6819      	ldr	r1, [r3, #0]
2000046e:	4a1e      	ldr	r2, [pc, #120]	; (200004e8 <main+0x158>)
20000470:	f004 fe49 	bl	20005106 <dbgprintx32>
      if (validate_pid)
          dbgprint("   YES\r\n");
      else
          dbgprint("   NO\r\n");
20000474:	4822      	ldr	r0, [pc, #136]	; (20000500 <main+0x170>)
20000476:	f004 fe13 	bl	200050a0 <dbgprint>
  }

  ramlog_reason();
2000047a:	f005 f8ef 	bl	2000565c <ramlog_reason>

  while (1) {
    if (!mod_dev_is_attached()) {
2000047e:	f001 fa2d 	bl	200018dc <mod_dev_is_attached>
20000482:	b9c8      	cbnz	r0, 200004b8 <main+0x128>
      dl_exit();
20000484:	f001 fc28 	bl	20001cd8 <dl_exit>
#ifdef CONFIG_SPIN_WHILE_DETACHED
      dbgprint("Detached - SPINNING\r\n");
20000488:	481e      	ldr	r0, [pc, #120]	; (20000504 <main+0x174>)
2000048a:	f004 fe09 	bl	200050a0 <dbgprint>
      while (!mod_dev_is_attached());
2000048e:	f001 fa25 	bl	200018dc <mod_dev_is_attached>
20000492:	2800      	cmp	r0, #0
20000494:	d0fb      	beq.n	2000048e <main+0xfe>
  return bootState;
}

static void _init(bool stay_in_bl)
{
  SystemClock_Config();
20000496:	f001 f853 	bl	20001540 <SystemClock_Config>

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
2000049a:	f001 f8c9 	bl	20001630 <MX_GPIO_Init>
  MX_USART_UART_Init();
2000049e:	f001 f889 	bl	200015b4 <MX_USART_UART_Init>

  if (stay_in_bl)
  {
    MX_DMA_Init();
200004a2:	f001 f8a3 	bl	200015ec <MX_DMA_Init>

#ifdef CONFIG_APBE_FLASH
    spi_flash_hal_init();
200004a6:	f001 fedb 	bl	20002260 <spi_flash_hal_init>
#endif
    /* Config SPI NSS in interrupt mode */
    SPI_NSS_INT_CTRL_Config();
200004aa:	f001 fad7 	bl	20001a5c <SPI_NSS_INT_CTRL_Config>

    dl_init();
200004ae:	f001 fbf7 	bl	20001ca0 <dl_init>
#else
      dbgprint("Detached - STOP2\r\n");
      HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
#endif
      _init(true);
      dbgprint("Back\r\n");
200004b2:	4815      	ldr	r0, [pc, #84]	; (20000508 <main+0x178>)
200004b4:	f004 fdf4 	bl	200050a0 <dbgprint>
    }

    setup_exchange();
200004b8:	f001 fcf8 	bl	20001eac <setup_exchange>
  }
200004bc:	e7df      	b.n	2000047e <main+0xee>
200004be:	bf00      	nop
200004c0:	200066d0 	.word	0x200066d0
200004c4:	20005dc0 	.word	0x20005dc0
200004c8:	20005ddb 	.word	0x20005ddb
200004cc:	20005dfb 	.word	0x20005dfb
200004d0:	20005e09 	.word	0x20005e09
200004d4:	20005e0d 	.word	0x20005e0d
200004d8:	200066cc 	.word	0x200066cc
200004dc:	20005e37 	.word	0x20005e37
200004e0:	20005e3f 	.word	0x20005e3f
200004e4:	200066d8 	.word	0x200066d8
200004e8:	20005e40 	.word	0x20005e40
200004ec:	20006439 	.word	0x20006439
200004f0:	20005e41 	.word	0x20005e41
200004f4:	200066d4 	.word	0x200066d4
200004f8:	20005e4a 	.word	0x20005e4a
200004fc:	200066c8 	.word	0x200066c8
20000500:	20005e52 	.word	0x20005e52
20000504:	20005e5a 	.word	0x20005e5a
20000508:	20005e70 	.word	0x20005e70

2000050c <set_request_flash>:
{
    ErasePage(mod_get_flashmode_addr());
}

int set_request_flash(void)
{
2000050c:	b510      	push	{r4, lr}
  int rv;
  program_flash_unlock();
2000050e:	f000 fa7d 	bl	20000a0c <program_flash_unlock>
  rv = program_flash_dword((uint64_t *)&bootmode_flag[0]);
20000512:	4804      	ldr	r0, [pc, #16]	; (20000524 <set_request_flash+0x18>)
20000514:	f000 fa84 	bl	20000a20 <program_flash_dword>
20000518:	4604      	mov	r4, r0
  program_flash_lock();
2000051a:	f000 fa7c 	bl	20000a16 <program_flash_lock>
  return rv;
}
2000051e:	4620      	mov	r0, r4
20000520:	bd10      	pop	{r4, pc}
20000522:	bf00      	nop
20000524:	20005db8 	.word	0x20005db8

20000528 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
20000528:	b510      	push	{r4, lr}
2000052a:	4604      	mov	r4, r0
#ifdef CONFIG_DATALINK_SPI
  if (mods_is_spi_csn(GPIO_Pin)) {
2000052c:	f000 ffec 	bl	20001508 <mods_is_spi_csn>
20000530:	b138      	cbz	r0, 20000542 <HAL_GPIO_EXTI_Callback+0x1a>
    mods_rfr_set(PIN_RESET);
20000532:	2000      	movs	r0, #0
20000534:	f001 fa22 	bl	2000197c <mods_rfr_set>
    mods_muc_int_set(PIN_RESET);
20000538:	2000      	movs	r0, #0
  } else
#endif
  {
      device_handle_exti(GPIO_Pin);
  }
}
2000053a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
#ifdef CONFIG_DATALINK_SPI
  if (mods_is_spi_csn(GPIO_Pin)) {
    mods_rfr_set(PIN_RESET);
    mods_muc_int_set(PIN_RESET);
2000053e:	f001 ba31 	b.w	200019a4 <mods_muc_int_set>
  } else
#endif
  {
      device_handle_exti(GPIO_Pin);
20000542:	4620      	mov	r0, r4
  }
}
20000544:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mods_rfr_set(PIN_RESET);
    mods_muc_int_set(PIN_RESET);
  } else
#endif
  {
      device_handle_exti(GPIO_Pin);
20000548:	f001 b970 	b.w	2000182c <device_handle_exti>

2000054c <HAL_SPI_ErrorCallback>:

#if defined(CONFIG_DATALINK_SPI) || defined(CONFIG_APBE_FLASH)
void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *_hspi)
{
#ifdef CONFIG_DATALINK_SPI
  if (_hspi->Instance == MOD_TO_BASE_SPI) {
2000054c:	6801      	ldr	r1, [r0, #0]
2000054e:	4b07      	ldr	r3, [pc, #28]	; (2000056c <HAL_SPI_ErrorCallback+0x20>)
20000550:	4299      	cmp	r1, r3
20000552:	d101      	bne.n	20000558 <HAL_SPI_ErrorCallback+0xc>
    dl_spi_error_handler(_hspi);
20000554:	f001 bc2e 	b.w	20001db4 <dl_spi_error_handler>
  } else
#endif
#ifdef CONFIG_APBE_FLASH
  if (_hspi->Instance == MOD_TO_SPI_FLASH) {
20000558:	4b05      	ldr	r3, [pc, #20]	; (20000570 <HAL_SPI_ErrorCallback+0x24>)
2000055a:	4299      	cmp	r1, r3
2000055c:	d101      	bne.n	20000562 <HAL_SPI_ErrorCallback+0x16>
    spi_flash_error_handler(_hspi);
2000055e:	f001 bf7b 	b.w	20002458 <spi_flash_error_handler>
  } else
#endif
  {
    dbgprintx32("ERR Invalid hspi ", (uint32_t)_hspi->Instance, "\r\n");
20000562:	4804      	ldr	r0, [pc, #16]	; (20000574 <HAL_SPI_ErrorCallback+0x28>)
20000564:	4a04      	ldr	r2, [pc, #16]	; (20000578 <HAL_SPI_ErrorCallback+0x2c>)
20000566:	f004 bdce 	b.w	20005106 <dbgprintx32>
2000056a:	bf00      	nop
2000056c:	40003800 	.word	0x40003800
20000570:	40013000 	.word	0x40013000
20000574:	20005e77 	.word	0x20005e77
20000578:	20005e34 	.word	0x20005e34

2000057c <HAL_SPI_TxRxCpltCallback>:
}

void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *_hspi)
{
#ifdef CONFIG_DATALINK_SPI
  if (_hspi->Instance == MOD_TO_BASE_SPI) {
2000057c:	6801      	ldr	r1, [r0, #0]
2000057e:	4b07      	ldr	r3, [pc, #28]	; (2000059c <HAL_SPI_TxRxCpltCallback+0x20>)
20000580:	4299      	cmp	r1, r3
20000582:	d101      	bne.n	20000588 <HAL_SPI_TxRxCpltCallback+0xc>
    dl_spi_transfer_complete(_hspi);
20000584:	f001 bc20 	b.w	20001dc8 <dl_spi_transfer_complete>
  } else
#endif
#ifdef CONFIG_APBE_FLASH
  if (_hspi->Instance == MOD_TO_SPI_FLASH) {
20000588:	4b05      	ldr	r3, [pc, #20]	; (200005a0 <HAL_SPI_TxRxCpltCallback+0x24>)
2000058a:	4299      	cmp	r1, r3
2000058c:	d101      	bne.n	20000592 <HAL_SPI_TxRxCpltCallback+0x16>
    spi_flash_transfer_complete(_hspi);
2000058e:	f001 bf5d 	b.w	2000244c <spi_flash_transfer_complete>
  } else
#endif
  {
    dbgprintx32("TxRx Invalid hspi ", (uint32_t)_hspi->Instance, "\r\n");
20000592:	4804      	ldr	r0, [pc, #16]	; (200005a4 <HAL_SPI_TxRxCpltCallback+0x28>)
20000594:	4a04      	ldr	r2, [pc, #16]	; (200005a8 <HAL_SPI_TxRxCpltCallback+0x2c>)
20000596:	f004 bdb6 	b.w	20005106 <dbgprintx32>
2000059a:	bf00      	nop
2000059c:	40003800 	.word	0x40003800
200005a0:	40013000 	.word	0x40013000
200005a4:	20005e89 	.word	0x20005e89
200005a8:	20005e34 	.word	0x20005e34

200005ac <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
200005ac:	490f      	ldr	r1, [pc, #60]	; (200005ec <SystemInit+0x40>)
200005ae:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
200005b2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
200005b6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
200005ba:	4b0d      	ldr	r3, [pc, #52]	; (200005f0 <SystemInit+0x44>)
200005bc:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
200005be:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
200005c0:	f042 0201 	orr.w	r2, r2, #1
200005c4:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
200005c6:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
200005c8:	681a      	ldr	r2, [r3, #0]
200005ca:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
200005ce:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
200005d2:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;
200005d4:	f44f 6200 	mov.w	r2, #2048	; 0x800
200005d8:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
200005da:	681a      	ldr	r2, [r3, #0]
200005dc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
200005e0:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
200005e2:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
200005e4:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
200005e8:	608b      	str	r3, [r1, #8]
200005ea:	4770      	bx	lr
200005ec:	e000ed00 	.word	0xe000ed00
200005f0:	40021000 	.word	0x40021000

200005f4 <HAL_MspInit>:
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
  __SYSCFG_CLK_ENABLE();
200005f4:	4b0b      	ldr	r3, [pc, #44]	; (20000624 <HAL_MspInit+0x30>)

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
200005f6:	b507      	push	{r0, r1, r2, lr}
  __SYSCFG_CLK_ENABLE();
200005f8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
200005fa:	f042 0201 	orr.w	r2, r2, #1
200005fe:	661a      	str	r2, [r3, #96]	; 0x60
20000600:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20000602:	f003 0301 	and.w	r3, r3, #1
20000606:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
20000608:	2003      	movs	r0, #3
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
  __SYSCFG_CLK_ENABLE();
2000060a:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
2000060c:	f003 f932 	bl	20003874 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
20000610:	2100      	movs	r1, #0
20000612:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20000616:	460a      	mov	r2, r1
20000618:	f003 f93e 	bl	20003898 <HAL_NVIC_SetPriority>

}
2000061c:	b003      	add	sp, #12
2000061e:	f85d fb04 	ldr.w	pc, [sp], #4
20000622:	bf00      	nop
20000624:	40021000 	.word	0x40021000

20000628 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
20000628:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  GPIO_InitTypeDef GPIO_InitStruct;

  if(hspi->Instance==SPI2)
2000062c:	6802      	ldr	r2, [r0, #0]
2000062e:	4b52      	ldr	r3, [pc, #328]	; (20000778 <HAL_SPI_MspInit+0x150>)
20000630:	429a      	cmp	r2, r3
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
20000632:	b088      	sub	sp, #32
20000634:	4605      	mov	r5, r0
  GPIO_InitTypeDef GPIO_InitStruct;

  if(hspi->Instance==SPI2)
20000636:	d142      	bne.n	200006be <HAL_SPI_MspInit+0x96>
  {
    /* Peripheral clock enable */
    __SPI2_CLK_ENABLE();
20000638:	f503 33ec 	add.w	r3, r3, #120832	; 0x1d800
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* Peripheral DMA init*/

    hdma_spi2_rx.Instance = DMA1_Channel4;
2000063c:	4c4f      	ldr	r4, [pc, #316]	; (2000077c <HAL_SPI_MspInit+0x154>)
  GPIO_InitTypeDef GPIO_InitStruct;

  if(hspi->Instance==SPI2)
  {
    /* Peripheral clock enable */
    __SPI2_CLK_ENABLE();
2000063e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_14|GPIO_PIN_12|GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
20000640:	484f      	ldr	r0, [pc, #316]	; (20000780 <HAL_SPI_MspInit+0x158>)
  GPIO_InitTypeDef GPIO_InitStruct;

  if(hspi->Instance==SPI2)
  {
    /* Peripheral clock enable */
    __SPI2_CLK_ENABLE();
20000642:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
20000646:	659a      	str	r2, [r3, #88]	; 0x58
20000648:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2000064a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000064e:	9301      	str	r3, [sp, #4]
20000650:	9b01      	ldr	r3, [sp, #4]
    PB15     ------> SPI2_MOSI
    PB14     ------> SPI2_MISO
    PB12     ------> SPI2_NSS
    PB13     ------> SPI2_SCK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_14|GPIO_PIN_12|GPIO_PIN_13;
20000652:	f44f 4370 	mov.w	r3, #61440	; 0xf000
20000656:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20000658:	2302      	movs	r3, #2
2000065a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
2000065c:	2303      	movs	r3, #3
    PB12     ------> SPI2_NSS
    PB13     ------> SPI2_SCK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_14|GPIO_PIN_12|GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
2000065e:	2600      	movs	r6, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
20000660:	a903      	add	r1, sp, #12
    PB13     ------> SPI2_SCK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_14|GPIO_PIN_12|GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20000662:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
20000664:	2305      	movs	r3, #5
20000666:	9307      	str	r3, [sp, #28]
    PB12     ------> SPI2_NSS
    PB13     ------> SPI2_SCK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_14|GPIO_PIN_12|GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20000668:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
2000066a:	f003 f97f 	bl	2000396c <HAL_GPIO_Init>

    /* Peripheral DMA init*/

    hdma_spi2_rx.Instance = DMA1_Channel4;
    hdma_spi2_rx.Init.Request = DMA_REQUEST_1;
2000066e:	4b45      	ldr	r3, [pc, #276]	; (20000784 <HAL_SPI_MspInit+0x15c>)
    hdma_spi2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
20000670:	60a6      	str	r6, [r4, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* Peripheral DMA init*/

    hdma_spi2_rx.Instance = DMA1_Channel4;
    hdma_spi2_rx.Init.Request = DMA_REQUEST_1;
20000672:	f04f 0901 	mov.w	r9, #1
    hdma_spi2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
20000676:	f04f 0880 	mov.w	r8, #128	; 0x80
    hdma_spi2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi2_rx.Init.Mode = DMA_NORMAL;
    hdma_spi2_rx.Init.Priority = DMA_PRIORITY_HIGH;
2000067a:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    HAL_DMA_Init(&hdma_spi2_rx);
2000067e:	4620      	mov	r0, r4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* Peripheral DMA init*/

    hdma_spi2_rx.Instance = DMA1_Channel4;
    hdma_spi2_rx.Init.Request = DMA_REQUEST_1;
20000680:	e884 0208 	stmia.w	r4, {r3, r9}
    hdma_spi2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
20000684:	60e6      	str	r6, [r4, #12]
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
20000686:	f8c4 8010 	str.w	r8, [r4, #16]
    hdma_spi2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
2000068a:	6166      	str	r6, [r4, #20]
    hdma_spi2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
2000068c:	61a6      	str	r6, [r4, #24]
    hdma_spi2_rx.Init.Mode = DMA_NORMAL;
2000068e:	61e6      	str	r6, [r4, #28]
    hdma_spi2_rx.Init.Priority = DMA_PRIORITY_HIGH;
20000690:	6227      	str	r7, [r4, #32]
    HAL_DMA_Init(&hdma_spi2_rx);
20000692:	f003 fe03 	bl	2000429c <HAL_DMA_Init>

    __HAL_LINKDMA(hspi,hdmarx,hdma_spi2_rx);
20000696:	65ac      	str	r4, [r5, #88]	; 0x58
20000698:	62a5      	str	r5, [r4, #40]	; 0x28

    hdma_spi2_tx.Instance = DMA1_Channel5;
2000069a:	4b3b      	ldr	r3, [pc, #236]	; (20000788 <HAL_SPI_MspInit+0x160>)
2000069c:	4c3b      	ldr	r4, [pc, #236]	; (2000078c <HAL_SPI_MspInit+0x164>)
    hdma_spi2_tx.Init.Request = DMA_REQUEST_1;
2000069e:	e884 0208 	stmia.w	r4, {r3, r9}
    hdma_spi2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi2_tx.Init.Mode = DMA_NORMAL;
    hdma_spi2_tx.Init.Priority = DMA_PRIORITY_HIGH;
    HAL_DMA_Init(&hdma_spi2_tx);
200006a2:	4620      	mov	r0, r4

    __HAL_LINKDMA(hspi,hdmarx,hdma_spi2_rx);

    hdma_spi2_tx.Instance = DMA1_Channel5;
    hdma_spi2_tx.Init.Request = DMA_REQUEST_1;
    hdma_spi2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
200006a4:	2310      	movs	r3, #16
200006a6:	60a3      	str	r3, [r4, #8]
    hdma_spi2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
200006a8:	60e6      	str	r6, [r4, #12]
    hdma_spi2_tx.Init.MemInc = DMA_MINC_ENABLE;
200006aa:	f8c4 8010 	str.w	r8, [r4, #16]
    hdma_spi2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
200006ae:	6166      	str	r6, [r4, #20]
    hdma_spi2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
200006b0:	61a6      	str	r6, [r4, #24]
    hdma_spi2_tx.Init.Mode = DMA_NORMAL;
200006b2:	61e6      	str	r6, [r4, #28]
    hdma_spi2_tx.Init.Priority = DMA_PRIORITY_HIGH;
200006b4:	6227      	str	r7, [r4, #32]
    HAL_DMA_Init(&hdma_spi2_tx);
200006b6:	f003 fdf1 	bl	2000429c <HAL_DMA_Init>

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi2_tx);
200006ba:	656c      	str	r4, [r5, #84]	; 0x54
200006bc:	62a5      	str	r5, [r4, #40]	; 0x28

  }
#ifdef CONFIG_APBE_FLASH
  if(hspi->Instance == MOD_TO_SPI_FLASH)
200006be:	682a      	ldr	r2, [r5, #0]
200006c0:	4b33      	ldr	r3, [pc, #204]	; (20000790 <HAL_SPI_MspInit+0x168>)
200006c2:	429a      	cmp	r2, r3
200006c4:	d154      	bne.n	20000770 <HAL_SPI_MspInit+0x148>
  {
    /* Peripheral clock enable */
    __SPI1_CLK_ENABLE();
200006c6:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
    PA7     ------> SPI1_MOSI
    PA6     ------> SPI1_MISO
    PA5     ------> SPI1_NSS
    PA4     ------> SPI1_SCK
    */
    memset(&GPIO_InitStruct, 0 , sizeof(GPIO_InitStruct));
200006ca:	2100      	movs	r1, #0
  }
#ifdef CONFIG_APBE_FLASH
  if(hspi->Instance == MOD_TO_SPI_FLASH)
  {
    /* Peripheral clock enable */
    __SPI1_CLK_ENABLE();
200006cc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
200006ce:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
200006d2:	661a      	str	r2, [r3, #96]	; 0x60
200006d4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200006d6:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    PA7     ------> SPI1_MOSI
    PA6     ------> SPI1_MISO
    PA5     ------> SPI1_NSS
    PA4     ------> SPI1_SCK
    */
    memset(&GPIO_InitStruct, 0 , sizeof(GPIO_InitStruct));
200006da:	2214      	movs	r2, #20
  }
#ifdef CONFIG_APBE_FLASH
  if(hspi->Instance == MOD_TO_SPI_FLASH)
  {
    /* Peripheral clock enable */
    __SPI1_CLK_ENABLE();
200006dc:	9302      	str	r3, [sp, #8]
    PA7     ------> SPI1_MOSI
    PA6     ------> SPI1_MISO
    PA5     ------> SPI1_NSS
    PA4     ------> SPI1_SCK
    */
    memset(&GPIO_InitStruct, 0 , sizeof(GPIO_InitStruct));
200006de:	a803      	add	r0, sp, #12
  }
#ifdef CONFIG_APBE_FLASH
  if(hspi->Instance == MOD_TO_SPI_FLASH)
  {
    /* Peripheral clock enable */
    __SPI1_CLK_ENABLE();
200006e0:	9b02      	ldr	r3, [sp, #8]
    PA7     ------> SPI1_MOSI
    PA6     ------> SPI1_MISO
    PA5     ------> SPI1_NSS
    PA4     ------> SPI1_SCK
    */
    memset(&GPIO_InitStruct, 0 , sizeof(GPIO_InitStruct));
200006e2:	f7ff fd79 	bl	200001d8 <memset>
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
200006e6:	23f0      	movs	r3, #240	; 0xf0
200006e8:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
200006ea:	2302      	movs	r3, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
200006ec:	2403      	movs	r4, #3
    PA5     ------> SPI1_NSS
    PA4     ------> SPI1_SCK
    */
    memset(&GPIO_InitStruct, 0 , sizeof(GPIO_InitStruct));
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
200006ee:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
200006f0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    memset(&GPIO_InitStruct, 0 , sizeof(GPIO_InitStruct));
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
200006f4:	2305      	movs	r3, #5
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
200006f6:	a903      	add	r1, sp, #12

    /*Configure GPIO pin : PA4 */
    GPIO_InitStruct.Pin = GPIO_PIN_SPI1_CS_N;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
200006f8:	2600      	movs	r6, #0
    memset(&GPIO_InitStruct, 0 , sizeof(GPIO_InitStruct));
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
200006fa:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /*Configure GPIO pin : PA4 */
    GPIO_InitStruct.Pin = GPIO_PIN_SPI1_CS_N;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
200006fc:	2701      	movs	r7, #1
    */
    memset(&GPIO_InitStruct, 0 , sizeof(GPIO_InitStruct));
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
200006fe:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /*Configure GPIO pin : PA4 */
    GPIO_InitStruct.Pin = GPIO_PIN_SPI1_CS_N;
20000700:	f04f 0a10 	mov.w	sl, #16
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
20000704:	f003 f932 	bl	2000396c <HAL_GPIO_Init>
    /*Configure GPIO pin : PA4 */
    GPIO_InitStruct.Pin = GPIO_PIN_SPI1_CS_N;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    HAL_GPIO_Init(GPIO_PORT_SPI1_CS_N, &GPIO_InitStruct);
20000708:	a903      	add	r1, sp, #12
2000070a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000

    /*Configure GPIO pin : PA4 */
    GPIO_InitStruct.Pin = GPIO_PIN_SPI1_CS_N;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
2000070e:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /*Configure GPIO pin : PA4 */
    GPIO_InitStruct.Pin = GPIO_PIN_SPI1_CS_N;
20000710:	f8cd a00c 	str.w	sl, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    HAL_GPIO_Init(GPIO_PORT_SPI1_CS_N, &GPIO_InitStruct);
    mods_muc_set_spi1_cs(PIN_SET);

    /* Peripheral DMA init*/
    hdma_spi1_rx.Instance = DMA1_Channel2;
20000714:	4c1f      	ldr	r4, [pc, #124]	; (20000794 <HAL_SPI_MspInit+0x16c>)
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /*Configure GPIO pin : PA4 */
    GPIO_InitStruct.Pin = GPIO_PIN_SPI1_CS_N;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
20000716:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20000718:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    HAL_GPIO_Init(GPIO_PORT_SPI1_CS_N, &GPIO_InitStruct);
2000071a:	f003 f927 	bl	2000396c <HAL_GPIO_Init>
    mods_muc_set_spi1_cs(PIN_SET);
2000071e:	4638      	mov	r0, r7
20000720:	f001 f926 	bl	20001970 <mods_muc_set_spi1_cs>

    /* Peripheral DMA init*/
    hdma_spi1_rx.Instance = DMA1_Channel2;
20000724:	4b1c      	ldr	r3, [pc, #112]	; (20000798 <HAL_SPI_MspInit+0x170>)
    hdma_spi1_rx.Init.Request = DMA_REQUEST_1;
    hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
20000726:	60a6      	str	r6, [r4, #8]
    hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
20000728:	f04f 0980 	mov.w	r9, #128	; 0x80
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_HIGH;
2000072c:	f44f 5800 	mov.w	r8, #8192	; 0x2000
    HAL_DMA_Init(&hdma_spi1_rx);
20000730:	4620      	mov	r0, r4
    HAL_GPIO_Init(GPIO_PORT_SPI1_CS_N, &GPIO_InitStruct);
    mods_muc_set_spi1_cs(PIN_SET);

    /* Peripheral DMA init*/
    hdma_spi1_rx.Instance = DMA1_Channel2;
    hdma_spi1_rx.Init.Request = DMA_REQUEST_1;
20000732:	e884 0088 	stmia.w	r4, {r3, r7}
    hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
20000736:	60e6      	str	r6, [r4, #12]
    hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
20000738:	f8c4 9010 	str.w	r9, [r4, #16]
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
2000073c:	6166      	str	r6, [r4, #20]
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
2000073e:	61a6      	str	r6, [r4, #24]
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
20000740:	61e6      	str	r6, [r4, #28]
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_HIGH;
20000742:	f8c4 8020 	str.w	r8, [r4, #32]
    HAL_DMA_Init(&hdma_spi1_rx);
20000746:	f003 fda9 	bl	2000429c <HAL_DMA_Init>

    __HAL_LINKDMA(hspi,hdmarx,hdma_spi1_rx);
2000074a:	65ac      	str	r4, [r5, #88]	; 0x58
2000074c:	62a5      	str	r5, [r4, #40]	; 0x28

    hdma_spi1_tx.Instance = DMA1_Channel3;
2000074e:	4c13      	ldr	r4, [pc, #76]	; (2000079c <HAL_SPI_MspInit+0x174>)
20000750:	4b13      	ldr	r3, [pc, #76]	; (200007a0 <HAL_SPI_MspInit+0x178>)
    hdma_spi1_tx.Init.Request = DMA_REQUEST_1;
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
20000752:	60e6      	str	r6, [r4, #12]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_HIGH;
    HAL_DMA_Init(&hdma_spi1_tx);
20000754:	4620      	mov	r0, r4

    __HAL_LINKDMA(hspi,hdmarx,hdma_spi1_rx);

    hdma_spi1_tx.Instance = DMA1_Channel3;
    hdma_spi1_tx.Init.Request = DMA_REQUEST_1;
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
20000756:	e884 0488 	stmia.w	r4, {r3, r7, sl}
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
2000075a:	f8c4 9010 	str.w	r9, [r4, #16]
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
2000075e:	6166      	str	r6, [r4, #20]
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
20000760:	61a6      	str	r6, [r4, #24]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
20000762:	61e6      	str	r6, [r4, #28]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_HIGH;
20000764:	f8c4 8020 	str.w	r8, [r4, #32]
    HAL_DMA_Init(&hdma_spi1_tx);
20000768:	f003 fd98 	bl	2000429c <HAL_DMA_Init>

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
2000076c:	656c      	str	r4, [r5, #84]	; 0x54
2000076e:	62a5      	str	r5, [r4, #40]	; 0x28

  }
#endif
}
20000770:	b008      	add	sp, #32
20000772:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
20000776:	bf00      	nop
20000778:	40003800 	.word	0x40003800
2000077c:	20006a68 	.word	0x20006a68
20000780:	48000400 	.word	0x48000400
20000784:	40020044 	.word	0x40020044
20000788:	40020058 	.word	0x40020058
2000078c:	20006aa4 	.word	0x20006aa4
20000790:	40013000 	.word	0x40013000
20000794:	20008ae8 	.word	0x20008ae8
20000798:	4002001c 	.word	0x4002001c
2000079c:	20008b24 	.word	0x20008b24
200007a0:	40020030 	.word	0x40020030

200007a4 <HAL_SPI_MspDeInit>:

void HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)
{
  if(hspi->Instance==SPI2)
200007a4:	6802      	ldr	r2, [r0, #0]
200007a6:	4b16      	ldr	r3, [pc, #88]	; (20000800 <HAL_SPI_MspDeInit+0x5c>)
200007a8:	429a      	cmp	r2, r3
  }
#endif
}

void HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)
{
200007aa:	b510      	push	{r4, lr}
200007ac:	4604      	mov	r4, r0
  if(hspi->Instance==SPI2)
200007ae:	d10f      	bne.n	200007d0 <HAL_SPI_MspDeInit+0x2c>
  {
    /* Peripheral clock disable */
    __SPI2_CLK_DISABLE();
200007b0:	4a14      	ldr	r2, [pc, #80]	; (20000804 <HAL_SPI_MspDeInit+0x60>)
    PB15     ------> SPI2_MOSI
    PB14     ------> SPI2_MISO
    PB12     ------> SPI2_NSS
    PB13     ------> SPI2_SCK
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_15|GPIO_PIN_14|GPIO_PIN_12|GPIO_PIN_13);
200007b2:	4815      	ldr	r0, [pc, #84]	; (20000808 <HAL_SPI_MspDeInit+0x64>)
void HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)
{
  if(hspi->Instance==SPI2)
  {
    /* Peripheral clock disable */
    __SPI2_CLK_DISABLE();
200007b4:	6d93      	ldr	r3, [r2, #88]	; 0x58
200007b6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
200007ba:	6593      	str	r3, [r2, #88]	; 0x58
    PB15     ------> SPI2_MOSI
    PB14     ------> SPI2_MISO
    PB12     ------> SPI2_NSS
    PB13     ------> SPI2_SCK
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_15|GPIO_PIN_14|GPIO_PIN_12|GPIO_PIN_13);
200007bc:	f44f 4170 	mov.w	r1, #61440	; 0xf000
200007c0:	f003 f9b2 	bl	20003b28 <HAL_GPIO_DeInit>

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hspi->hdmarx);
200007c4:	6da0      	ldr	r0, [r4, #88]	; 0x58
200007c6:	f003 fe37 	bl	20004438 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(hspi->hdmatx);
200007ca:	6d60      	ldr	r0, [r4, #84]	; 0x54
200007cc:	f003 fe34 	bl	20004438 <HAL_DMA_DeInit>
  }
#ifdef CONFIG_APBE_FLASH
  if(hspi->Instance == MOD_TO_SPI_FLASH)
200007d0:	6822      	ldr	r2, [r4, #0]
200007d2:	4b0e      	ldr	r3, [pc, #56]	; (2000080c <HAL_SPI_MspDeInit+0x68>)
200007d4:	429a      	cmp	r2, r3
200007d6:	d111      	bne.n	200007fc <HAL_SPI_MspDeInit+0x58>
  {
    /* Peripheral clock disable */
    __SPI1_CLK_DISABLE();
200007d8:	4a0a      	ldr	r2, [pc, #40]	; (20000804 <HAL_SPI_MspDeInit+0x60>)
200007da:	6e13      	ldr	r3, [r2, #96]	; 0x60
200007dc:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
200007e0:	6613      	str	r3, [r2, #96]	; 0x60
    PA7     ------> SPI1_MOSI
    PA6     ------> SPI1_MISO
    PA5     ------> SPI1_NSS
    PA4     ------> SPI1_SCK
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7);
200007e2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
200007e6:	21f0      	movs	r1, #240	; 0xf0
200007e8:	f003 f99e 	bl	20003b28 <HAL_GPIO_DeInit>

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hspi->hdmarx);
200007ec:	6da0      	ldr	r0, [r4, #88]	; 0x58
200007ee:	f003 fe23 	bl	20004438 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(hspi->hdmatx);
200007f2:	6d60      	ldr	r0, [r4, #84]	; 0x54
  }
#endif
}
200007f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7);

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hspi->hdmarx);
    HAL_DMA_DeInit(hspi->hdmatx);
200007f8:	f003 be1e 	b.w	20004438 <HAL_DMA_DeInit>
200007fc:	bd10      	pop	{r4, pc}
200007fe:	bf00      	nop
20000800:	40003800 	.word	0x40003800
20000804:	40021000 	.word	0x40021000
20000808:	48000400 	.word	0x48000400
2000080c:	40013000 	.word	0x40013000

20000810 <stm32_exti_multi_isr>:
{
    int pin;
    uint32_t pending;
    uint32_t gpio_pin; /* pin in HAL format */

    pending = getreg32(STM32_EXTI_PR1);
20000810:	4b06      	ldr	r3, [pc, #24]	; (2000082c <stm32_exti_multi_isr+0x1c>)
20000812:	681a      	ldr	r2, [r3, #0]

    for (pin = first; pin <= last; pin++) {
20000814:	4288      	cmp	r0, r1
20000816:	dc08      	bgt.n	2000082a <stm32_exti_multi_isr+0x1a>
        gpio_pin = (1 << pin);
20000818:	2301      	movs	r3, #1
2000081a:	4083      	lsls	r3, r0
        if (pending & gpio_pin) {
2000081c:	4213      	tst	r3, r2
2000081e:	d002      	beq.n	20000826 <stm32_exti_multi_isr+0x16>
            /* TODO: skip using HAL and then clear
             * with putreg32(gpio_pin, STM32_EXTI_PR1);
             * and dispatch directly
             * */
            HAL_GPIO_EXTI_IRQHandler(gpio_pin);
20000820:	b298      	uxth	r0, r3
20000822:	f003 ba23 	b.w	20003c6c <HAL_GPIO_EXTI_IRQHandler>
    uint32_t pending;
    uint32_t gpio_pin; /* pin in HAL format */

    pending = getreg32(STM32_EXTI_PR1);

    for (pin = first; pin <= last; pin++) {
20000826:	3001      	adds	r0, #1
20000828:	e7f4      	b.n	20000814 <stm32_exti_multi_isr+0x4>
             * */
            HAL_GPIO_EXTI_IRQHandler(gpio_pin);
            return;
        }
    }
}
2000082a:	4770      	bx	lr
2000082c:	40010414 	.word	0x40010414

20000830 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
20000830:	b508      	push	{r3, lr}
  HAL_IncTick();
20000832:	f003 f805 	bl	20003840 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
}
20000836:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
2000083a:	f003 b892 	b.w	20003962 <HAL_SYSTICK_IRQHandler>
	...

20000840 <DMA1_Channel4_IRQHandler>:
/**
* @brief This function handles DMA1 channel4 global interrupt.
*/
void DMA1_Channel4_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_spi2_rx);
20000840:	4801      	ldr	r0, [pc, #4]	; (20000848 <DMA1_Channel4_IRQHandler+0x8>)
20000842:	f004 b819 	b.w	20004878 <HAL_DMA_IRQHandler>
20000846:	bf00      	nop
20000848:	20006a68 	.word	0x20006a68

2000084c <DMA1_Channel2_IRQHandler>:
/**
* @brief This function handles DMA1 channel2 global interrupt.
*/
void DMA1_Channel2_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_spi1_rx);
2000084c:	4801      	ldr	r0, [pc, #4]	; (20000854 <DMA1_Channel2_IRQHandler+0x8>)
2000084e:	f004 b813 	b.w	20004878 <HAL_DMA_IRQHandler>
20000852:	bf00      	nop
20000854:	20008ae8 	.word	0x20008ae8

20000858 <DMA1_Channel3_IRQHandler>:
/**
* @brief This function handles DMA1 channel3 global interrupt.
*/
void DMA1_Channel3_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
20000858:	4801      	ldr	r0, [pc, #4]	; (20000860 <DMA1_Channel3_IRQHandler+0x8>)
2000085a:	f004 b80d 	b.w	20004878 <HAL_DMA_IRQHandler>
2000085e:	bf00      	nop
20000860:	20008b24 	.word	0x20008b24

20000864 <DMA1_Channel5_IRQHandler>:
/**
* @brief This function handles DMA1 channel5 global interrupt.
*/
void DMA1_Channel5_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_spi2_tx);
20000864:	4801      	ldr	r0, [pc, #4]	; (2000086c <DMA1_Channel5_IRQHandler+0x8>)
20000866:	f004 b807 	b.w	20004878 <HAL_DMA_IRQHandler>
2000086a:	bf00      	nop
2000086c:	20006aa4 	.word	0x20006aa4

20000870 <EXTI1_IRQHandler>:
/**
* @brief IRQ Handler for pin 1
*/
void EXTI1_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
20000870:	2002      	movs	r0, #2
20000872:	f003 b9fb 	b.w	20003c6c <HAL_GPIO_EXTI_IRQHandler>

20000876 <EXTI3_IRQHandler>:
/**
* @brief IRQ Handler for pin 2
*/
void EXTI3_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
20000876:	2008      	movs	r0, #8
20000878:	f003 b9f8 	b.w	20003c6c <HAL_GPIO_EXTI_IRQHandler>

2000087c <EXTI9_5_IRQHandler>:
/**
* @brief IRQ Handler for pins 5 through 9
*/
void EXTI9_5_IRQHandler(void)
{
  stm32_exti_multi_isr(5, 9);
2000087c:	2005      	movs	r0, #5
2000087e:	2109      	movs	r1, #9
20000880:	f7ff bfc6 	b.w	20000810 <stm32_exti_multi_isr>

20000884 <EXTI15_10_IRQHandler>:
/**
* @brief IRQ Handler for pins 10 through 15
*/
void EXTI15_10_IRQHandler (void)
{
  stm32_exti_multi_isr(10, 15);
20000884:	200a      	movs	r0, #10
20000886:	210f      	movs	r1, #15
20000888:	f7ff bfc2 	b.w	20000810 <stm32_exti_multi_isr>

2000088c <GetPage>:
  */
static uint32_t GetPage(uint32_t Addr)
{
  uint32_t page = 0;

  if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
2000088c:	4b0b      	ldr	r3, [pc, #44]	; (200008bc <GetPage+0x30>)
2000088e:	881b      	ldrh	r3, [r3, #0]
20000890:	f64f 72ff 	movw	r2, #65535	; 0xffff
20000894:	4293      	cmp	r3, r2
20000896:	d009      	beq.n	200008ac <GetPage+0x20>
20000898:	f3c3 030b 	ubfx	r3, r3, #0, #12
2000089c:	025b      	lsls	r3, r3, #9
2000089e:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
200008a2:	4298      	cmp	r0, r3
200008a4:	d206      	bcs.n	200008b4 <GetPage+0x28>
  {
    /* Bank 1 */
    page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
200008a6:	f100 4078 	add.w	r0, r0, #4160749568	; 0xf8000000
200008aa:	e004      	b.n	200008b6 <GetPage+0x2a>
  */
static uint32_t GetPage(uint32_t Addr)
{
  uint32_t page = 0;

  if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
200008ac:	4b04      	ldr	r3, [pc, #16]	; (200008c0 <GetPage+0x34>)
200008ae:	4298      	cmp	r0, r3
200008b0:	d9f9      	bls.n	200008a6 <GetPage+0x1a>
    page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
  }
  else
  {
    /* Bank 2 */
    page = (Addr - (FLASH_BASE + FLASH_BANK_SIZE)) / FLASH_PAGE_SIZE;
200008b2:	3301      	adds	r3, #1
200008b4:	1ac0      	subs	r0, r0, r3
200008b6:	0ac0      	lsrs	r0, r0, #11
200008b8:	4770      	bx	lr
200008ba:	bf00      	nop
200008bc:	1fff75e0 	.word	0x1fff75e0
200008c0:	0807ffff 	.word	0x0807ffff

200008c4 <GetBank>:
  */
static uint32_t GetBank(uint32_t Addr)
{
  uint32_t bank = 0;

  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0)
200008c4:	4b11      	ldr	r3, [pc, #68]	; (2000090c <GetBank+0x48>)
200008c6:	4a12      	ldr	r2, [pc, #72]	; (20000910 <GetBank+0x4c>)
200008c8:	681b      	ldr	r3, [r3, #0]
200008ca:	f413 7f80 	tst.w	r3, #256	; 0x100
200008ce:	f64f 73ff 	movw	r3, #65535	; 0xffff
200008d2:	d10d      	bne.n	200008f0 <GetBank+0x2c>
  {
    /* No Bank swap */
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
200008d4:	8811      	ldrh	r1, [r2, #0]
200008d6:	4299      	cmp	r1, r3
200008d8:	bf1b      	ittet	ne
200008da:	f3c1 020b 	ubfxne	r2, r1, #0, #12
200008de:	0252      	lslne	r2, r2, #9
200008e0:	4a0c      	ldreq	r2, [pc, #48]	; (20000914 <GetBank+0x50>)
200008e2:	f102 6200 	addne.w	r2, r2, #134217728	; 0x8000000
    {
      bank = FLASH_BANK_1;
    }
    else
    {
      bank = FLASH_BANK_2;
200008e6:	4290      	cmp	r0, r2
200008e8:	bf34      	ite	cc
200008ea:	2001      	movcc	r0, #1
200008ec:	2002      	movcs	r0, #2
200008ee:	4770      	bx	lr
    }
  }
  else
  {
    /* Bank swap */
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
200008f0:	8812      	ldrh	r2, [r2, #0]
200008f2:	429a      	cmp	r2, r3
200008f4:	bf1b      	ittet	ne
200008f6:	f3c2 030b 	ubfxne	r3, r2, #0, #12
200008fa:	025b      	lslne	r3, r3, #9
200008fc:	4b05      	ldreq	r3, [pc, #20]	; (20000914 <GetBank+0x50>)
200008fe:	f103 6300 	addne.w	r3, r3, #134217728	; 0x8000000
    {
      bank = FLASH_BANK_2;
    }
    else
    {
      bank = FLASH_BANK_1;
20000902:	4298      	cmp	r0, r3
20000904:	bf34      	ite	cc
20000906:	2002      	movcc	r0, #2
20000908:	2001      	movcs	r0, #1
    }
  }

  return bank;
}
2000090a:	4770      	bx	lr
2000090c:	40010000 	.word	0x40010000
20000910:	1fff75e0 	.word	0x1fff75e0
20000914:	08080000 	.word	0x08080000

20000918 <mod_get_tftf_addr>:
#endif

uint32_t mod_get_tftf_addr(void)
{
  return (uint32_t)(PARTITION_TFTF_START);
}
20000918:	4800      	ldr	r0, [pc, #0]	; (2000091c <mod_get_tftf_addr+0x4>)
2000091a:	4770      	bx	lr
2000091c:	08008000 	.word	0x08008000

20000920 <mod_get_flashmode_addr>:

uint32_t mod_get_flashmode_addr(void)
{
    return (uint32_t)(PARTITION_FLASHMODE_START);
20000920:	4b07      	ldr	r3, [pc, #28]	; (20000940 <mod_get_flashmode_addr+0x20>)
20000922:	8818      	ldrh	r0, [r3, #0]
20000924:	f64f 73ff 	movw	r3, #65535	; 0xffff
20000928:	4298      	cmp	r0, r3
2000092a:	bf1f      	itttt	ne
2000092c:	f3c0 000b 	ubfxne	r0, r0, #0, #12
20000930:	0280      	lslne	r0, r0, #10
20000932:	f100 60ff 	addne.w	r0, r0, #133693440	; 0x7f80000
20000936:	f500 20ff 	addne.w	r0, r0, #522240	; 0x7f800
2000093a:	bf08      	it	eq
2000093c:	4801      	ldreq	r0, [pc, #4]	; (20000944 <mod_get_flashmode_addr+0x24>)
}
2000093e:	4770      	bx	lr
20000940:	1fff75e0 	.word	0x1fff75e0
20000944:	080ff800 	.word	0x080ff800

20000948 <mod_get_program_start_addr>:

uint32_t mod_get_program_start_addr(void)
{
    return PARTITION_MAIN_START;
}
20000948:	4800      	ldr	r0, [pc, #0]	; (2000094c <mod_get_program_start_addr+0x4>)
2000094a:	4770      	bx	lr
2000094c:	08008200 	.word	0x08008200

20000950 <mod_get_program_end_addr>:

uint32_t mod_get_program_end_addr(void)
{
    return PARTITION_MAIN_END;
20000950:	4b08      	ldr	r3, [pc, #32]	; (20000974 <mod_get_program_end_addr+0x24>)
20000952:	8818      	ldrh	r0, [r3, #0]
20000954:	f64f 73ff 	movw	r3, #65535	; 0xffff
20000958:	4298      	cmp	r0, r3
2000095a:	bf1f      	itttt	ne
2000095c:	f3c0 000b 	ubfxne	r0, r0, #0, #12
20000960:	0280      	lslne	r0, r0, #10
20000962:	f100 6000 	addne.w	r0, r0, #134217728	; 0x8000000
20000966:	f46f 6300 	mvnne.w	r3, #2048	; 0x800
2000096a:	bf14      	ite	ne
2000096c:	18c0      	addne	r0, r0, r3
2000096e:	4802      	ldreq	r0, [pc, #8]	; (20000978 <mod_get_program_end_addr+0x28>)
}
20000970:	4770      	bx	lr
20000972:	bf00      	nop
20000974:	1fff75e0 	.word	0x1fff75e0
20000978:	080ff7ff 	.word	0x080ff7ff

2000097c <ErasePage>:

void ErasePage(uint32_t pageAddress)
{
2000097c:	b570      	push	{r4, r5, r6, lr}
2000097e:	b086      	sub	sp, #24
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t FirstPage = 0, NbOfPages = 0, BankNumber = 0, PAGEError = 0;
20000980:	2400      	movs	r4, #0
{
    return PARTITION_MAIN_END;
}

void ErasePage(uint32_t pageAddress)
{
20000982:	4605      	mov	r5, r0
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t FirstPage = 0, NbOfPages = 0, BankNumber = 0, PAGEError = 0;
20000984:	9401      	str	r4, [sp, #4]

  /* Unlock the Flash to enable the flash control register access */
  HAL_FLASH_Unlock();
20000986:	f004 fa27 	bl	20004dd8 <HAL_FLASH_Unlock>

  /* Clear OPTVERR bit set on virgin samples */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
2000098a:	4b0c      	ldr	r3, [pc, #48]	; (200009bc <ErasePage+0x40>)
2000098c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
20000990:	611a      	str	r2, [r3, #16]

  /* Get the 1st page to erase */
  FirstPage = GetPage(pageAddress);
20000992:	4628      	mov	r0, r5
20000994:	f7ff ff7a 	bl	2000088c <GetPage>
20000998:	4606      	mov	r6, r0
  /* Get the number of pages to erase from 1st page */
  NbOfPages = 1;
  /* Get the bank */
  BankNumber = GetBank(pageAddress);
2000099a:	4628      	mov	r0, r5
2000099c:	f7ff ff92 	bl	200008c4 <GetBank>
  /* Fill EraseInit structure*/
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
  EraseInitStruct.Banks       = BankNumber;
  EraseInitStruct.Page        = FirstPage;
  EraseInitStruct.NbPages     = NbOfPages;
200009a0:	2301      	movs	r3, #1
  NbOfPages = 1;
  /* Get the bank */
  BankNumber = GetBank(pageAddress);
  /* Fill EraseInit structure*/
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
  EraseInitStruct.Banks       = BankNumber;
200009a2:	9003      	str	r0, [sp, #12]
  EraseInitStruct.Page        = FirstPage;
  EraseInitStruct.NbPages     = NbOfPages;

  HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError);
200009a4:	a901      	add	r1, sp, #4
200009a6:	a802      	add	r0, sp, #8
  BankNumber = GetBank(pageAddress);
  /* Fill EraseInit structure*/
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
  EraseInitStruct.Banks       = BankNumber;
  EraseInitStruct.Page        = FirstPage;
  EraseInitStruct.NbPages     = NbOfPages;
200009a8:	9305      	str	r3, [sp, #20]
  /* Get the number of pages to erase from 1st page */
  NbOfPages = 1;
  /* Get the bank */
  BankNumber = GetBank(pageAddress);
  /* Fill EraseInit structure*/
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
200009aa:	9402      	str	r4, [sp, #8]
  EraseInitStruct.Banks       = BankNumber;
  EraseInitStruct.Page        = FirstPage;
200009ac:	9604      	str	r6, [sp, #16]
  EraseInitStruct.NbPages     = NbOfPages;

  HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError);
200009ae:	f004 fb09 	bl	20004fc4 <HAL_FLASHEx_Erase>

  HAL_FLASH_Lock();
200009b2:	f004 fa23 	bl	20004dfc <HAL_FLASH_Lock>
}
200009b6:	b006      	add	sp, #24
200009b8:	bd70      	pop	{r4, r5, r6, pc}
200009ba:	bf00      	nop
200009bc:	40022000 	.word	0x40022000

200009c0 <flash_erase>:

int flash_erase(uint32_t start_addr, uint32_t size)
{
200009c0:	b5f0      	push	{r4, r5, r6, r7, lr}
200009c2:	b087      	sub	sp, #28
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t FirstPage = 0, NbOfPages = 0, BankNumber = 0, PAGEError = 0;
200009c4:	2700      	movs	r7, #0
  uint32_t end_addr = start_addr + size;
200009c6:	1844      	adds	r4, r0, r1

  HAL_FLASH_Lock();
}

int flash_erase(uint32_t start_addr, uint32_t size)
{
200009c8:	4605      	mov	r5, r0
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t FirstPage = 0, NbOfPages = 0, BankNumber = 0, PAGEError = 0;
200009ca:	9701      	str	r7, [sp, #4]
  uint32_t end_addr = start_addr + size;

  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
200009cc:	f004 fa04 	bl	20004dd8 <HAL_FLASH_Unlock>

  /* Erase the user Flash area */

  /* Clear OPTVERR bit set on virgin samples */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
200009d0:	4b0d      	ldr	r3, [pc, #52]	; (20000a08 <flash_erase+0x48>)
200009d2:	f44f 4200 	mov.w	r2, #32768	; 0x8000
200009d6:	611a      	str	r2, [r3, #16]
  /* Get the 1st page to erase */
  FirstPage = GetPage(start_addr);
200009d8:	4628      	mov	r0, r5
200009da:	f7ff ff57 	bl	2000088c <GetPage>
200009de:	4606      	mov	r6, r0
  /* Get the number of pages to erase from 1st page */
  NbOfPages = GetPage(end_addr) - FirstPage + 1;
200009e0:	4620      	mov	r0, r4
200009e2:	f7ff ff53 	bl	2000088c <GetPage>
200009e6:	3001      	adds	r0, #1
200009e8:	1b84      	subs	r4, r0, r6
  /* Get the bank */
  BankNumber = GetBank(start_addr);
200009ea:	4628      	mov	r0, r5
200009ec:	f7ff ff6a 	bl	200008c4 <GetBank>

  /* Note: If an erase operation in Flash memory also concerns data in the data or instruction cache,
     you have to make sure that these data are rewritten before they are accessed during code
     execution. If this cannot be done safely, it is recommended to flush the caches by setting the
     DCRST and ICRST bits in the FLASH_CR register. */
  if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK)
200009f0:	a901      	add	r1, sp, #4
  NbOfPages = GetPage(end_addr) - FirstPage + 1;
  /* Get the bank */
  BankNumber = GetBank(start_addr);
  /* Fill EraseInit structure*/
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
  EraseInitStruct.Banks       = BankNumber;
200009f2:	9003      	str	r0, [sp, #12]

  /* Note: If an erase operation in Flash memory also concerns data in the data or instruction cache,
     you have to make sure that these data are rewritten before they are accessed during code
     execution. If this cannot be done safely, it is recommended to flush the caches by setting the
     DCRST and ICRST bits in the FLASH_CR register. */
  if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK)
200009f4:	a802      	add	r0, sp, #8
  /* Get the number of pages to erase from 1st page */
  NbOfPages = GetPage(end_addr) - FirstPage + 1;
  /* Get the bank */
  BankNumber = GetBank(start_addr);
  /* Fill EraseInit structure*/
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
200009f6:	9702      	str	r7, [sp, #8]
  EraseInitStruct.Banks       = BankNumber;
  EraseInitStruct.Page        = FirstPage;
200009f8:	9604      	str	r6, [sp, #16]
  EraseInitStruct.NbPages     = NbOfPages;
200009fa:	9405      	str	r4, [sp, #20]

  /* Note: If an erase operation in Flash memory also concerns data in the data or instruction cache,
     you have to make sure that these data are rewritten before they are accessed during code
     execution. If this cannot be done safely, it is recommended to flush the caches by setting the
     DCRST and ICRST bits in the FLASH_CR register. */
  if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK)
200009fc:	f004 fae2 	bl	20004fc4 <HAL_FLASHEx_Erase>
20000a00:	b100      	cbz	r0, 20000a04 <flash_erase+0x44>
      PAGEError will contain the faulty page and then to know the code error on this page,
      user can call function 'HAL_FLASH_GetError()'
    */
    /* Infinite loop */
    while (1) {
    }
20000a02:	e7fe      	b.n	20000a02 <flash_erase+0x42>
  }
  return 0;
}
20000a04:	b007      	add	sp, #28
20000a06:	bdf0      	pop	{r4, r5, r6, r7, pc}
20000a08:	40022000 	.word	0x40022000

20000a0c <program_flash_unlock>:

int program_flash_unlock(void)
{
20000a0c:	b508      	push	{r3, lr}
    HAL_FLASH_Unlock();
20000a0e:	f004 f9e3 	bl	20004dd8 <HAL_FLASH_Unlock>
    return 0;
}
20000a12:	2000      	movs	r0, #0
20000a14:	bd08      	pop	{r3, pc}

20000a16 <program_flash_lock>:

int program_flash_lock(void)
{
20000a16:	b508      	push	{r3, lr}
    HAL_FLASH_Lock();
20000a18:	f004 f9f0 	bl	20004dfc <HAL_FLASH_Lock>
    return 0;
}
20000a1c:	2000      	movs	r0, #0
20000a1e:	bd08      	pop	{r3, pc}

20000a20 <program_flash_dword>:

int program_flash_dword(const uint64_t *dword)
{
20000a20:	b538      	push	{r3, r4, r5, lr}
    int rv;

    dbgprintx32("program_flash_dword ", PARTITION_FLASHMODE_START, "\r\n");
20000a22:	4b14      	ldr	r3, [pc, #80]	; (20000a74 <program_flash_dword+0x54>)
20000a24:	8819      	ldrh	r1, [r3, #0]
20000a26:	f64f 72ff 	movw	r2, #65535	; 0xffff
20000a2a:	4291      	cmp	r1, r2
20000a2c:	bf1e      	ittt	ne
20000a2e:	f3c1 010b 	ubfxne	r1, r1, #0, #12
20000a32:	0289      	lslne	r1, r1, #10
20000a34:	f101 61ff 	addne.w	r1, r1, #133693440	; 0x7f80000
20000a38:	461d      	mov	r5, r3
20000a3a:	bf14      	ite	ne
20000a3c:	f501 21ff 	addne.w	r1, r1, #522240	; 0x7f800
20000a40:	490d      	ldreq	r1, [pc, #52]	; (20000a78 <program_flash_dword+0x58>)
20000a42:	4a0e      	ldr	r2, [pc, #56]	; (20000a7c <program_flash_dword+0x5c>)
    HAL_FLASH_Lock();
    return 0;
}

int program_flash_dword(const uint64_t *dword)
{
20000a44:	4604      	mov	r4, r0
    int rv;

    dbgprintx32("program_flash_dword ", PARTITION_FLASHMODE_START, "\r\n");
20000a46:	480e      	ldr	r0, [pc, #56]	; (20000a80 <program_flash_dword+0x60>)
20000a48:	f004 fb5d 	bl	20005106 <dbgprintx32>
    rv = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, PARTITION_FLASHMODE_START, *dword);
20000a4c:	8829      	ldrh	r1, [r5, #0]
20000a4e:	f64f 73ff 	movw	r3, #65535	; 0xffff
20000a52:	4299      	cmp	r1, r3
20000a54:	bf1f      	itttt	ne
20000a56:	f3c1 010b 	ubfxne	r1, r1, #0, #12
20000a5a:	0289      	lslne	r1, r1, #10
20000a5c:	f101 61ff 	addne.w	r1, r1, #133693440	; 0x7f80000
20000a60:	f501 21ff 	addne.w	r1, r1, #522240	; 0x7f800
20000a64:	bf08      	it	eq
20000a66:	4904      	ldreq	r1, [pc, #16]	; (20000a78 <program_flash_dword+0x58>)
20000a68:	e9d4 2300 	ldrd	r2, r3, [r4]
20000a6c:	2000      	movs	r0, #0
20000a6e:	f004 fa13 	bl	20004e98 <HAL_FLASH_Program>
    return rv;
}
20000a72:	bd38      	pop	{r3, r4, r5, pc}
20000a74:	1fff75e0 	.word	0x1fff75e0
20000a78:	080ff800 	.word	0x080ff800
20000a7c:	20005e34 	.word	0x20005e34
20000a80:	20005ee4 	.word	0x20005ee4

20000a84 <program_flash_data>:

int program_flash_data(uint32_t start, uint32_t size, uint8_t *data)
{
20000a84:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
20000a88:	4606      	mov	r6, r0
20000a8a:	460d      	mov	r5, r1
20000a8c:	4617      	mov	r7, r2
  uint64_t data64;
  uint32_t offset = 0;
20000a8e:	2400      	movs	r4, #0

  while (offset < size) {
20000a90:	42ac      	cmp	r4, r5
20000a92:	eb04 0806 	add.w	r8, r4, r6
20000a96:	d21c      	bcs.n	20000ad2 <program_flash_data+0x4e>
    data64 = 0xFFFFFFFFFFFFFFFF;
20000a98:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20000a9c:	a802      	add	r0, sp, #8
20000a9e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
20000aa2:	e960 2302 	strd	r2, r3, [r0, #-8]!
20000aa6:	1b2a      	subs	r2, r5, r4
    if((size - offset) < 8) {
20000aa8:	2a07      	cmp	r2, #7
20000aaa:	eb07 0104 	add.w	r1, r7, r4
20000aae:	d802      	bhi.n	20000ab6 <program_flash_data+0x32>
      memcpy((uint8_t *)&data64, (uint8_t *)&data[offset], (size - offset));
20000ab0:	f005 f8e8 	bl	20005c84 <memcpy>
20000ab4:	e003      	b.n	20000abe <program_flash_data+0x3a>
    } else {
      memcpy((uint8_t *)&data64, (uint8_t *)&data[offset], 8);
20000ab6:	4603      	mov	r3, r0
20000ab8:	6808      	ldr	r0, [r1, #0]
20000aba:	6849      	ldr	r1, [r1, #4]
20000abc:	c303      	stmia	r3!, {r0, r1}
    }

    if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, start, data64) == HAL_OK) {
20000abe:	2000      	movs	r0, #0
20000ac0:	4641      	mov	r1, r8
20000ac2:	e9dd 2300 	ldrd	r2, r3, [sp]
20000ac6:	f004 f9e7 	bl	20004e98 <HAL_FLASH_Program>
20000aca:	b908      	cbnz	r0, 20000ad0 <program_flash_data+0x4c>
      start += 8;
      offset += 8;
20000acc:	3408      	adds	r4, #8
20000ace:	e7df      	b.n	20000a90 <program_flash_data+0xc>
    } else {
      /* Error occurred while writing data in Flash memory.
         User can add here some code to deal with this error */
      while (1) {
      }
20000ad0:	e7fe      	b.n	20000ad0 <program_flash_data+0x4c>
    }
  }
  return 0;
}
20000ad2:	2000      	movs	r0, #0
20000ad4:	b002      	add	sp, #8
20000ad6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

20000adc <erase_tftf_header>:
/**
 * @brief Erase the partition containing the TFTF Header
 */
void erase_tftf_header(void)
{
  ErasePage((uint32_t)(PARTITION_TFTF_START));
20000adc:	4801      	ldr	r0, [pc, #4]	; (20000ae4 <erase_tftf_header+0x8>)
20000ade:	f7ff bf4d 	b.w	2000097c <ErasePage>
20000ae2:	bf00      	nop
20000ae4:	08008000 	.word	0x08008000

20000ae8 <program_tftf_header>:

/**
 * @brief Writes the contents fo the TFTF header to the TFTF_PARTITION
 */
int program_tftf_header(uint8_t *data, uint32_t size)
{
20000ae8:	b538      	push	{r3, r4, r5, lr}
20000aea:	4604      	mov	r4, r0
20000aec:	460d      	mov	r5, r1
  HAL_FLASH_Unlock();
20000aee:	f004 f973 	bl	20004dd8 <HAL_FLASH_Unlock>
  program_flash_data((uint32_t)(PARTITION_TFTF_START), size, data);
20000af2:	4629      	mov	r1, r5
20000af4:	4622      	mov	r2, r4
20000af6:	4803      	ldr	r0, [pc, #12]	; (20000b04 <program_tftf_header+0x1c>)
20000af8:	f7ff ffc4 	bl	20000a84 <program_flash_data>
  HAL_FLASH_Lock();
20000afc:	f004 f97e 	bl	20004dfc <HAL_FLASH_Lock>

  return 0;
}
20000b00:	2000      	movs	r0, #0
20000b02:	bd38      	pop	{r3, r4, r5, pc}
20000b04:	08008000 	.word	0x08008000

20000b08 <is_constant_fill>:
 * @param len The number of bytes to check
 * @param fill_byte The constant byte to check against
 *
 * @returns True if the buffer is filled with a constan byte, false otherwise.
 */
bool is_constant_fill(uint8_t * buf, uint32_t len, uint8_t fill_byte) {
20000b08:	4401      	add	r1, r0
     while (len-- > 0) {
20000b0a:	4288      	cmp	r0, r1
20000b0c:	d005      	beq.n	20000b1a <is_constant_fill+0x12>
         if (*buf++ != fill_byte) {
20000b0e:	f810 3b01 	ldrb.w	r3, [r0], #1
20000b12:	4293      	cmp	r3, r2
20000b14:	d0f9      	beq.n	20000b0a <is_constant_fill+0x2>
             return false;
20000b16:	2000      	movs	r0, #0
         }
     }
     return true;
}
20000b18:	4770      	bx	lr
     while (len-- > 0) {
         if (*buf++ != fill_byte) {
             return false;
         }
     }
     return true;
20000b1a:	2001      	movs	r0, #1
20000b1c:	4770      	bx	lr

20000b1e <greybus_send_message>:
                                uint8_t type,
                                uint8_t status,
                                const unsigned char *payload_data,
                                uint16_t payload_size,
                                msg_sent_cb cb)
{
20000b1e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
20000b22:	f8bd 6034 	ldrh.w	r6, [sp, #52]	; 0x34
20000b26:	9101      	str	r1, [sp, #4]
20000b28:	469a      	mov	sl, r3
20000b2a:	4693      	mov	fp, r2
20000b2c:	4681      	mov	r9, r0
20000b2e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
20000b30:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
    struct gb_operation_msg *msg = (struct gb_operation_msg *)greybus_get_operation_header();
20000b34:	f001 f8aa 	bl	20001c8c <greybus_get_operation_header>
    dbgprintx32("  - gb_op_hdr = ", (uint32_t)msg, "\r\n");
    dbgprintx32("  - payload = ", (uint32_t) payload, "\r\n");
    dbgprintx32("  - callback = ", (uint32_t) cb, "\r\n");
#endif

    msg->hdr.size    = sizeof(struct gb_operation_hdr) + payload_size;
20000b38:	f106 0508 	add.w	r5, r6, #8
    msg->hdr.id      = id;
    msg->hdr.type    = type;
    msg->hdr.status  = status;
    msg->hdr.padding = 0;
20000b3c:	2300      	movs	r3, #0
    dbgprintx32("  - gb_op_hdr = ", (uint32_t)msg, "\r\n");
    dbgprintx32("  - payload = ", (uint32_t) payload, "\r\n");
    dbgprintx32("  - callback = ", (uint32_t) cb, "\r\n");
#endif

    msg->hdr.size    = sizeof(struct gb_operation_hdr) + payload_size;
20000b3e:	b2ad      	uxth	r5, r5
    msg->hdr.id      = id;
20000b40:	9901      	ldr	r1, [sp, #4]
    dbgprintx32("  - gb_op_hdr = ", (uint32_t)msg, "\r\n");
    dbgprintx32("  - payload = ", (uint32_t) payload, "\r\n");
    dbgprintx32("  - callback = ", (uint32_t) cb, "\r\n");
#endif

    msg->hdr.size    = sizeof(struct gb_operation_hdr) + payload_size;
20000b42:	8005      	strh	r5, [r0, #0]
                                uint8_t status,
                                const unsigned char *payload_data,
                                uint16_t payload_size,
                                msg_sent_cb cb)
{
    struct gb_operation_msg *msg = (struct gb_operation_msg *)greybus_get_operation_header();
20000b44:	4604      	mov	r4, r0
    dbgprintx32("  - payload = ", (uint32_t) payload, "\r\n");
    dbgprintx32("  - callback = ", (uint32_t) cb, "\r\n");
#endif

    msg->hdr.size    = sizeof(struct gb_operation_hdr) + payload_size;
    msg->hdr.id      = id;
20000b46:	8041      	strh	r1, [r0, #2]
    msg->hdr.type    = type;
20000b48:	f880 b004 	strb.w	fp, [r0, #4]
    msg->hdr.status  = status;
20000b4c:	f880 a005 	strb.w	sl, [r0, #5]
    msg->hdr.padding = 0;
20000b50:	7183      	strb	r3, [r0, #6]
20000b52:	71c3      	strb	r3, [r0, #7]

    if (payload_size != 0 && payload_data != NULL) {
20000b54:	b12e      	cbz	r6, 20000b62 <greybus_send_message+0x44>
20000b56:	b127      	cbz	r7, 20000b62 <greybus_send_message+0x44>
        memcpy(payload, payload_data, payload_size);
20000b58:	3008      	adds	r0, #8
20000b5a:	4639      	mov	r1, r7
20000b5c:	4632      	mov	r2, r6
20000b5e:	f005 f891 	bl	20005c84 <memcpy>
    }

    return network_send(cport, (uint8_t *)msg, msg->hdr.size, cb);
20000b62:	4648      	mov	r0, r9
20000b64:	4621      	mov	r1, r4
20000b66:	462a      	mov	r2, r5
20000b68:	4643      	mov	r3, r8
}
20000b6a:	b003      	add	sp, #12
20000b6c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    if (payload_size != 0 && payload_data != NULL) {
        memcpy(payload, payload_data, payload_size);
    }

    return network_send(cport, (uint8_t *)msg, msg->hdr.size, cb);
20000b70:	f000 bb76 	b.w	20001260 <network_send>

20000b74 <greybus_get_next_id>:
extern gb_operation_header *gb_op_hdr;   /* TODO: factor out shared globals */

static uint16_t greybus_id_count = 1;
uint16_t greybus_get_next_id(void)
{
    uint16_t next = greybus_id_count++;
20000b74:	4b03      	ldr	r3, [pc, #12]	; (20000b84 <greybus_get_next_id+0x10>)
20000b76:	8818      	ldrh	r0, [r3, #0]
20000b78:	1c42      	adds	r2, r0, #1

    if (!next)
20000b7a:	2800      	cmp	r0, #0
extern gb_operation_header *gb_op_hdr;   /* TODO: factor out shared globals */

static uint16_t greybus_id_count = 1;
uint16_t greybus_get_next_id(void)
{
    uint16_t next = greybus_id_count++;
20000b7c:	801a      	strh	r2, [r3, #0]

    if (!next)
        next = 1;
    return next;
}
20000b7e:	bf08      	it	eq
20000b80:	2001      	moveq	r0, #1
20000b82:	4770      	bx	lr
20000b84:	200066bc 	.word	0x200066bc

20000b88 <greybus_get_max_payload_size>:

uint16_t greybus_get_max_payload_size(void)
{
20000b88:	b508      	push	{r3, lr}
    return network_get_max_payload_size() - sizeof(struct gb_operation_hdr);
20000b8a:	f000 fb63 	bl	20001254 <network_get_max_payload_size>
20000b8e:	3808      	subs	r0, #8
}
20000b90:	b280      	uxth	r0, r0
20000b92:	bd08      	pop	{r3, pc}

20000b94 <greybus_send_request>:
                         uint16_t id,
                         uint8_t type,
                         const unsigned char *payload_data,
                         uint16_t payload_size,
                         msg_sent_cb cb)
{
20000b94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return greybus_send_message(cport,
20000b96:	9300      	str	r3, [sp, #0]
20000b98:	f8bd 3018 	ldrh.w	r3, [sp, #24]
20000b9c:	9301      	str	r3, [sp, #4]
20000b9e:	9b07      	ldr	r3, [sp, #28]
20000ba0:	9302      	str	r3, [sp, #8]
20000ba2:	2300      	movs	r3, #0
20000ba4:	f7ff ffbb 	bl	20000b1e <greybus_send_message>
                                type,
                                0,
                                payload_data,
                                payload_size,
                                cb);
}
20000ba8:	b005      	add	sp, #20
20000baa:	f85d fb04 	ldr.w	pc, [sp], #4

20000bae <greybus_send_response>:
                        gb_operation_header *op_header,
                        uint8_t status,
                        const unsigned char *payload_data,
                        uint16_t payload_size,
                        msg_sent_cb cb)
{
20000bae:	b530      	push	{r4, r5, lr}
20000bb0:	b085      	sub	sp, #20
    return greybus_send_message(cport,
20000bb2:	884d      	ldrh	r5, [r1, #2]
                        gb_operation_header *op_header,
                        uint8_t status,
                        const unsigned char *payload_data,
                        uint16_t payload_size,
                        msg_sent_cb cb)
{
20000bb4:	4614      	mov	r4, r2
    return greybus_send_message(cport,
20000bb6:	790a      	ldrb	r2, [r1, #4]
20000bb8:	9300      	str	r3, [sp, #0]
20000bba:	f8bd 3020 	ldrh.w	r3, [sp, #32]
20000bbe:	9301      	str	r3, [sp, #4]
20000bc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
20000bc2:	9302      	str	r3, [sp, #8]
20000bc4:	4629      	mov	r1, r5
20000bc6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
20000bca:	4623      	mov	r3, r4
20000bcc:	f7ff ffa7 	bl	20000b1e <greybus_send_message>
                                op_header->type | GB_TYPE_RESPONSE,
                                status,
                                payload_data,
                                payload_size,
                                cb);
}
20000bd0:	b005      	add	sp, #20
20000bd2:	bd30      	pop	{r4, r5, pc}

20000bd4 <control_cport_handler>:
int control_cport_handler(uint32_t cportid,
                          void *data,
                          size_t len)
{
    int rc = 0;
    if (len < sizeof(gb_operation_header)) {
20000bd4:	2a07      	cmp	r2, #7
}

int control_cport_handler(uint32_t cportid,
                          void *data,
                          size_t len)
{
20000bd6:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
20000bd8:	4605      	mov	r5, r0
20000bda:	460c      	mov	r4, r1
    int rc = 0;
    if (len < sizeof(gb_operation_header)) {
20000bdc:	d803      	bhi.n	20000be6 <control_cport_handler+0x12>
        dbgprint("control_cport_handler: RX data length error\r\n");
20000bde:	4837      	ldr	r0, [pc, #220]	; (20000cbc <control_cport_handler+0xe8>)
20000be0:	f004 fa5e 	bl	200050a0 <dbgprint>
20000be4:	e047      	b.n	20000c76 <control_cport_handler+0xa2>
        return -1;
    }

    gb_operation_header *op_header = (gb_operation_header *)data;

    switch (op_header->type) {
20000be6:	790b      	ldrb	r3, [r1, #4]
20000be8:	3b01      	subs	r3, #1
20000bea:	2200      	movs	r2, #0
20000bec:	2b05      	cmp	r3, #5
20000bee:	d858      	bhi.n	20000ca2 <control_cport_handler+0xce>
20000bf0:	e8df f003 	tbb	[pc, r3]
20000bf4:	24180f03 	.word	0x24180f03
20000bf8:	4836      	.short	0x4836

uint32_t gbfw_cportid = 0;

static int gbctrl_get_version(uint32_t cportid,
                            gb_operation_header *op_header) {
    unsigned char payload[2] = {GREYBUS_MAJOR_VERSION,
20000bfa:	2301      	movs	r3, #1
20000bfc:	f88d 300d 	strb.w	r3, [sp, #13]
                                GREYBUS_MINOR_VERSION};

    return greybus_send_response(cportid,
20000c00:	2302      	movs	r3, #2

uint32_t gbfw_cportid = 0;

static int gbctrl_get_version(uint32_t cportid,
                            gb_operation_header *op_header) {
    unsigned char payload[2] = {GREYBUS_MAJOR_VERSION,
20000c02:	f88d 200c 	strb.w	r2, [sp, #12]
                                GREYBUS_MINOR_VERSION};

    return greybus_send_response(cportid,
20000c06:	9300      	str	r3, [sp, #0]
20000c08:	9201      	str	r2, [sp, #4]
20000c0a:	4621      	mov	r1, r4
20000c0c:	2200      	movs	r2, #0
20000c0e:	ab03      	add	r3, sp, #12
20000c10:	e04f      	b.n	20000cb2 <control_cport_handler+0xde>
                               NULL);
}

static int gbctrl_probe_ap(uint32_t cportid,
                         gb_operation_header *op_header) {
    uint16_t payload[1] = {0};
20000c12:	ab04      	add	r3, sp, #16

    return greybus_send_response(cportid,
20000c14:	2102      	movs	r1, #2
                               NULL);
}

static int gbctrl_probe_ap(uint32_t cportid,
                         gb_operation_header *op_header) {
    uint16_t payload[1] = {0};
20000c16:	f823 2d04 	strh.w	r2, [r3, #-4]!

    return greybus_send_response(cportid,
20000c1a:	e88d 0006 	stmia.w	sp, {r1, r2}
20000c1e:	4621      	mov	r1, r4
20000c20:	2200      	movs	r2, #0
20000c22:	e046      	b.n	20000cb2 <control_cport_handler+0xde>
                               NULL);
}

static int gbctrl_get_manifest_size(uint32_t cportid,
                                  gb_operation_header *op_header) {
    uint16_t payload[1] = { get_manifest_size() };
20000c24:	f000 fc52 	bl	200014cc <get_manifest_size>
20000c28:	ab04      	add	r3, sp, #16

    return greybus_send_response(cportid,
20000c2a:	2202      	movs	r2, #2
                               NULL);
}

static int gbctrl_get_manifest_size(uint32_t cportid,
                                  gb_operation_header *op_header) {
    uint16_t payload[1] = { get_manifest_size() };
20000c2c:	f823 0d04 	strh.w	r0, [r3, #-4]!

    return greybus_send_response(cportid,
20000c30:	9200      	str	r2, [sp, #0]
20000c32:	2200      	movs	r2, #0
20000c34:	9201      	str	r2, [sp, #4]
20000c36:	4628      	mov	r0, r5
20000c38:	4621      	mov	r1, r4
20000c3a:	e03a      	b.n	20000cb2 <control_cport_handler+0xde>
}

static int gbctrl_get_manifest(uint32_t cportid,
                             gb_operation_header *op_header) {
    int rc;
    rc = greybus_send_response(cportid,
20000c3c:	f000 fc42 	bl	200014c4 <get_manifest>
20000c40:	4606      	mov	r6, r0
20000c42:	f000 fc43 	bl	200014cc <get_manifest_size>
20000c46:	2200      	movs	r2, #0
20000c48:	9000      	str	r0, [sp, #0]
20000c4a:	9201      	str	r2, [sp, #4]
20000c4c:	4628      	mov	r0, r5
20000c4e:	4621      	mov	r1, r4
20000c50:	4633      	mov	r3, r6
20000c52:	f7ff ffac 	bl	20000bae <greybus_send_response>
                             op_header,
                             GB_OP_SUCCESS,
                             get_manifest(),
                             get_manifest_size(),
                             NULL);
    if (rc) {
20000c56:	bb70      	cbnz	r0, 20000cb6 <control_cport_handler+0xe2>
        return rc;
    }

    manifest_fetched = true;
20000c58:	4b19      	ldr	r3, [pc, #100]	; (20000cc0 <control_cport_handler+0xec>)
20000c5a:	2201      	movs	r2, #1
20000c5c:	701a      	strb	r2, [r3, #0]
20000c5e:	e02a      	b.n	20000cb6 <control_cport_handler+0xe2>

static int gbctrl_connected(uint32_t cportid,
                          gb_operation_header *op_header) {
    uint16_t *payload = (uint16_t *)(op_header + 1);

    if (op_header->size != sizeof(gb_operation_header) + sizeof(*payload)) {
20000c60:	8823      	ldrh	r3, [r4, #0]
20000c62:	2b0a      	cmp	r3, #10
20000c64:	d00a      	beq.n	20000c7c <control_cport_handler+0xa8>
        greybus_send_response(cportid,
20000c66:	2300      	movs	r3, #0
20000c68:	9300      	str	r3, [sp, #0]
20000c6a:	9301      	str	r3, [sp, #4]
20000c6c:	4628      	mov	r0, r5
20000c6e:	4621      	mov	r1, r4
20000c70:	2206      	movs	r2, #6
20000c72:	f7ff ff9c 	bl	20000bae <greybus_send_response>
                            op_header,
                            GB_OP_INVALID,
                            NULL,
                            0,
                            NULL);
        return -1;
20000c76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20000c7a:	e01c      	b.n	20000cb6 <control_cport_handler+0xe2>
    }

    gbfw_cportid = *payload;
20000c7c:	4b11      	ldr	r3, [pc, #68]	; (20000cc4 <control_cport_handler+0xf0>)
20000c7e:	8922      	ldrh	r2, [r4, #8]
20000c80:	601a      	str	r2, [r3, #0]
20000c82:	e007      	b.n	20000c94 <control_cport_handler+0xc0>

static int gbctrl_disconnected(uint32_t cportid,
                             gb_operation_header *op_header) {
    uint16_t *payload = (uint16_t *)(op_header + 1);

    if (op_header->size != sizeof(gb_operation_header) + sizeof(*payload) ||
20000c84:	8823      	ldrh	r3, [r4, #0]
20000c86:	2b0a      	cmp	r3, #10
20000c88:	d1ed      	bne.n	20000c66 <control_cport_handler+0x92>
        *payload != gbfw_cportid) {
20000c8a:	4b0e      	ldr	r3, [pc, #56]	; (20000cc4 <control_cport_handler+0xf0>)
20000c8c:	8922      	ldrh	r2, [r4, #8]

static int gbctrl_disconnected(uint32_t cportid,
                             gb_operation_header *op_header) {
    uint16_t *payload = (uint16_t *)(op_header + 1);

    if (op_header->size != sizeof(gb_operation_header) + sizeof(*payload) ||
20000c8e:	681b      	ldr	r3, [r3, #0]
20000c90:	429a      	cmp	r2, r3
20000c92:	d1e8      	bne.n	20000c66 <control_cport_handler+0x92>
                            0,
                            NULL);
        return -1;
    }

    return greybus_send_response(cportid,
20000c94:	2200      	movs	r2, #0
20000c96:	9200      	str	r2, [sp, #0]
20000c98:	9201      	str	r2, [sp, #4]
20000c9a:	4628      	mov	r0, r5
20000c9c:	4621      	mov	r1, r4
20000c9e:	4613      	mov	r3, r2
20000ca0:	e007      	b.n	20000cb2 <control_cport_handler+0xde>
static int gbctrl_unimplemented(uint32_t cportid,
        gb_operation_header *op_header)
{
    int rv = GB_OP_SUCCESS;

    if (op_header->id) {
20000ca2:	8860      	ldrh	r0, [r4, #2]
20000ca4:	2300      	movs	r3, #0
20000ca6:	b130      	cbz	r0, 20000cb6 <control_cport_handler+0xe2>
        rv = greybus_send_response(cportid,
20000ca8:	9300      	str	r3, [sp, #0]
20000caa:	9301      	str	r3, [sp, #4]
20000cac:	4628      	mov	r0, r5
20000cae:	4621      	mov	r1, r4
20000cb0:	2206      	movs	r2, #6
20000cb2:	f7ff ff7c 	bl	20000bae <greybus_send_response>
        rc  = gbctrl_unimplemented(cportid, op_header);
        break;
    }

    return rc;
}
20000cb6:	b004      	add	sp, #16
20000cb8:	bd70      	pop	{r4, r5, r6, pc}
20000cba:	bf00      	nop
20000cbc:	20005ef9 	.word	0x20005ef9
20000cc0:	200066dc 	.word	0x200066dc
20000cc4:	200066e0 	.word	0x200066e0

20000cc8 <modsctrl_null_resp>:
} __attribute__ ((packed));

/* conditionally respond to a message */
static inline int
modsctrl_null_resp(uint32_t cportid, struct gb_operation_msg *msg,  uint8_t status)
{
20000cc8:	b513      	push	{r0, r1, r4, lr}
    int rv = GB_OP_SUCCESS;

    if (msg->hdr.id) {
20000cca:	884c      	ldrh	r4, [r1, #2]
20000ccc:	2300      	movs	r3, #0
20000cce:	b124      	cbz	r4, 20000cda <modsctrl_null_resp+0x12>
        rv = greybus_send_response(cportid, &msg->hdr, status, NULL, 0, NULL);
20000cd0:	9300      	str	r3, [sp, #0]
20000cd2:	9301      	str	r3, [sp, #4]
20000cd4:	f7ff ff6b 	bl	20000bae <greybus_send_response>
20000cd8:	e000      	b.n	20000cdc <modsctrl_null_resp+0x14>

/* conditionally respond to a message */
static inline int
modsctrl_null_resp(uint32_t cportid, struct gb_operation_msg *msg,  uint8_t status)
{
    int rv = GB_OP_SUCCESS;
20000cda:	4620      	mov	r0, r4

    if (msg->hdr.id) {
        rv = greybus_send_response(cportid, &msg->hdr, status, NULL, 0, NULL);
    }
    return rv;
}
20000cdc:	b002      	add	sp, #8
20000cde:	bd10      	pop	{r4, pc}

20000ce0 <mods_control_handler>:
            sizeof(resp),
            NULL);
}

int mods_control_handler(uint32_t cportid, void *data, size_t len)
{
20000ce0:	b530      	push	{r4, r5, lr}
    int rc = 0;
    struct gb_operation_msg *msg;

    if (len < sizeof(gb_operation_header)) {
20000ce2:	2a07      	cmp	r2, #7
            sizeof(resp),
            NULL);
}

int mods_control_handler(uint32_t cportid, void *data, size_t len)
{
20000ce4:	b097      	sub	sp, #92	; 0x5c
20000ce6:	4605      	mov	r5, r0
20000ce8:	460c      	mov	r4, r1
    int rc = 0;
    struct gb_operation_msg *msg;

    if (len < sizeof(gb_operation_header)) {
20000cea:	d805      	bhi.n	20000cf8 <mods_control_handler+0x18>
        dbgprint("mods_control_handler: RX data length error\r\n");
20000cec:	483d      	ldr	r0, [pc, #244]	; (20000de4 <mods_control_handler+0x104>)
20000cee:	f004 f9d7 	bl	200050a0 <dbgprint>
        return -1;
20000cf2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20000cf6:	e072      	b.n	20000dde <mods_control_handler+0xfe>
    }

    msg = (struct gb_operation_msg *)data;
    switch (msg->hdr.type) {
20000cf8:	790b      	ldrb	r3, [r1, #4]
20000cfa:	3b01      	subs	r3, #1
20000cfc:	2b0b      	cmp	r3, #11
20000cfe:	d86b      	bhi.n	20000dd8 <mods_control_handler+0xf8>
20000d00:	e8df f003 	tbb	[pc, r3]
20000d04:	5a310e06 	.word	0x5a310e06
20000d08:	5a544c5a 	.word	0x5a544c5a
20000d0c:	5c6a5a6a 	.word	0x5c6a5a6a
    return rv;
}

static int modsctrl_get_version(uint32_t cportid, struct gb_operation_msg *msg)
{
    unsigned char payload[2] = {MB_CONTROL_VERSION_MAJOR,
20000d10:	2307      	movs	r3, #7
20000d12:	2200      	movs	r2, #0
20000d14:	f88d 300d 	strb.w	r3, [sp, #13]
20000d18:	f88d 200c 	strb.w	r2, [sp, #12]
                                MB_CONTROL_VERSION_MINOR};

    return greybus_send_response(cportid,
20000d1c:	2302      	movs	r3, #2
20000d1e:	e01c      	b.n	20000d5a <mods_control_handler+0x7a>

static int modsctrl_get_ids(uint32_t cportid, struct gb_operation_msg *msg)
{
    struct mb_control_get_ids_response get_ids_resp;

    get_ids_resp.fw_version = (CONFIG_VERSION_MAJOR << 16 | CONFIG_VERSION_MINOR);
20000d20:	2301      	movs	r3, #1
    get_chip_id(&get_ids_resp.unipro_mfg_id, &get_ids_resp.unipro_prod_id);
20000d22:	a904      	add	r1, sp, #16
20000d24:	a803      	add	r0, sp, #12

static int modsctrl_get_ids(uint32_t cportid, struct gb_operation_msg *msg)
{
    struct mb_control_get_ids_response get_ids_resp;

    get_ids_resp.fw_version = (CONFIG_VERSION_MAJOR << 16 | CONFIG_VERSION_MINOR);
20000d26:	930b      	str	r3, [sp, #44]	; 0x2c
    get_chip_id(&get_ids_resp.unipro_mfg_id, &get_ids_resp.unipro_prod_id);
20000d28:	f7ff fb04 	bl	20000334 <get_chip_id>
    get_board_id(&get_ids_resp.ara_vend_id, &get_ids_resp.ara_prod_id);
20000d2c:	a906      	add	r1, sp, #24
20000d2e:	a805      	add	r0, sp, #20
20000d30:	f7ff faf4 	bl	2000031c <get_board_id>
    get_chip_uid(&get_ids_resp.uid_high, &get_ids_resp.uid_low);
20000d34:	a809      	add	r0, sp, #36	; 0x24
20000d36:	a907      	add	r1, sp, #28
20000d38:	f000 fbec 	bl	20001514 <get_chip_uid>
#ifdef CONFIG_SLAVE_APBE
    get_ids_resp.slave_mask = 1;
    dbgprint("MODCTRL:SLAVE MASK SET\r\n");
#else
    get_ids_resp.slave_mask = 0;
20000d3c:	2300      	movs	r3, #0
20000d3e:	930c      	str	r3, [sp, #48]	; 0x30
/* NOTE: no boundary checking; do not use for inputted strings. */
static inline char *cpstr(char *tgt, const char *src)
{
    size_t i;

    for (i = 0; src[i] != '\0'; i++) {
20000d40:	4a29      	ldr	r2, [pc, #164]	; (20000de8 <mods_control_handler+0x108>)
20000d42:	5c9a      	ldrb	r2, [r3, r2]
20000d44:	b12a      	cbz	r2, 20000d52 <mods_control_handler+0x72>
20000d46:	a903      	add	r1, sp, #12
20000d48:	4419      	add	r1, r3
20000d4a:	3301      	adds	r3, #1
        tgt[i] = src[i];
20000d4c:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
20000d50:	e7f6      	b.n	20000d40 <mods_control_handler+0x60>
#endif

    cpstr(get_ids_resp.fw_version_str, CONFIG_VERSION_STRING " " CONFIG_VERSION_BUILD);

#ifdef CONFIG_GREYBUS_MODS_SUPPORT_VENDOR_UPDATES
    get_ids_resp.fw_vendor_updates = true;
20000d52:	2301      	movs	r3, #1
20000d54:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
#else
    get_ids_resp.fw_vendor_updates = false;
#endif

    return greybus_send_response(cportid,
20000d58:	2349      	movs	r3, #73	; 0x49
20000d5a:	9300      	str	r3, [sp, #0]
20000d5c:	9201      	str	r2, [sp, #4]
20000d5e:	4628      	mov	r0, r5
20000d60:	4621      	mov	r1, r4
20000d62:	ab03      	add	r3, sp, #12
20000d64:	e035      	b.n	20000dd2 <mods_control_handler+0xf2>
    int rv = GB_OP_SUCCESS;

    struct mb_control_reboot_request *req =
            (struct mb_control_reboot_request *)msg->data;

    switch (req->mode) {
20000d66:	7a09      	ldrb	r1, [r1, #8]
20000d68:	2901      	cmp	r1, #1
20000d6a:	d002      	beq.n	20000d72 <mods_control_handler+0x92>
20000d6c:	2902      	cmp	r1, #2
20000d6e:	d004      	beq.n	20000d7a <mods_control_handler+0x9a>
20000d70:	e00c      	b.n	20000d8c <mods_control_handler+0xac>
        case MB_CONTROL_REBOOT_MODE_RESET:
            dbgprint("REBOOT_RESET\r\n");
20000d72:	481e      	ldr	r0, [pc, #120]	; (20000dec <mods_control_handler+0x10c>)
20000d74:	f004 f994 	bl	200050a0 <dbgprint>
20000d78:	e00c      	b.n	20000d94 <mods_control_handler+0xb4>
        break;
        case MB_CONTROL_REBOOT_MODE_BOOTLOADER:
            dbgprint("REBOOT_BOOTLOADER\r\n");
20000d7a:	481d      	ldr	r0, [pc, #116]	; (20000df0 <mods_control_handler+0x110>)
20000d7c:	f004 f990 	bl	200050a0 <dbgprint>
            if (CheckFlashMode() == BOOT_STATE_NORMAL) {
20000d80:	f7ff fa7e 	bl	20000280 <CheckFlashMode>
20000d84:	b930      	cbnz	r0, 20000d94 <mods_control_handler+0xb4>
                set_request_flash();
20000d86:	f7ff fbc1 	bl	2000050c <set_request_flash>
20000d8a:	e003      	b.n	20000d94 <mods_control_handler+0xb4>
            }
        break;
        default:
            dbgprintx32("REBOOT ", req->mode, "\r\n");
20000d8c:	4819      	ldr	r0, [pc, #100]	; (20000df4 <mods_control_handler+0x114>)
20000d8e:	4a1a      	ldr	r2, [pc, #104]	; (20000df8 <mods_control_handler+0x118>)
20000d90:	f004 f9b9 	bl	20005106 <dbgprintx32>
        break;
    }
    HAL_NVIC_SystemReset();
20000d94:	f002 fdbc 	bl	20003910 <HAL_NVIC_SystemReset>
        break;
    case MB_CONTROL_TYPE_GET_IDS:
        rc = modsctrl_get_ids(cportid, msg);
        break;
    case MB_CONTROL_TYPE_REBOOT:
        rc = modsctrl_reboot(cportid, msg);
20000d98:	2000      	movs	r0, #0
        break;
20000d9a:	e020      	b.n	20000dde <mods_control_handler+0xfe>
    struct mb_control_power_ctrl_request *req =
        (struct mb_control_power_ctrl_request *)msg->data;

    ret = slave_pwrctrl_set_mode(req->mode);
#else
    ret = modsctrl_null_resp(cportid, msg, GB_OP_INVALID);
20000d9c:	2206      	movs	r2, #6
20000d9e:	f7ff ff93 	bl	20000cc8 <modsctrl_null_resp>
#endif
    return ret ? GB_OP_UNKNOWN_ERROR : GB_OP_SUCCESS;
20000da2:	2800      	cmp	r0, #0
20000da4:	bf14      	ite	ne
20000da6:	20fe      	movne	r0, #254	; 0xfe
20000da8:	2000      	moveq	r0, #0
20000daa:	e018      	b.n	20000dde <mods_control_handler+0xfe>
}

static int modsctrl_root_version(uint32_t cportid, struct gb_operation_msg *msg)
{
    struct mb_control_root_ver_response resp = { CONFIG_ROOT_VERSION };
20000dac:	ab16      	add	r3, sp, #88	; 0x58
20000dae:	2203      	movs	r2, #3
20000db0:	f803 2d4c 	strb.w	r2, [r3, #-76]!

    return greybus_send_response(cportid,
20000db4:	2201      	movs	r2, #1
20000db6:	e007      	b.n	20000dc8 <mods_control_handler+0xe8>
}

static inline int
modsctrl_set_current_limit(uint32_t cportid, struct gb_operation_msg *msg)
{
    return modsctrl_null_resp(cportid, msg,  GB_OP_SUCCESS);
20000db8:	2200      	movs	r2, #0
20000dba:	e00e      	b.n	20000dda <mods_control_handler+0xfa>
static inline int
modsctrl_get_pwrup_reason(uint32_t cportid, struct gb_operation_msg *msg)
{
    struct mb_control_get_pwrup_reason_response resp;

    resp.reason = get_flash_reason();
20000dbc:	f7ff fa5a 	bl	20000274 <get_flash_reason>
20000dc0:	ab16      	add	r3, sp, #88	; 0x58

    return greybus_send_response(cportid,
20000dc2:	2204      	movs	r2, #4
static inline int
modsctrl_get_pwrup_reason(uint32_t cportid, struct gb_operation_msg *msg)
{
    struct mb_control_get_pwrup_reason_response resp;

    resp.reason = get_flash_reason();
20000dc4:	f843 0d4c 	str.w	r0, [r3, #-76]!

    return greybus_send_response(cportid,
20000dc8:	9200      	str	r2, [sp, #0]
20000dca:	2200      	movs	r2, #0
20000dcc:	9201      	str	r2, [sp, #4]
20000dce:	4628      	mov	r0, r5
20000dd0:	4621      	mov	r1, r4
20000dd2:	f7ff feec 	bl	20000bae <greybus_send_response>
        break;
    case MB_CONTROL_TYPE_SET_CURRENT_LIMIT:
        return modsctrl_set_current_limit(cportid, msg);
        break;
    case MB_CONTROL_TYPE_GET_PWRUP_REASON:
        return modsctrl_get_pwrup_reason(cportid, msg);
20000dd6:	e002      	b.n	20000dde <mods_control_handler+0xfe>
        break;
    default:
        rc = modsctrl_null_resp(cportid, msg, GB_OP_INVALID);
20000dd8:	2206      	movs	r2, #6
20000dda:	f7ff ff75 	bl	20000cc8 <modsctrl_null_resp>
        break;
    }

    return rc;
}
20000dde:	b017      	add	sp, #92	; 0x5c
20000de0:	bd30      	pop	{r4, r5, pc}
20000de2:	bf00      	nop
20000de4:	20005f27 	.word	0x20005f27
20000de8:	20005f54 	.word	0x20005f54
20000dec:	20005f60 	.word	0x20005f60
20000df0:	20005f6f 	.word	0x20005f6f
20000df4:	20005f83 	.word	0x20005f83
20000df8:	20005e34 	.word	0x20005e34

20000dfc <gbfw_ready_to_boot_cb>:
    }
    return 0;
}

static void gbfw_ready_to_boot_cb(int status, void *cntx)
{
20000dfc:	4770      	bx	lr
	...

20000e00 <gbfw_next_stage>:

    return 0;
}

static void gbfw_next_stage(void)
{
20000e00:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t valid_stage_mask = 0x00;

    memset(&fw_flash_data, 0, sizeof(fw_flash_data));
20000e02:	2100      	movs	r1, #0
20000e04:	2214      	movs	r2, #20
20000e06:	4820      	ldr	r0, [pc, #128]	; (20000e88 <gbfw_next_stage+0x88>)
20000e08:	f7ff f9e6 	bl	200001d8 <memset>
    tftf_header_received = false;
20000e0c:	4b1f      	ldr	r3, [pc, #124]	; (20000e8c <gbfw_next_stage+0x8c>)
20000e0e:	2200      	movs	r2, #0
20000e10:	701a      	strb	r2, [r3, #0]

    if (!chip_bootloader_is_readonly()) {
20000e12:	f000 fc39 	bl	20001688 <chip_bootloader_is_readonly>
20000e16:	491e      	ldr	r1, [pc, #120]	; (20000e90 <gbfw_next_stage+0x90>)
        valid_stage_mask |= 1 << GBFW_STAGE_BOOTLOADER;
20000e18:	2800      	cmp	r0, #0
20000e1a:	780b      	ldrb	r3, [r1, #0]
    }
#ifdef CONFIG_APBE_FLASH
    valid_stage_mask |= 1 << GBFW_STAGE_APBE_SPI_FLASH;
#endif
    valid_stage_mask |= 1 << GBFW_STAGE_MAIN;
20000e1c:	bf14      	ite	ne
20000e1e:	200c      	movne	r0, #12
20000e20:	200e      	moveq	r0, #14

    while (_gbfw_stage < GBFW_STAGE_MAX) {
20000e22:	2b02      	cmp	r3, #2
20000e24:	d817      	bhi.n	20000e56 <gbfw_next_stage+0x56>
20000e26:	3301      	adds	r3, #1
20000e28:	b2da      	uxtb	r2, r3
        if ((1 << (_gbfw_stage + 1)) & valid_stage_mask) {
20000e2a:	fa40 f303 	asr.w	r3, r0, r3
20000e2e:	07dc      	lsls	r4, r3, #31
20000e30:	d50f      	bpl.n	20000e52 <gbfw_next_stage+0x52>
                                       void *data, uint32_t len);

static int gbfw_firmware_size(uint8_t stage)
{
    int rc;
    struct gbfw_firmware_size_request req = {stage};
20000e32:	ac04      	add	r4, sp, #16
#endif
    valid_stage_mask |= 1 << GBFW_STAGE_MAIN;

    while (_gbfw_stage < GBFW_STAGE_MAX) {
        if ((1 << (_gbfw_stage + 1)) & valid_stage_mask) {
            gbfw_firmware_size(++_gbfw_stage);
20000e34:	700a      	strb	r2, [r1, #0]
                                       void *data, uint32_t len);

static int gbfw_firmware_size(uint8_t stage)
{
    int rc;
    struct gbfw_firmware_size_request req = {stage};
20000e36:	f804 2d04 	strb.w	r2, [r4, #-4]!
    uint16_t msg_id = greybus_get_next_id();
20000e3a:	f7ff fe9b 	bl	20000b74 <greybus_get_next_id>

    rc = greybus_send_request(gbfw_cportid, msg_id, GB_FW_OP_FIRMWARE_SIZE,
20000e3e:	2201      	movs	r2, #1
20000e40:	2300      	movs	r3, #0
20000e42:	e88d 000c 	stmia.w	sp, {r2, r3}
20000e46:	4b13      	ldr	r3, [pc, #76]	; (20000e94 <gbfw_next_stage+0x94>)

static int gbfw_firmware_size(uint8_t stage)
{
    int rc;
    struct gbfw_firmware_size_request req = {stage};
    uint16_t msg_id = greybus_get_next_id();
20000e48:	4601      	mov	r1, r0

    rc = greybus_send_request(gbfw_cportid, msg_id, GB_FW_OP_FIRMWARE_SIZE,
20000e4a:	2202      	movs	r2, #2
20000e4c:	6818      	ldr	r0, [r3, #0]
20000e4e:	4623      	mov	r3, r4
20000e50:	e016      	b.n	20000e80 <gbfw_next_stage+0x80>
20000e52:	4613      	mov	r3, r2
20000e54:	e7e5      	b.n	20000e22 <gbfw_next_stage+0x22>
20000e56:	700b      	strb	r3, [r1, #0]
}

static int gbfw_ready_to_boot(uint8_t status)
{
    int rc;
    struct gbfw_ready_to_boot_request req = {status};
20000e58:	2302      	movs	r3, #2
20000e5a:	f88d 300c 	strb.w	r3, [sp, #12]
    uint16_t msg_id = greybus_get_next_id();
20000e5e:	f7ff fe89 	bl	20000b74 <greybus_get_next_id>

    /* Erase the Flash Mode Barker */
    if (_gbfw_updated_count > 0) {
20000e62:	4b0d      	ldr	r3, [pc, #52]	; (20000e98 <gbfw_next_stage+0x98>)
20000e64:	781b      	ldrb	r3, [r3, #0]

static int gbfw_ready_to_boot(uint8_t status)
{
    int rc;
    struct gbfw_ready_to_boot_request req = {status};
    uint16_t msg_id = greybus_get_next_id();
20000e66:	4604      	mov	r4, r0

    /* Erase the Flash Mode Barker */
    if (_gbfw_updated_count > 0) {
20000e68:	b10b      	cbz	r3, 20000e6e <gbfw_next_stage+0x6e>
#ifdef CONFIG_DEBUG_FIRMWARE
        dbgprintx32("updated ", _gbfw_updated_count, " files\r\n");
#endif
        clr_flash_barker();
20000e6a:	f7ff fa89 	bl	20000380 <clr_flash_barker>
    }

    /* ready_to_boot currently doesn't respond so fake a response */
    rc = greybus_send_request(gbfw_cportid, msg_id, GB_FW_OP_READY_TO_BOOT,
20000e6e:	2301      	movs	r3, #1
20000e70:	9300      	str	r3, [sp, #0]
20000e72:	4b0a      	ldr	r3, [pc, #40]	; (20000e9c <gbfw_next_stage+0x9c>)
20000e74:	9301      	str	r3, [sp, #4]
20000e76:	4b07      	ldr	r3, [pc, #28]	; (20000e94 <gbfw_next_stage+0x94>)
20000e78:	4621      	mov	r1, r4
20000e7a:	6818      	ldr	r0, [r3, #0]
20000e7c:	2204      	movs	r2, #4
20000e7e:	ab03      	add	r3, sp, #12
20000e80:	f7ff fe88 	bl	20000b94 <greybus_send_request>
        _gbfw_stage++;
    }

    if (_gbfw_stage >= GBFW_STAGE_MAX)
        gbfw_ready_to_boot(GB_FW_BOOT_STATUS_SECURE);
}
20000e84:	b004      	add	sp, #16
20000e86:	bd10      	pop	{r4, pc}
20000e88:	200066e8 	.word	0x200066e8
20000e8c:	200066e4 	.word	0x200066e4
20000e90:	200066fe 	.word	0x200066fe
20000e94:	200066e0 	.word	0x200066e0
20000e98:	20006903 	.word	0x20006903
20000e9c:	20000dfd 	.word	0x20000dfd

20000ea0 <gbfw_ap_ready_cb>:
                                 sizeof(payload), NULL);
}

static void gbfw_ap_ready_cb(int status, void *cntx)
{
    _gbfw_stage = 0;
20000ea0:	4a03      	ldr	r2, [pc, #12]	; (20000eb0 <gbfw_ap_ready_cb+0x10>)
20000ea2:	2300      	movs	r3, #0
20000ea4:	7013      	strb	r3, [r2, #0]
    _gbfw_updated_count = 0;
20000ea6:	4a03      	ldr	r2, [pc, #12]	; (20000eb4 <gbfw_ap_ready_cb+0x14>)
20000ea8:	7013      	strb	r3, [r2, #0]
    gbfw_next_stage();
20000eaa:	f7ff bfa9 	b.w	20000e00 <gbfw_next_stage>
20000eae:	bf00      	nop
20000eb0:	200066fe 	.word	0x200066fe
20000eb4:	20006903 	.word	0x20006903

20000eb8 <fw_cport_handler>:
    }
    return 0;
}

int fw_cport_handler(uint32_t cportid, void *data, size_t len)
{
20000eb8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    int rc = 0;
    uint8_t *data_ptr;

    if (cportid != gbfw_cportid) {
20000ebc:	4fae      	ldr	r7, [pc, #696]	; (20001178 <fw_cport_handler+0x2c0>)
20000ebe:	683b      	ldr	r3, [r7, #0]
20000ec0:	4298      	cmp	r0, r3
    }
    return 0;
}

int fw_cport_handler(uint32_t cportid, void *data, size_t len)
{
20000ec2:	4604      	mov	r4, r0
20000ec4:	460d      	mov	r5, r1
20000ec6:	4616      	mov	r6, r2
    int rc = 0;
    uint8_t *data_ptr;

    if (cportid != gbfw_cportid) {
20000ec8:	d001      	beq.n	20000ece <fw_cport_handler+0x16>
        dbgprint("fw_cport_handler: incorrect CPort #\r\n");
20000eca:	48ac      	ldr	r0, [pc, #688]	; (2000117c <fw_cport_handler+0x2c4>)
20000ecc:	e002      	b.n	20000ed4 <fw_cport_handler+0x1c>
        return GB_FW_ERR_INVALID;
    }

    if (len < sizeof(gb_operation_header)) {
20000ece:	2a07      	cmp	r2, #7
20000ed0:	d805      	bhi.n	20000ede <fw_cport_handler+0x26>
        dbgprint("fw_cport_handler: RX data length error\r\n");
20000ed2:	48ab      	ldr	r0, [pc, #684]	; (20001180 <fw_cport_handler+0x2c8>)
20000ed4:	f004 f8e4 	bl	200050a0 <dbgprint>
        return GB_FW_ERR_INVALID;
20000ed8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20000edc:	e1ab      	b.n	20001236 <fw_cport_handler+0x37e>
    }

    gb_operation_header *op_header = (gb_operation_header *)data;
    data_ptr = (uint8_t *)data;

    if (op_header->size > len) {
20000ede:	880b      	ldrh	r3, [r1, #0]
20000ee0:	4293      	cmp	r3, r2
20000ee2:	d90d      	bls.n	20000f00 <fw_cport_handler+0x48>
        dbgprint("fw_cport_handler: payload size > total size.\r\n");
20000ee4:	48a7      	ldr	r0, [pc, #668]	; (20001184 <fw_cport_handler+0x2cc>)
20000ee6:	f004 f8db 	bl	200050a0 <dbgprint>
        dbgprintx32("  total_size (len) = 0x", len, "\r\n");
20000eea:	4631      	mov	r1, r6
20000eec:	48a6      	ldr	r0, [pc, #664]	; (20001188 <fw_cport_handler+0x2d0>)
20000eee:	4aa7      	ldr	r2, [pc, #668]	; (2000118c <fw_cport_handler+0x2d4>)
20000ef0:	f004 f909 	bl	20005106 <dbgprintx32>
        dbgprintx32("      payload_size = 0x", op_header->size, "\r\n");
20000ef4:	48a6      	ldr	r0, [pc, #664]	; (20001190 <fw_cport_handler+0x2d8>)
20000ef6:	8829      	ldrh	r1, [r5, #0]
20000ef8:	4aa4      	ldr	r2, [pc, #656]	; (2000118c <fw_cport_handler+0x2d4>)
20000efa:	f004 f904 	bl	20005106 <dbgprintx32>
20000efe:	e7eb      	b.n	20000ed8 <fw_cport_handler+0x20>
        return GB_FW_ERR_INVALID;
    }

    if (op_header->type & GB_TYPE_RESPONSE && op_header->status) {
20000f00:	f991 3004 	ldrsb.w	r3, [r1, #4]
20000f04:	2b00      	cmp	r3, #0
20000f06:	da05      	bge.n	20000f14 <fw_cport_handler+0x5c>
20000f08:	7949      	ldrb	r1, [r1, #5]
20000f0a:	b119      	cbz	r1, 20000f14 <fw_cport_handler+0x5c>
        dbgprintx32("fw_cport_handler: Greybus response, status 0x",
20000f0c:	48a1      	ldr	r0, [pc, #644]	; (20001194 <fw_cport_handler+0x2dc>)
20000f0e:	4a9f      	ldr	r2, [pc, #636]	; (2000118c <fw_cport_handler+0x2d4>)
20000f10:	f004 f8f9 	bl	20005106 <dbgprintx32>
     * synchronously.  We set the constant and return to the recipient rather
     * than setting the constant in parallel with the recipient.
     */
    data_ptr += sizeof(gb_operation_header);
    len -= sizeof(gb_operation_header);
    switch (op_header->type) {
20000f14:	792b      	ldrb	r3, [r5, #4]
20000f16:	2b82      	cmp	r3, #130	; 0x82
20000f18:	d01f      	beq.n	20000f5a <fw_cport_handler+0xa2>
20000f1a:	d80d      	bhi.n	20000f38 <fw_cport_handler+0x80>
20000f1c:	2b01      	cmp	r3, #1
20000f1e:	f04f 0200 	mov.w	r2, #0
20000f22:	d00f      	beq.n	20000f44 <fw_cport_handler+0x8c>
20000f24:	2b05      	cmp	r3, #5
20000f26:	f040 8182 	bne.w	2000122e <fw_cport_handler+0x376>
    gbfw_next_stage();
}

static int gbfw_ap_ready(uint32_t cportid, gb_operation_header *header)
{
    return greybus_send_response(cportid, header, GB_OP_SUCCESS, NULL, 0, gbfw_ap_ready_cb);
20000f2a:	4b9b      	ldr	r3, [pc, #620]	; (20001198 <fw_cport_handler+0x2e0>)
20000f2c:	9301      	str	r3, [sp, #4]
20000f2e:	9200      	str	r2, [sp, #0]
20000f30:	4620      	mov	r0, r4
20000f32:	4629      	mov	r1, r5
20000f34:	4613      	mov	r3, r2
20000f36:	e177      	b.n	20001228 <fw_cport_handler+0x370>
     * synchronously.  We set the constant and return to the recipient rather
     * than setting the constant in parallel with the recipient.
     */
    data_ptr += sizeof(gb_operation_header);
    len -= sizeof(gb_operation_header);
    switch (op_header->type) {
20000f38:	2b83      	cmp	r3, #131	; 0x83
20000f3a:	d045      	beq.n	20000fc8 <fw_cport_handler+0x110>
20000f3c:	2b84      	cmp	r3, #132	; 0x84
20000f3e:	f000 816b 	beq.w	20001218 <fw_cport_handler+0x360>
20000f42:	e174      	b.n	2000122e <fw_cport_handler+0x376>
static int gbfw_ready_to_boot(uint8_t status);
static void gbfw_next_stage(void);

static int gbfw_get_version(uint32_t cportid, gb_operation_header *header)
{
    uint8_t payload[2] = {GB_FIRMWARE_VERSION_MAJOR, GB_FIRMWARE_VERSION_MINOR};
20000f44:	f88d 3009 	strb.w	r3, [sp, #9]

    return greybus_send_response(cportid, header, GB_OP_SUCCESS, payload,
20000f48:	2302      	movs	r3, #2
20000f4a:	9300      	str	r3, [sp, #0]
static int gbfw_ready_to_boot(uint8_t status);
static void gbfw_next_stage(void);

static int gbfw_get_version(uint32_t cportid, gb_operation_header *header)
{
    uint8_t payload[2] = {GB_FIRMWARE_VERSION_MAJOR, GB_FIRMWARE_VERSION_MINOR};
20000f4c:	f88d 2008 	strb.w	r2, [sp, #8]

    return greybus_send_response(cportid, header, GB_OP_SUCCESS, payload,
20000f50:	9201      	str	r2, [sp, #4]
20000f52:	4620      	mov	r0, r4
20000f54:	4629      	mov	r1, r5
20000f56:	ab02      	add	r3, sp, #8
20000f58:	e166      	b.n	20001228 <fw_cport_handler+0x370>
static int gbfw_firmware_size_response(gb_operation_header *head, void *data,
                                       uint32_t len)
{
    size_t fw_size;

    if (head->status) {
20000f5a:	796c      	ldrb	r4, [r5, #5]
20000f5c:	2c00      	cmp	r4, #0
20000f5e:	f040 8158 	bne.w	20001212 <fw_cport_handler+0x35a>
     * This works here because we're actually calling this handler
     * synchronously.  We set the constant and return to the recipient rather
     * than setting the constant in parallel with the recipient.
     */
    data_ptr += sizeof(gb_operation_header);
    len -= sizeof(gb_operation_header);
20000f62:	3e08      	subs	r6, #8
#endif
        gbfw_next_stage();
        return 0;
    }

    if (len < sizeof(struct gbfw_firmware_size_response)) {
20000f64:	2e03      	cmp	r6, #3
20000f66:	d801      	bhi.n	20000f6c <fw_cport_handler+0xb4>
        dbgprint("gbfw_firmware_size_response: bad response size\r\n");
20000f68:	488c      	ldr	r0, [pc, #560]	; (2000119c <fw_cport_handler+0x2e4>)
20000f6a:	e7b3      	b.n	20000ed4 <fw_cport_handler+0x1c>
        return GB_FW_ERR_INVALID;
    }
    memcpy(&firmware_size_response, data, sizeof(firmware_size_response));
20000f6c:	4e8c      	ldr	r6, [pc, #560]	; (200011a0 <fw_cport_handler+0x2e8>)
20000f6e:	68ab      	ldr	r3, [r5, #8]
20000f70:	6033      	str	r3, [r6, #0]

    fw_size = firmware_size_response.size;
20000f72:	6833      	ldr	r3, [r6, #0]

    if (fw_size > TFTF_HEADER_SIZE) {
20000f74:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20000f78:	d920      	bls.n	20000fbc <fw_cport_handler+0x104>
        int rc;
        struct gbfw_get_firmware_request req = {0, TFTF_HEADER_SIZE};
20000f7a:	9402      	str	r4, [sp, #8]
20000f7c:	f44f 7400 	mov.w	r4, #512	; 0x200
20000f80:	9403      	str	r4, [sp, #12]
        uint16_t msg_id = greybus_get_next_id();
20000f82:	f7ff fdf7 	bl	20000b74 <greybus_get_next_id>
}

#ifdef CONFIG_APBE_FLASH
static bool gbfw_is_apbe_flash_stage(void)
{
   return _gbfw_stage == GBFW_STAGE_APBE_SPI_FLASH ? true : false;
20000f86:	4b87      	ldr	r3, [pc, #540]	; (200011a4 <fw_cport_handler+0x2ec>)
    if (fw_size > TFTF_HEADER_SIZE) {
        int rc;
        struct gbfw_get_firmware_request req = {0, TFTF_HEADER_SIZE};
        uint16_t msg_id = greybus_get_next_id();
#ifdef CONFIG_APBE_FLASH
        if (gbfw_is_apbe_flash_stage()) {
20000f88:	781b      	ldrb	r3, [r3, #0]
20000f8a:	2b02      	cmp	r3, #2
            req.offset = TFTF_HEADER_SIZE;
            firmware_size_response.size -= TFTF_HEADER_SIZE;
20000f8c:	bf01      	itttt	eq
20000f8e:	6833      	ldreq	r3, [r6, #0]
        int rc;
        struct gbfw_get_firmware_request req = {0, TFTF_HEADER_SIZE};
        uint16_t msg_id = greybus_get_next_id();
#ifdef CONFIG_APBE_FLASH
        if (gbfw_is_apbe_flash_stage()) {
            req.offset = TFTF_HEADER_SIZE;
20000f90:	9402      	streq	r4, [sp, #8]
            firmware_size_response.size -= TFTF_HEADER_SIZE;
20000f92:	f5a3 7300 	subeq.w	r3, r3, #512	; 0x200
20000f96:	6033      	streq	r3, [r6, #0]
        }
#endif
        rc = greybus_send_request(gbfw_cportid, msg_id, GB_FW_OP_GET_FIRMWARE,
20000f98:	2208      	movs	r2, #8
20000f9a:	2300      	movs	r3, #0
20000f9c:	e88d 000c 	stmia.w	sp, {r2, r3}
    fw_size = firmware_size_response.size;

    if (fw_size > TFTF_HEADER_SIZE) {
        int rc;
        struct gbfw_get_firmware_request req = {0, TFTF_HEADER_SIZE};
        uint16_t msg_id = greybus_get_next_id();
20000fa0:	4601      	mov	r1, r0
        if (gbfw_is_apbe_flash_stage()) {
            req.offset = TFTF_HEADER_SIZE;
            firmware_size_response.size -= TFTF_HEADER_SIZE;
        }
#endif
        rc = greybus_send_request(gbfw_cportid, msg_id, GB_FW_OP_GET_FIRMWARE,
20000fa2:	2203      	movs	r2, #3
20000fa4:	6838      	ldr	r0, [r7, #0]
20000fa6:	ab02      	add	r3, sp, #8
20000fa8:	f7ff fdf4 	bl	20000b94 <greybus_send_request>
                                  (uint8_t*)&req, sizeof(req), NULL);
        if (rc) {
20000fac:	2800      	cmp	r0, #0
20000fae:	f040 8142 	bne.w	20001236 <fw_cport_handler+0x37e>
            return rc;
        }
        fw_flash_data.fw_request_size = TFTF_HEADER_SIZE;
20000fb2:	4b7d      	ldr	r3, [pc, #500]	; (200011a8 <fw_cport_handler+0x2f0>)
20000fb4:	f44f 7200 	mov.w	r2, #512	; 0x200
20000fb8:	605a      	str	r2, [r3, #4]
20000fba:	e13c      	b.n	20001236 <fw_cport_handler+0x37e>
    } else {
        dbgprint("skip empty firmware");
20000fbc:	487b      	ldr	r0, [pc, #492]	; (200011ac <fw_cport_handler+0x2f4>)
20000fbe:	f004 f86f 	bl	200050a0 <dbgprint>
        gbfw_next_stage();
20000fc2:	f7ff ff1d 	bl	20000e00 <gbfw_next_stage>
20000fc6:	e0d4      	b.n	20001172 <fw_cport_handler+0x2ba>
    int err_count = 0;

    tftf_header *tf_header = (tftf_header *)data;
    data_ptr = (uint8_t *)data;

    if (tftf_header_received == false) {
20000fc8:	4c79      	ldr	r4, [pc, #484]	; (200011b0 <fw_cport_handler+0x2f8>)
20000fca:	7823      	ldrb	r3, [r4, #0]
    /*
     * This works here because we're actually calling this handler
     * synchronously.  We set the constant and return to the recipient rather
     * than setting the constant in parallel with the recipient.
     */
    data_ptr += sizeof(gb_operation_header);
20000fcc:	f105 0608 	add.w	r6, r5, #8
    int err_count = 0;

    tftf_header *tf_header = (tftf_header *)data;
    data_ptr = (uint8_t *)data;

    if (tftf_header_received == false) {
20000fd0:	2b00      	cmp	r3, #0
20000fd2:	f040 8083 	bne.w	200010dc <fw_cport_handler+0x224>
        if (!valid_tftf_header(tf_header)) {
20000fd6:	4630      	mov	r0, r6
20000fd8:	f000 f9d8 	bl	2000138c <valid_tftf_header>
20000fdc:	b908      	cbnz	r0, 20000fe2 <fw_cport_handler+0x12a>
            dbgprint("INVALID_TFTF");
20000fde:	4875      	ldr	r0, [pc, #468]	; (200011b4 <fw_cport_handler+0x2fc>)
20000fe0:	e778      	b.n	20000ed4 <fw_cport_handler+0x1c>
            return GB_FW_ERR_INVALID;
        }

        memcpy(tftf_buff, data_ptr, sizeof(tftf_header));
20000fe2:	4631      	mov	r1, r6
20000fe4:	f44f 7200 	mov.w	r2, #512	; 0x200
20000fe8:	4873      	ldr	r0, [pc, #460]	; (200011b8 <fw_cport_handler+0x300>)
20000fea:	f004 fe4b 	bl	20005c84 <memcpy>
        tftf_header_received = true;
20000fee:	2001      	movs	r0, #1

        /* flash the raw code and any attached sections*/
        section_index = get_section_index(TFTF_SECTION_RAW_CODE, &tf_header->sections[0]);
20000ff0:	f105 0178 	add.w	r1, r5, #120	; 0x78
            dbgprint("INVALID_TFTF");
            return GB_FW_ERR_INVALID;
        }

        memcpy(tftf_buff, data_ptr, sizeof(tftf_header));
        tftf_header_received = true;
20000ff4:	7020      	strb	r0, [r4, #0]

        /* flash the raw code and any attached sections*/
        section_index = get_section_index(TFTF_SECTION_RAW_CODE, &tf_header->sections[0]);
20000ff6:	f000 fa1f 	bl	20001438 <get_section_index>
20000ffa:	4b70      	ldr	r3, [pc, #448]	; (200011bc <fw_cport_handler+0x304>)
20000ffc:	b280      	uxth	r0, r0
        if (section_index == TFTF_SECTION_END) {
20000ffe:	28fe      	cmp	r0, #254	; 0xfe

        memcpy(tftf_buff, data_ptr, sizeof(tftf_header));
        tftf_header_received = true;

        /* flash the raw code and any attached sections*/
        section_index = get_section_index(TFTF_SECTION_RAW_CODE, &tf_header->sections[0]);
20001000:	8018      	strh	r0, [r3, #0]
20001002:	4698      	mov	r8, r3
        if (section_index == TFTF_SECTION_END) {
20001004:	d101      	bne.n	2000100a <fw_cport_handler+0x152>
            dbgprint("No sections to flash");
20001006:	486e      	ldr	r0, [pc, #440]	; (200011c0 <fw_cport_handler+0x308>)
20001008:	e764      	b.n	20000ed4 <fw_cport_handler+0x1c>
            return GB_FW_ERR_INVALID;
        }

        if (set_flashing_flag()) {
2000100a:	f7ff f99f 	bl	2000034c <set_flashing_flag>
2000100e:	b120      	cbz	r0, 2000101a <fw_cport_handler+0x162>
            dbgprint("Failed to set flashing flag\r\n");
20001010:	486c      	ldr	r0, [pc, #432]	; (200011c4 <fw_cport_handler+0x30c>)
20001012:	f004 f845 	bl	200050a0 <dbgprint>
            HAL_NVIC_SystemReset();
20001016:	f002 fc7b 	bl	20003910 <HAL_NVIC_SystemReset>
        }

        /* erase image copy address and size */
        fw_flash_data.fw_flash_addr = tf_header->sections[section_index].section_load_address;
2000101a:	f8b8 3000 	ldrh.w	r3, [r8]
2000101e:	4c62      	ldr	r4, [pc, #392]	; (200011a8 <fw_cport_handler+0x2f0>)
20001020:	2214      	movs	r2, #20
20001022:	fb02 5303 	mla	r3, r2, r3, r5
20001026:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000102a:	6023      	str	r3, [r4, #0]
        fw_flash_data.fw_remaining_size = firmware_size_response.size - TFTF_HEADER_SIZE;
2000102c:	4b5c      	ldr	r3, [pc, #368]	; (200011a0 <fw_cport_handler+0x2e8>)
2000102e:	f8d3 8000 	ldr.w	r8, [r3]
20001032:	f5a8 7300 	sub.w	r3, r8, #512	; 0x200
20001036:	60e3      	str	r3, [r4, #12]
        fw_flash_data.fw_offset = 0;
20001038:	2300      	movs	r3, #0
2000103a:	60a3      	str	r3, [r4, #8]
        fw_flash_data.new_payload_size = 0;
2000103c:	6123      	str	r3, [r4, #16]
}

#ifdef CONFIG_APBE_FLASH
static bool gbfw_is_apbe_flash_stage(void)
{
   return _gbfw_stage == GBFW_STAGE_APBE_SPI_FLASH ? true : false;
2000103e:	4b59      	ldr	r3, [pc, #356]	; (200011a4 <fw_cport_handler+0x2ec>)
20001040:	781a      	ldrb	r2, [r3, #0]
        fw_flash_data.fw_flash_addr = tf_header->sections[section_index].section_load_address;
        fw_flash_data.fw_remaining_size = firmware_size_response.size - TFTF_HEADER_SIZE;
        fw_flash_data.fw_offset = 0;
        fw_flash_data.new_payload_size = 0;
#ifdef CONFIG_APBE_FLASH
        if (gbfw_is_apbe_flash_stage()) {
20001042:	2a02      	cmp	r2, #2
20001044:	d118      	bne.n	20001078 <fw_cport_handler+0x1c0>
              * and a muc signature section, need to skip requesting muc signature
              * and muc tftf header, so initialize offset to TFTF_HEADER_SIZE, and
              * remaining size to difference between total firmware size and apbe
              * image size.
              */
             fw_flash_data.fw_offset = TFTF_HEADER_SIZE;
20001046:	f44f 7300 	mov.w	r3, #512	; 0x200
             fw_flash_data.fw_remaining_size -= ((firmware_size_response.size - TFTF_HEADER_SIZE) -
                                                 spi_write_calc_total_len(data));
2000104a:	4630      	mov	r0, r6
              * and a muc signature section, need to skip requesting muc signature
              * and muc tftf header, so initialize offset to TFTF_HEADER_SIZE, and
              * remaining size to difference between total firmware size and apbe
              * image size.
              */
             fw_flash_data.fw_offset = TFTF_HEADER_SIZE;
2000104c:	60a3      	str	r3, [r4, #8]
             fw_flash_data.fw_remaining_size -= ((firmware_size_response.size - TFTF_HEADER_SIZE) -
                                                 spi_write_calc_total_len(data));
2000104e:	f001 f90d 	bl	2000226c <spi_write_calc_total_len>
20001052:	68e3      	ldr	r3, [r4, #12]
20001054:	ebc8 0303 	rsb	r3, r8, r3
20001058:	f503 7300 	add.w	r3, r3, #512	; 0x200
              * and muc tftf header, so initialize offset to TFTF_HEADER_SIZE, and
              * remaining size to difference between total firmware size and apbe
              * image size.
              */
             fw_flash_data.fw_offset = TFTF_HEADER_SIZE;
             fw_flash_data.fw_remaining_size -= ((firmware_size_response.size - TFTF_HEADER_SIZE) -
2000105c:	4418      	add	r0, r3
2000105e:	60e0      	str	r0, [r4, #12]
20001060:	2503      	movs	r5, #3
                                                 spi_write_calc_total_len(data));
             do {
                 err = spi_write_to_flash_header(&spi_write_ops, data);
20001062:	4859      	ldr	r0, [pc, #356]	; (200011c8 <fw_cport_handler+0x310>)
20001064:	4631      	mov	r1, r6
20001066:	f001 f911 	bl	2000228c <spi_write_to_flash_header>
                 if (err) {
2000106a:	b330      	cbz	r0, 200010ba <fw_cport_handler+0x202>
                     dbgprint("spi_write_to_flash_header error\r\n");
2000106c:	4857      	ldr	r0, [pc, #348]	; (200011cc <fw_cport_handler+0x314>)
2000106e:	f004 f817 	bl	200050a0 <dbgprint>
                     err_count++;
                 }
             } while (err && err_count < GBFW_MAX_RETRIES);
20001072:	3d01      	subs	r5, #1
20001074:	d1f5      	bne.n	20001062 <fw_cport_handler+0x1aa>
20001076:	e01e      	b.n	200010b6 <fw_cport_handler+0x1fe>
             else
                 err_count = 0;
        } else
#endif
        {
            if (_gbfw_stage == GBFW_STAGE_MAIN) {
20001078:	2a03      	cmp	r2, #3
2000107a:	d101      	bne.n	20001080 <fw_cport_handler+0x1c8>
                erase_tftf_header();
2000107c:	f7ff fd2e 	bl	20000adc <erase_tftf_header>
            }
            flash_erase(fw_flash_data.fw_flash_addr, fw_flash_data.fw_remaining_size);
20001080:	6820      	ldr	r0, [r4, #0]
20001082:	68e1      	ldr	r1, [r4, #12]
20001084:	f7ff fc9c 	bl	200009c0 <flash_erase>

            /* program the first packet */
            data_ptr += sizeof(tftf_header);

            flash_addr = fw_flash_data.fw_flash_addr + fw_flash_data.fw_offset;
20001088:	6823      	ldr	r3, [r4, #0]
2000108a:	68a2      	ldr	r2, [r4, #8]
2000108c:	eb02 0903 	add.w	r9, r2, r3
            flash_data_size = fw_flash_data.fw_request_size - TFTF_HEADER_SIZE;
20001090:	6863      	ldr	r3, [r4, #4]
                erase_tftf_header();
            }
            flash_erase(fw_flash_data.fw_flash_addr, fw_flash_data.fw_remaining_size);

            /* program the first packet */
            data_ptr += sizeof(tftf_header);
20001092:	f505 7502 	add.w	r5, r5, #520	; 0x208

            flash_addr = fw_flash_data.fw_flash_addr + fw_flash_data.fw_offset;
            flash_data_size = fw_flash_data.fw_request_size - TFTF_HEADER_SIZE;
20001096:	f5a3 7a00 	sub.w	sl, r3, #512	; 0x200
2000109a:	f04f 0803 	mov.w	r8, #3
            dbgprinthex32(flash_addr);
            dbgprint("\r\n");
#endif

             do {
                 err = program_flash_data(flash_addr, flash_data_size, data_ptr);
2000109e:	4648      	mov	r0, r9
200010a0:	4651      	mov	r1, sl
200010a2:	462a      	mov	r2, r5
200010a4:	f7ff fcee 	bl	20000a84 <program_flash_data>
                 if (err) {
200010a8:	b138      	cbz	r0, 200010ba <fw_cport_handler+0x202>
                     dbgprint("program_flash_data (hdr) error\r\n");
200010aa:	4849      	ldr	r0, [pc, #292]	; (200011d0 <fw_cport_handler+0x318>)
200010ac:	f003 fff8 	bl	200050a0 <dbgprint>
                     err_count++;
                }
             } while (err && err_count < GBFW_MAX_RETRIES);
200010b0:	f1b8 0801 	subs.w	r8, r8, #1
200010b4:	d1f3      	bne.n	2000109e <fw_cport_handler+0x1e6>
                     err_count++;
                 }
             } while (err && err_count < GBFW_MAX_RETRIES);

             if (err)
                 HAL_NVIC_SystemReset();
200010b6:	f002 fc2b 	bl	20003910 <HAL_NVIC_SystemReset>
                 HAL_NVIC_SystemReset();
             else
                 err_count = 0;
        }

        fw_flash_data.fw_offset += (fw_flash_data.fw_request_size - TFTF_HEADER_SIZE);
200010ba:	6861      	ldr	r1, [r4, #4]
200010bc:	68a2      	ldr	r2, [r4, #8]
        fw_flash_data.fw_remaining_size -= (fw_flash_data.fw_request_size - TFTF_HEADER_SIZE);
200010be:	68e3      	ldr	r3, [r4, #12]
                 HAL_NVIC_SystemReset();
             else
                 err_count = 0;
        }

        fw_flash_data.fw_offset += (fw_flash_data.fw_request_size - TFTF_HEADER_SIZE);
200010c0:	440a      	add	r2, r1
        fw_flash_data.fw_remaining_size -= (fw_flash_data.fw_request_size - TFTF_HEADER_SIZE);
200010c2:	1a5b      	subs	r3, r3, r1
                 HAL_NVIC_SystemReset();
             else
                 err_count = 0;
        }

        fw_flash_data.fw_offset += (fw_flash_data.fw_request_size - TFTF_HEADER_SIZE);
200010c4:	f5a2 7200 	sub.w	r2, r2, #512	; 0x200
        fw_flash_data.fw_remaining_size -= (fw_flash_data.fw_request_size - TFTF_HEADER_SIZE);
200010c8:	f503 7300 	add.w	r3, r3, #512	; 0x200
                 HAL_NVIC_SystemReset();
             else
                 err_count = 0;
        }

        fw_flash_data.fw_offset += (fw_flash_data.fw_request_size - TFTF_HEADER_SIZE);
200010cc:	60a2      	str	r2, [r4, #8]
        fw_flash_data.fw_remaining_size -= (fw_flash_data.fw_request_size - TFTF_HEADER_SIZE);
200010ce:	60e3      	str	r3, [r4, #12]
    return 0;
}

static inline uint16_t gbfw_get_payload_size(void)
{
    return greybus_get_max_payload_size();
200010d0:	f7ff fd5a 	bl	20000b88 <greybus_get_max_payload_size>
        /* Calculate the size for get firmware request */
        pl_data_size = gbfw_get_payload_size();

        /* data size should be multiple of uint64_t */
        fw_flash_data.fw_request_size =
                 pl_data_size - (pl_data_size % sizeof(uint64_t));
200010d4:	f020 0007 	bic.w	r0, r0, #7

        /* Calculate the size for get firmware request */
        pl_data_size = gbfw_get_payload_size();

        /* data size should be multiple of uint64_t */
        fw_flash_data.fw_request_size =
200010d8:	6060      	str	r0, [r4, #4]
200010da:	e030      	b.n	2000113e <fw_cport_handler+0x286>
}

#ifdef CONFIG_APBE_FLASH
static bool gbfw_is_apbe_flash_stage(void)
{
   return _gbfw_stage == GBFW_STAGE_APBE_SPI_FLASH ? true : false;
200010dc:	4b31      	ldr	r3, [pc, #196]	; (200011a4 <fw_cport_handler+0x2ec>)
200010de:	4c32      	ldr	r4, [pc, #200]	; (200011a8 <fw_cport_handler+0x2f0>)
        fw_flash_data.fw_request_size =
                 pl_data_size - (pl_data_size % sizeof(uint64_t));
    } else {
        tf_header = (tftf_header *)tftf_buff;
#ifdef CONFIG_APBE_FLASH
        if (gbfw_is_apbe_flash_stage()) {
200010e0:	781b      	ldrb	r3, [r3, #0]
200010e2:	2b02      	cmp	r3, #2
200010e4:	d10f      	bne.n	20001106 <fw_cport_handler+0x24e>
200010e6:	2503      	movs	r5, #3
             do {
                 err = spi_write_to_flash_data(&spi_write_ops, data,
200010e8:	4837      	ldr	r0, [pc, #220]	; (200011c8 <fw_cport_handler+0x310>)
200010ea:	6922      	ldr	r2, [r4, #16]
200010ec:	4631      	mov	r1, r6
200010ee:	f001 f985 	bl	200023fc <spi_write_to_flash_data>
                                               fw_flash_data.new_payload_size);
                 if (err) {
200010f2:	b130      	cbz	r0, 20001102 <fw_cport_handler+0x24a>
                     dbgprint("spi_write_to_flash_data error\r\n");
200010f4:	4837      	ldr	r0, [pc, #220]	; (200011d4 <fw_cport_handler+0x31c>)
200010f6:	f003 ffd3 	bl	200050a0 <dbgprint>
                     err_count++;
                 }
             } while (err && err_count < GBFW_MAX_RETRIES);
200010fa:	3d01      	subs	r5, #1
200010fc:	d1f4      	bne.n	200010e8 <fw_cport_handler+0x230>

             if (err)
                 HAL_NVIC_SystemReset();
200010fe:	f002 fc07 	bl	20003910 <HAL_NVIC_SystemReset>
             else
                 err_count = 0;

             flash_data_size = fw_flash_data.new_payload_size;
20001102:	6925      	ldr	r5, [r4, #16]
20001104:	e014      	b.n	20001130 <fw_cport_handler+0x278>
        } else
#endif
        {
            flash_addr = fw_flash_data.fw_flash_addr + fw_flash_data.fw_offset;
20001106:	68a2      	ldr	r2, [r4, #8]
20001108:	6823      	ldr	r3, [r4, #0]
            flash_data_size = fw_flash_data.new_payload_size;
2000110a:	6925      	ldr	r5, [r4, #16]

             flash_data_size = fw_flash_data.new_payload_size;
        } else
#endif
        {
            flash_addr = fw_flash_data.fw_flash_addr + fw_flash_data.fw_offset;
2000110c:	eb02 0903 	add.w	r9, r2, r3
            flash_data_size = fw_flash_data.new_payload_size;
20001110:	f04f 0803 	mov.w	r8, #3
            dbgprinthex32(flash_data_size);
            dbgprint("\r\n");
#endif

            do {
                err = program_flash_data(flash_addr, flash_data_size, data_ptr);
20001114:	4648      	mov	r0, r9
20001116:	4629      	mov	r1, r5
20001118:	4632      	mov	r2, r6
2000111a:	f7ff fcb3 	bl	20000a84 <program_flash_data>
                if (err) {
2000111e:	b138      	cbz	r0, 20001130 <fw_cport_handler+0x278>
                    dbgprint("program_flash_data error\r\n");
20001120:	482d      	ldr	r0, [pc, #180]	; (200011d8 <fw_cport_handler+0x320>)
20001122:	f003 ffbd 	bl	200050a0 <dbgprint>
                    err_count++;
                }
             } while (err && err_count < GBFW_MAX_RETRIES);
20001126:	f1b8 0801 	subs.w	r8, r8, #1
2000112a:	d1f3      	bne.n	20001114 <fw_cport_handler+0x25c>

             if (err)
                 HAL_NVIC_SystemReset();
2000112c:	f002 fbf0 	bl	20003910 <HAL_NVIC_SystemReset>
             else
                 err_count = 0;
        }

        fw_flash_data.fw_offset += flash_data_size;
20001130:	68a3      	ldr	r3, [r4, #8]

        /* data size should be multiple of uint64_t */
        fw_flash_data.fw_request_size =
                 pl_data_size - (pl_data_size % sizeof(uint64_t));
    } else {
        tf_header = (tftf_header *)tftf_buff;
20001132:	4e21      	ldr	r6, [pc, #132]	; (200011b8 <fw_cport_handler+0x300>)
                 HAL_NVIC_SystemReset();
             else
                 err_count = 0;
        }

        fw_flash_data.fw_offset += flash_data_size;
20001134:	442b      	add	r3, r5
20001136:	60a3      	str	r3, [r4, #8]
        fw_flash_data.fw_remaining_size -= flash_data_size;
20001138:	68e3      	ldr	r3, [r4, #12]
2000113a:	1b5d      	subs	r5, r3, r5
2000113c:	60e5      	str	r5, [r4, #12]
        dbgprinthex32(fw_flash_data.fw_remaining_size);
        dbgprint("\r\n");
#endif
    }

    if (fw_flash_data.fw_remaining_size > 0) {
2000113e:	4a1a      	ldr	r2, [pc, #104]	; (200011a8 <fw_cport_handler+0x2f0>)
20001140:	68d1      	ldr	r1, [r2, #12]
20001142:	2900      	cmp	r1, #0
20001144:	dd4a      	ble.n	200011dc <fw_cport_handler+0x324>
        if (fw_flash_data.fw_remaining_size < fw_flash_data.fw_request_size) {
20001146:	6853      	ldr	r3, [r2, #4]
            fw_flash_data.new_payload_size = fw_flash_data.fw_remaining_size;
20001148:	428b      	cmp	r3, r1
2000114a:	bf28      	it	cs
2000114c:	460b      	movcs	r3, r1
2000114e:	6113      	str	r3, [r2, #16]
#ifdef CONFIG_DEBUG_FIRMWARE
        dbgprint("Req:");
        dbgprinthex32(fw_flash_data.new_payload_size);
        dbgprint("\r\n");
#endif
        gbfw_get_firmware(fw_flash_data.fw_offset + TFTF_HEADER_SIZE,
20001150:	6892      	ldr	r2, [r2, #8]
}

static int gbfw_get_firmware(uint32_t offset, uint32_t size)
{
    int rc;
    struct gbfw_get_firmware_request req = {offset, size};
20001152:	9303      	str	r3, [sp, #12]
#ifdef CONFIG_DEBUG_FIRMWARE
        dbgprint("Req:");
        dbgprinthex32(fw_flash_data.new_payload_size);
        dbgprint("\r\n");
#endif
        gbfw_get_firmware(fw_flash_data.fw_offset + TFTF_HEADER_SIZE,
20001154:	f502 7200 	add.w	r2, r2, #512	; 0x200
}

static int gbfw_get_firmware(uint32_t offset, uint32_t size)
{
    int rc;
    struct gbfw_get_firmware_request req = {offset, size};
20001158:	9202      	str	r2, [sp, #8]
    uint16_t msg_id = greybus_get_next_id();

    rc = greybus_send_request(gbfw_cportid, msg_id, GB_FW_OP_GET_FIRMWARE,
2000115a:	2400      	movs	r4, #0

static int gbfw_get_firmware(uint32_t offset, uint32_t size)
{
    int rc;
    struct gbfw_get_firmware_request req = {offset, size};
    uint16_t msg_id = greybus_get_next_id();
2000115c:	f7ff fd0a 	bl	20000b74 <greybus_get_next_id>

    rc = greybus_send_request(gbfw_cportid, msg_id, GB_FW_OP_GET_FIRMWARE,
20001160:	2308      	movs	r3, #8
20001162:	e88d 0018 	stmia.w	sp, {r3, r4}

static int gbfw_get_firmware(uint32_t offset, uint32_t size)
{
    int rc;
    struct gbfw_get_firmware_request req = {offset, size};
    uint16_t msg_id = greybus_get_next_id();
20001166:	4601      	mov	r1, r0

    rc = greybus_send_request(gbfw_cportid, msg_id, GB_FW_OP_GET_FIRMWARE,
20001168:	2203      	movs	r2, #3
2000116a:	6838      	ldr	r0, [r7, #0]
2000116c:	446b      	add	r3, sp
2000116e:	f7ff fd11 	bl	20000b94 <greybus_send_request>
            }
        }
        _gbfw_updated_count++;
        gbfw_next_stage();
    }
    return 0;
20001172:	4620      	mov	r0, r4
20001174:	e05f      	b.n	20001236 <fw_cport_handler+0x37e>
20001176:	bf00      	nop
20001178:	200066e0 	.word	0x200066e0
2000117c:	20005f8b 	.word	0x20005f8b
20001180:	20005fb1 	.word	0x20005fb1
20001184:	20005fda 	.word	0x20005fda
20001188:	20006009 	.word	0x20006009
2000118c:	20005e34 	.word	0x20005e34
20001190:	20006021 	.word	0x20006021
20001194:	20006039 	.word	0x20006039
20001198:	20000ea1 	.word	0x20000ea1
2000119c:	20006067 	.word	0x20006067
200011a0:	200068ff 	.word	0x200068ff
200011a4:	200066fe 	.word	0x200066fe
200011a8:	200066e8 	.word	0x200066e8
200011ac:	20006098 	.word	0x20006098
200011b0:	200066e4 	.word	0x200066e4
200011b4:	200060ac 	.word	0x200060ac
200011b8:	200066ff 	.word	0x200066ff
200011bc:	200066fc 	.word	0x200066fc
200011c0:	200060b9 	.word	0x200060b9
200011c4:	200060ce 	.word	0x200060ce
200011c8:	2000658c 	.word	0x2000658c
200011cc:	200060ec 	.word	0x200060ec
200011d0:	2000610e 	.word	0x2000610e
200011d4:	2000612f 	.word	0x2000612f
200011d8:	2000614f 	.word	0x2000614f
}

#ifdef CONFIG_APBE_FLASH
static bool gbfw_is_apbe_flash_stage(void)
{
   return _gbfw_stage == GBFW_STAGE_APBE_SPI_FLASH ? true : false;
200011dc:	4b17      	ldr	r3, [pc, #92]	; (2000123c <fw_cport_handler+0x384>)
                          fw_flash_data.new_payload_size);
    } else {
        /* No more data to write */

#ifdef CONFIG_APBE_FLASH
        if (gbfw_is_apbe_flash_stage())
200011de:	781a      	ldrb	r2, [r3, #0]
200011e0:	2a02      	cmp	r2, #2
200011e2:	461c      	mov	r4, r3
200011e4:	d103      	bne.n	200011ee <fw_cport_handler+0x336>
            spi_write_to_flash_finish(&spi_write_ops);
200011e6:	4816      	ldr	r0, [pc, #88]	; (20001240 <fw_cport_handler+0x388>)
200011e8:	f001 f91c 	bl	20002424 <spi_write_to_flash_finish>
200011ec:	e001      	b.n	200011f2 <fw_cport_handler+0x33a>
        else
#endif
        {

            program_flash_lock();
200011ee:	f7ff fc12 	bl	20000a16 <program_flash_lock>
        }

        /* now that we are done flashing, if this is the main stage,
         * then we want to update the tf header section */
        if (_gbfw_stage == GBFW_STAGE_MAIN) {
200011f2:	7823      	ldrb	r3, [r4, #0]
200011f4:	2b03      	cmp	r3, #3
200011f6:	d108      	bne.n	2000120a <fw_cport_handler+0x352>
            if (valid_tftf_header(tf_header)) {
200011f8:	4630      	mov	r0, r6
200011fa:	f000 f8c7 	bl	2000138c <valid_tftf_header>
200011fe:	b120      	cbz	r0, 2000120a <fw_cport_handler+0x352>
                program_tftf_header(tftf_buff, sizeof(tftf_buff));
20001200:	4810      	ldr	r0, [pc, #64]	; (20001244 <fw_cport_handler+0x38c>)
20001202:	f44f 7100 	mov.w	r1, #512	; 0x200
20001206:	f7ff fc6f 	bl	20000ae8 <program_tftf_header>
            }
        }
        _gbfw_updated_count++;
2000120a:	4a0f      	ldr	r2, [pc, #60]	; (20001248 <fw_cport_handler+0x390>)
2000120c:	7813      	ldrb	r3, [r2, #0]
2000120e:	3301      	adds	r3, #1
20001210:	7013      	strb	r3, [r2, #0]
        gbfw_next_stage();
20001212:	f7ff fdf5 	bl	20000e00 <gbfw_next_stage>
20001216:	e00d      	b.n	20001234 <fw_cport_handler+0x37c>
}

static int gbfw_ready_to_boot_response(gb_operation_header *header,
                                       void *data, uint32_t len)
{
    if (header->status) {
20001218:	7968      	ldrb	r0, [r5, #5]
2000121a:	b160      	cbz	r0, 20001236 <fw_cport_handler+0x37e>
        dbgprint("gbfw_ready_to_boot_response(): got error status\r\n");
2000121c:	480b      	ldr	r0, [pc, #44]	; (2000124c <fw_cport_handler+0x394>)
2000121e:	f003 ff3f 	bl	200050a0 <dbgprint>
        return -header->status;
20001222:	7968      	ldrb	r0, [r5, #5]
20001224:	4240      	negs	r0, r0
20001226:	e006      	b.n	20001236 <fw_cport_handler+0x37e>
    gbfw_next_stage();
}

static int gbfw_ap_ready(uint32_t cportid, gb_operation_header *header)
{
    return greybus_send_response(cportid, header, GB_OP_SUCCESS, NULL, 0, gbfw_ap_ready_cb);
20001228:	f7ff fcc1 	bl	20000bae <greybus_send_response>
    case GB_FW_OP_READY_TO_BOOT | GB_TYPE_RESPONSE:
        rc = gbfw_ready_to_boot_response(op_header, data_ptr, len);
        break;
    case GB_FW_OP_AP_READY:
        rc = gbfw_ap_ready(cportid, op_header);
        break;
2000122c:	e003      	b.n	20001236 <fw_cport_handler+0x37e>
    default:
        dbgprint("FWDFLT\r\n");
2000122e:	4808      	ldr	r0, [pc, #32]	; (20001250 <fw_cport_handler+0x398>)
20001230:	f003 ff36 	bl	200050a0 <dbgprint>
    return 0;
}

int fw_cport_handler(uint32_t cportid, void *data, size_t len)
{
    int rc = 0;
20001234:	2000      	movs	r0, #0
        dbgprint("FWDFLT\r\n");
        break;
    }

    return rc;
}
20001236:	b004      	add	sp, #16
20001238:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
2000123c:	200066fe 	.word	0x200066fe
20001240:	2000658c 	.word	0x2000658c
20001244:	200066ff 	.word	0x200066ff
20001248:	20006903 	.word	0x20006903
2000124c:	2000616a 	.word	0x2000616a
20001250:	2000619c 	.word	0x2000619c

20001254 <network_get_max_payload_size>:
    struct mods_nw_hdr hdr;
    uint8_t   payload[0];
} __attribute__ ((packed));

uint16_t network_get_max_payload_size(void)
{
20001254:	b508      	push	{r3, lr}
    return datalink_get_max_payload_size() - sizeof(struct mods_nw_hdr);
20001256:	f000 fd1d 	bl	20001c94 <datalink_get_max_payload_size>
2000125a:	3802      	subs	r0, #2
}
2000125c:	b280      	uxth	r0, r0
2000125e:	bd08      	pop	{r3, pc}

20001260 <network_send>:

int network_send(uint32_t cport, uint8_t *buf, size_t len, msg_sent_cb cb)
{
    struct mods_nw_msg *nw = (struct mods_nw_msg *)&buf[-sizeof(struct mods_nw_hdr)];
    nw->hdr.cport = cport;
20001260:	f821 0d02 	strh.w	r0, [r1, #-2]!

    return datalink_send((uint8_t *)nw, len + sizeof(struct mods_nw_hdr), cb, NULL);
20001264:	4608      	mov	r0, r1
20001266:	1c91      	adds	r1, r2, #2
20001268:	461a      	mov	r2, r3
2000126a:	2300      	movs	r3, #0
2000126c:	f000 bd44 	b.w	20001cf8 <datalink_send>

20001270 <network_recv>:
}

/* TODO: switch should be part of greybus core */
int network_recv(const void *msg, size_t len)
{
20001270:	b510      	push	{r4, lr}
20001272:	460a      	mov	r2, r1
    struct mods_nw_msg *m_msg = (struct mods_nw_msg *)msg;
    int rc = 0;

    switch(m_msg->hdr.cport) {
20001274:	8801      	ldrh	r1, [r0, #0]
20001276:	2901      	cmp	r1, #1
    return datalink_send((uint8_t *)nw, len + sizeof(struct mods_nw_hdr), cb, NULL);
}

/* TODO: switch should be part of greybus core */
int network_recv(const void *msg, size_t len)
{
20001278:	4603      	mov	r3, r0
    struct mods_nw_msg *m_msg = (struct mods_nw_msg *)msg;
    int rc = 0;

    switch(m_msg->hdr.cport) {
2000127a:	d010      	beq.n	2000129e <network_recv+0x2e>
2000127c:	d309      	bcc.n	20001292 <network_recv+0x22>
2000127e:	f64f 70ff 	movw	r0, #65535	; 0xffff
20001282:	4281      	cmp	r1, r0
20001284:	d11a      	bne.n	200012bc <network_recv+0x4c>
        dbgprint("fw_cport_handler failed\r\n");
        goto protocol_error;
      }
      break;
    case MODS_CONTROL_CPORT:
      rc = mods_control_handler(m_msg->hdr.cport, m_msg->payload,
20001286:	4608      	mov	r0, r1
20001288:	3a02      	subs	r2, #2
2000128a:	1c99      	adds	r1, r3, #2
2000128c:	f7ff fd28 	bl	20000ce0 <mods_control_handler>
20001290:	e010      	b.n	200012b4 <network_recv+0x44>
    struct mods_nw_msg *m_msg = (struct mods_nw_msg *)msg;
    int rc = 0;

    switch(m_msg->hdr.cport) {
    case CONTROL_CPORT:
      rc = control_cport_handler(m_msg->hdr.cport, m_msg->payload,
20001292:	1c99      	adds	r1, r3, #2
20001294:	3a02      	subs	r2, #2
20001296:	2000      	movs	r0, #0
20001298:	f7ff fc9c 	bl	20000bd4 <control_cport_handler>
2000129c:	e00a      	b.n	200012b4 <network_recv+0x44>
        dbgprint("mods_control_handler failed\r\n");
        goto protocol_error;
      }
      break;
    case FIRMWARE_CPORT:
      rc = fw_cport_handler(m_msg->hdr.cport, m_msg->payload,
2000129e:	4608      	mov	r0, r1
200012a0:	3a02      	subs	r2, #2
200012a2:	1c99      	adds	r1, r3, #2
200012a4:	f7ff fe08 	bl	20000eb8 <fw_cport_handler>
                    len - sizeof(struct mods_nw_hdr));
      if (rc != GB_OP_SUCCESS) {
200012a8:	4604      	mov	r4, r0
200012aa:	b160      	cbz	r0, 200012c6 <network_recv+0x56>
        dbgprint("fw_cport_handler failed\r\n");
200012ac:	4807      	ldr	r0, [pc, #28]	; (200012cc <network_recv+0x5c>)
200012ae:	f003 fef7 	bl	200050a0 <dbgprint>
        goto protocol_error;
200012b2:	e008      	b.n	200012c6 <network_recv+0x56>
      }
      break;
    case MODS_CONTROL_CPORT:
      rc = mods_control_handler(m_msg->hdr.cport, m_msg->payload,
                    len - sizeof(struct mods_nw_hdr));
      if (rc != GB_OP_SUCCESS) {
200012b4:	4604      	mov	r4, r0
200012b6:	b130      	cbz	r0, 200012c6 <network_recv+0x56>
        dbgprint("mods_control_handler failed\r\n");
200012b8:	4805      	ldr	r0, [pc, #20]	; (200012d0 <network_recv+0x60>)
200012ba:	e7f8      	b.n	200012ae <network_recv+0x3e>
        goto protocol_error;
      }
      break;
    default:
      dbgprintx32("ERROR received message for cport ", m_msg->hdr.cport, "\r\n");
200012bc:	4805      	ldr	r0, [pc, #20]	; (200012d4 <network_recv+0x64>)
200012be:	4a06      	ldr	r2, [pc, #24]	; (200012d8 <network_recv+0x68>)
200012c0:	f003 ff21 	bl	20005106 <dbgprintx32>

/* TODO: switch should be part of greybus core */
int network_recv(const void *msg, size_t len)
{
    struct mods_nw_msg *m_msg = (struct mods_nw_msg *)msg;
    int rc = 0;
200012c4:	2400      	movs	r4, #0
      break;
    }

protocol_error:
    return rc;
}
200012c6:	4620      	mov	r0, r4
200012c8:	bd10      	pop	{r4, pc}
200012ca:	bf00      	nop
200012cc:	200061c3 	.word	0x200061c3
200012d0:	200061a5 	.word	0x200061a5
200012d4:	200061dd 	.word	0x200061dd
200012d8:	20005e34 	.word	0x20005e34

200012dc <valid_tftf_type>:
 * @param section_type The section type to check
 *
 * @returns True if a valid section type, false otherwise
 */
bool valid_tftf_type(uint32_t section_type) {
     return (((section_type >= TFTF_SECTION_RAW_CODE) &&
200012dc:	1e43      	subs	r3, r0, #1
              (section_type <= TFTF_SECTION_MANIFEST)) ||
             (section_type == TFTF_SECTION_SIGNATURE) ||
             (section_type == TFTF_SECTION_CERTIFICATE) ||
200012de:	2b04      	cmp	r3, #4
200012e0:	d908      	bls.n	200012f4 <valid_tftf_type+0x18>
 *
 * @returns True if a valid section type, false otherwise
 */
bool valid_tftf_type(uint32_t section_type) {
     return (((section_type >= TFTF_SECTION_RAW_CODE) &&
              (section_type <= TFTF_SECTION_MANIFEST)) ||
200012e2:	f1a0 0380 	sub.w	r3, r0, #128	; 0x80
200012e6:	2b01      	cmp	r3, #1
200012e8:	d904      	bls.n	200012f4 <valid_tftf_type+0x18>
             (section_type == TFTF_SECTION_SIGNATURE) ||
             (section_type == TFTF_SECTION_CERTIFICATE) ||
200012ea:	f1a0 03fe 	sub.w	r3, r0, #254	; 0xfe
200012ee:	4258      	negs	r0, r3
200012f0:	4158      	adcs	r0, r3
200012f2:	4770      	bx	lr
200012f4:	2001      	movs	r0, #1
             (section_type == TFTF_SECTION_END));
}
200012f6:	4770      	bx	lr

200012f8 <valid_tftf_section>:
 * @returns True if valid section, false otherwise
 */
bool valid_tftf_section(const tftf_section_descriptor * section,
                        const tftf_header * header,
                        bool * section_contains_start,
                        bool * end_of_sections) {
200012f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint32_t    section_end;
    uint32_t    other_section_start;
    uint32_t    other_section_end;
    const tftf_section_descriptor * other_section;

    if (!valid_tftf_type(section->section_type)) {
200012fc:	7807      	ldrb	r7, [r0, #0]
 * @returns True if valid section, false otherwise
 */
bool valid_tftf_section(const tftf_section_descriptor * section,
                        const tftf_header * header,
                        bool * section_contains_start,
                        bool * end_of_sections) {
200012fe:	4604      	mov	r4, r0
    uint32_t    section_end;
    uint32_t    other_section_start;
    uint32_t    other_section_end;
    const tftf_section_descriptor * other_section;

    if (!valid_tftf_type(section->section_type)) {
20001300:	4638      	mov	r0, r7
 * @returns True if valid section, false otherwise
 */
bool valid_tftf_section(const tftf_section_descriptor * section,
                        const tftf_header * header,
                        bool * section_contains_start,
                        bool * end_of_sections) {
20001302:	4688      	mov	r8, r1
20001304:	4691      	mov	r9, r2
20001306:	461e      	mov	r6, r3
    uint32_t    section_end;
    uint32_t    other_section_start;
    uint32_t    other_section_end;
    const tftf_section_descriptor * other_section;

    if (!valid_tftf_type(section->section_type)) {
20001308:	f7ff ffe8 	bl	200012dc <valid_tftf_type>
2000130c:	4605      	mov	r5, r0
2000130e:	b918      	cbnz	r0, 20001318 <valid_tftf_section+0x20>
        dbgprint("BRE_TFTF_HEADER_TYPE\r\n");
20001310:	481b      	ldr	r0, [pc, #108]	; (20001380 <valid_tftf_section+0x88>)
20001312:	f003 fec5 	bl	200050a0 <dbgprint>
        return false;
20001316:	e030      	b.n	2000137a <valid_tftf_section+0x82>
    }

    /* Is this the end-of-table marker? */
    if (section->section_type == TFTF_SECTION_END) {
20001318:	2ffe      	cmp	r7, #254	; 0xfe
2000131a:	d102      	bne.n	20001322 <valid_tftf_section+0x2a>
        *end_of_sections = true;
2000131c:	2301      	movs	r3, #1
2000131e:	7033      	strb	r3, [r6, #0]
        return true;
20001320:	e02b      	b.n	2000137a <valid_tftf_section+0x82>

    /*
     * Convert the section limits to absolute addresses to compare against
     * absolute addresses found in the TFTF header.
     */
    section_start = section->section_load_address;
20001322:	68e6      	ldr	r6, [r4, #12]
    section_end = section_start + section->section_expanded_length;
20001324:	6923      	ldr	r3, [r4, #16]

    if (section_start == DATA_ADDRESS_TO_BE_IGNORED) {
20001326:	1c70      	adds	r0, r6, #1
20001328:	d027      	beq.n	2000137a <valid_tftf_section+0x82>
        return true;
    }

    /* Verify the expanded/compressed lengths are sane */
    if (section->section_expanded_length < section->section_length) {
2000132a:	68a2      	ldr	r2, [r4, #8]
2000132c:	4293      	cmp	r3, r2
2000132e:	d201      	bcs.n	20001334 <valid_tftf_section+0x3c>
        dbgprint("BRE_TFTF_COMPRESSION_BAD\r\n");
20001330:	4814      	ldr	r0, [pc, #80]	; (20001384 <valid_tftf_section+0x8c>)
20001332:	e01f      	b.n	20001374 <valid_tftf_section+0x7c>
        return false;
    }

    /* Does the section contain the entry point? */
    if ((header->start_location >= section_start) &&
20001334:	f8d8 104c 	ldr.w	r1, [r8, #76]	; 0x4c
20001338:	42b1      	cmp	r1, r6
    /*
     * Convert the section limits to absolute addresses to compare against
     * absolute addresses found in the TFTF header.
     */
    section_start = section->section_load_address;
    section_end = section_start + section->section_expanded_length;
2000133a:	4433      	add	r3, r6
        dbgprint("BRE_TFTF_COMPRESSION_BAD\r\n");
        return false;
    }

    /* Does the section contain the entry point? */
    if ((header->start_location >= section_start) &&
2000133c:	d305      	bcc.n	2000134a <valid_tftf_section+0x52>
2000133e:	4299      	cmp	r1, r3
20001340:	d203      	bcs.n	2000134a <valid_tftf_section+0x52>
        (header->start_location < section_end) &&
20001342:	2f01      	cmp	r7, #1
        (section->section_type == TFTF_SECTION_RAW_CODE)) {
        *section_contains_start = true;
20001344:	bf08      	it	eq
20001346:	f889 7000 	strbeq.w	r7, [r9]
     * the sections array, all sections before us have already validated that
     * they don't collide with us.
     *
     * Overlap is determined to be "non-disjoint" sections
     */
    for (other_section = section + 1;
2000134a:	f104 0014 	add.w	r0, r4, #20
2000134e:	e000      	b.n	20001352 <valid_tftf_section+0x5a>
         ((other_section < &header->sections[TFTF_MAX_SECTIONS]) &&
          (other_section->section_type != TFTF_SECTION_END) &&
          (other_section->section_load_address != DATA_ADDRESS_TO_BE_IGNORED));
         other_section++) {
20001350:	3014      	adds	r0, #20
     * they don't collide with us.
     *
     * Overlap is determined to be "non-disjoint" sections
     */
    for (other_section = section + 1;
         ((other_section < &header->sections[TFTF_MAX_SECTIONS]) &&
20001352:	f508 7200 	add.w	r2, r8, #512	; 0x200
     * the sections array, all sections before us have already validated that
     * they don't collide with us.
     *
     * Overlap is determined to be "non-disjoint" sections
     */
    for (other_section = section + 1;
20001356:	4290      	cmp	r0, r2
20001358:	d20f      	bcs.n	2000137a <valid_tftf_section+0x82>
         ((other_section < &header->sections[TFTF_MAX_SECTIONS]) &&
2000135a:	7802      	ldrb	r2, [r0, #0]
2000135c:	2afe      	cmp	r2, #254	; 0xfe
2000135e:	d00c      	beq.n	2000137a <valid_tftf_section+0x82>
          (other_section->section_type != TFTF_SECTION_END) &&
          (other_section->section_load_address != DATA_ADDRESS_TO_BE_IGNORED));
20001360:	68c2      	ldr	r2, [r0, #12]
     *
     * Overlap is determined to be "non-disjoint" sections
     */
    for (other_section = section + 1;
         ((other_section < &header->sections[TFTF_MAX_SECTIONS]) &&
          (other_section->section_type != TFTF_SECTION_END) &&
20001362:	1c51      	adds	r1, r2, #1
20001364:	d009      	beq.n	2000137a <valid_tftf_section+0x82>
          (other_section->section_load_address != DATA_ADDRESS_TO_BE_IGNORED));
         other_section++) {
        other_section_start = other_section->section_load_address;
        other_section_end = other_section_start +
                            other_section->section_expanded_length;
20001366:	6904      	ldr	r4, [r0, #16]
         ((other_section < &header->sections[TFTF_MAX_SECTIONS]) &&
          (other_section->section_type != TFTF_SECTION_END) &&
          (other_section->section_load_address != DATA_ADDRESS_TO_BE_IGNORED));
         other_section++) {
        other_section_start = other_section->section_load_address;
        other_section_end = other_section_start +
20001368:	4414      	add	r4, r2
                            other_section->section_expanded_length;
        if ((other_section->section_type != TFTF_SECTION_END) &&
2000136a:	42b4      	cmp	r4, r6
2000136c:	d3f0      	bcc.n	20001350 <valid_tftf_section+0x58>
            (!((other_section_end < section_start) ||
2000136e:	429a      	cmp	r2, r3
20001370:	d2ee      	bcs.n	20001350 <valid_tftf_section+0x58>
            (other_section_start >= section_end)))) {
            dbgprint("BRE_TFTF_COLLISION\r\n");
20001372:	4805      	ldr	r0, [pc, #20]	; (20001388 <valid_tftf_section+0x90>)
20001374:	f003 fe94 	bl	200050a0 <dbgprint>
            return false;
20001378:	2500      	movs	r5, #0
        }
    }

    return true;
}
2000137a:	4628      	mov	r0, r5
2000137c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
20001380:	200061ff 	.word	0x200061ff
20001384:	20006216 	.word	0x20006216
20001388:	20006231 	.word	0x20006231

2000138c <valid_tftf_header>:
 *
 * @param header The TFTF header to validate
 *
 * @returns True if valid TFTF header, false otherwise
 */
bool valid_tftf_header(const tftf_header * header) {
2000138c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    bool end_of_sections = false;
    int i;

    /* Verify the sentinel */
    for (i = 0; i < TFTF_SENTINEL_SIZE; i++) {
        if (header->sentinel_value[i] != tftf_sentinel[i]) {
2000138e:	7803      	ldrb	r3, [r0, #0]
 *
 * @returns True if valid TFTF header, false otherwise
 */
bool valid_tftf_header(const tftf_header * header) {
    const tftf_section_descriptor * section;
    bool section_contains_start = false;
20001390:	2400      	movs	r4, #0
    bool end_of_sections = false;
    int i;

    /* Verify the sentinel */
    for (i = 0; i < TFTF_SENTINEL_SIZE; i++) {
        if (header->sentinel_value[i] != tftf_sentinel[i]) {
20001392:	2b54      	cmp	r3, #84	; 0x54
 *
 * @param header The TFTF header to validate
 *
 * @returns True if valid TFTF header, false otherwise
 */
bool valid_tftf_header(const tftf_header * header) {
20001394:	4605      	mov	r5, r0
    const tftf_section_descriptor * section;
    bool section_contains_start = false;
20001396:	f88d 4006 	strb.w	r4, [sp, #6]
    bool end_of_sections = false;
2000139a:	f88d 4007 	strb.w	r4, [sp, #7]
    int i;

    /* Verify the sentinel */
    for (i = 0; i < TFTF_SENTINEL_SIZE; i++) {
        if (header->sentinel_value[i] != tftf_sentinel[i]) {
2000139e:	d108      	bne.n	200013b2 <valid_tftf_header+0x26>
200013a0:	7843      	ldrb	r3, [r0, #1]
200013a2:	2b46      	cmp	r3, #70	; 0x46
200013a4:	d105      	bne.n	200013b2 <valid_tftf_header+0x26>
200013a6:	7883      	ldrb	r3, [r0, #2]
200013a8:	2b54      	cmp	r3, #84	; 0x54
200013aa:	d102      	bne.n	200013b2 <valid_tftf_header+0x26>
200013ac:	78c3      	ldrb	r3, [r0, #3]
200013ae:	2b46      	cmp	r3, #70	; 0x46
200013b0:	d004      	beq.n	200013bc <valid_tftf_header+0x30>
            dbgprint("BRE_TFTF_SENTINEL\r\n");
200013b2:	481c      	ldr	r0, [pc, #112]	; (20001424 <valid_tftf_header+0x98>)
200013b4:	f003 fe74 	bl	200050a0 <dbgprint>
            return false;
200013b8:	2400      	movs	r4, #0
200013ba:	e02f      	b.n	2000141c <valid_tftf_header+0x90>
        }
    }

    if (header->header_size != TFTF_HEADER_SIZE) {
200013bc:	6843      	ldr	r3, [r0, #4]
200013be:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200013c2:	d001      	beq.n	200013c8 <valid_tftf_header+0x3c>
        dbgprint("BRE_TFTF_HEADER_SIZE\r\n");
200013c4:	4818      	ldr	r0, [pc, #96]	; (20001428 <valid_tftf_header+0x9c>)
200013c6:	e027      	b.n	20001418 <valid_tftf_header+0x8c>
        return false;
    }

    /* Verify all of the sections */
    for (section = &header->sections[0];
200013c8:	f100 0670 	add.w	r6, r0, #112	; 0x70
         (section < &header->sections[TFTF_MAX_SECTIONS]) && !end_of_sections;
200013cc:	f505 7100 	add.w	r1, r5, #512	; 0x200
        dbgprint("BRE_TFTF_HEADER_SIZE\r\n");
        return false;
    }

    /* Verify all of the sections */
    for (section = &header->sections[0];
200013d0:	428e      	cmp	r6, r1
200013d2:	f89d 4007 	ldrb.w	r4, [sp, #7]
200013d6:	d302      	bcc.n	200013de <valid_tftf_header+0x52>
                                &end_of_sections)) {
            /* (valid_tftf_section took care of error reporting) */
            return false;
        }
    }
    if (!end_of_sections) {
200013d8:	b97c      	cbnz	r4, 200013fa <valid_tftf_header+0x6e>
        dbgprint("BRE_TFTF_NO_TABLE_END\r\n");
200013da:	4814      	ldr	r0, [pc, #80]	; (2000142c <valid_tftf_header+0xa0>)
200013dc:	e01c      	b.n	20001418 <valid_tftf_header+0x8c>
        return false;
    }

    /* Verify all of the sections */
    for (section = &header->sections[0];
         (section < &header->sections[TFTF_MAX_SECTIONS]) && !end_of_sections;
200013de:	2c00      	cmp	r4, #0
200013e0:	d1fa      	bne.n	200013d8 <valid_tftf_header+0x4c>
         section++) {
        if (!valid_tftf_section(section, header, &section_contains_start,
200013e2:	4630      	mov	r0, r6
200013e4:	4629      	mov	r1, r5
200013e6:	f10d 0206 	add.w	r2, sp, #6
200013ea:	f10d 0307 	add.w	r3, sp, #7
200013ee:	f7ff ff83 	bl	200012f8 <valid_tftf_section>
200013f2:	4604      	mov	r4, r0
200013f4:	b190      	cbz	r0, 2000141c <valid_tftf_header+0x90>
    }

    /* Verify all of the sections */
    for (section = &header->sections[0];
         (section < &header->sections[TFTF_MAX_SECTIONS]) && !end_of_sections;
         section++) {
200013f6:	3614      	adds	r6, #20
200013f8:	e7e8      	b.n	200013cc <valid_tftf_header+0x40>
        dbgprint("BRE_TFTF_NO_TABLE_END\r\n");
        return false;
    }

    /* Verify that, if this TFTF has a start address, it falls in one of our code sections. */
    if ((header->start_location != 0) && !section_contains_start) {
200013fa:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
200013fc:	b123      	cbz	r3, 20001408 <valid_tftf_header+0x7c>
200013fe:	f89d 4006 	ldrb.w	r4, [sp, #6]
20001402:	b90c      	cbnz	r4, 20001408 <valid_tftf_header+0x7c>
        dbgprint("BRE_TFTF_START_NOT_IN_CODE\r\n");
20001404:	480a      	ldr	r0, [pc, #40]	; (20001430 <valid_tftf_header+0xa4>)
20001406:	e007      	b.n	20001418 <valid_tftf_header+0x8c>

    /*
     * Verify that the remainder of the header (i.e., unused section
     * descriptors and the padding) is zero-filled
     */
    if (!is_constant_fill((uint8_t *)section,
20001408:	4630      	mov	r0, r6
2000140a:	1b89      	subs	r1, r1, r6
2000140c:	2200      	movs	r2, #0
2000140e:	f7ff fb7b 	bl	20000b08 <is_constant_fill>
20001412:	4604      	mov	r4, r0
20001414:	b910      	cbnz	r0, 2000141c <valid_tftf_header+0x90>
                          (uint32_t)&header[1] - (uint32_t)section,
                          0x00)) {
        dbgprint("BRE_TFTF_NON_ZERO_PAD\r\n");
20001416:	4807      	ldr	r0, [pc, #28]	; (20001434 <valid_tftf_header+0xa8>)
20001418:	f003 fe42 	bl	200050a0 <dbgprint>
        return false;
    }

    return true;
}
2000141c:	4620      	mov	r0, r4
2000141e:	b002      	add	sp, #8
20001420:	bd70      	pop	{r4, r5, r6, pc}
20001422:	bf00      	nop
20001424:	20006246 	.word	0x20006246
20001428:	2000625a 	.word	0x2000625a
2000142c:	20006271 	.word	0x20006271
20001430:	20006289 	.word	0x20006289
20001434:	200062a6 	.word	0x200062a6

20001438 <get_section_index>:

uint8_t get_section_index(uint8_t section_type, const tftf_section_descriptor *section)
{
20001438:	b510      	push	{r4, lr}
2000143a:	2200      	movs	r2, #0
2000143c:	2314      	movs	r3, #20
2000143e:	4353      	muls	r3, r2
20001440:	b294      	uxth	r4, r2
    uint16_t ndx = 0;

    for (ndx = 0; ndx < TFTF_MAX_SECTIONS; ndx++) {
        if (section->section_type == section_type) {
20001442:	5ccb      	ldrb	r3, [r1, r3]
20001444:	4283      	cmp	r3, r0
20001446:	d101      	bne.n	2000144c <get_section_index+0x14>
            return ndx;
20001448:	b2e3      	uxtb	r3, r4
2000144a:	e005      	b.n	20001458 <get_section_index+0x20>
        }
        if (section->section_type == TFTF_SECTION_END) {
2000144c:	2bfe      	cmp	r3, #254	; 0xfe
2000144e:	d003      	beq.n	20001458 <get_section_index+0x20>
20001450:	3201      	adds	r2, #1

uint8_t get_section_index(uint8_t section_type, const tftf_section_descriptor *section)
{
    uint16_t ndx = 0;

    for (ndx = 0; ndx < TFTF_MAX_SECTIONS; ndx++) {
20001452:	2a14      	cmp	r2, #20
20001454:	d1f2      	bne.n	2000143c <get_section_index+0x4>
        if (section->section_type == section_type) {
            return ndx;
        }
        if (section->section_type == TFTF_SECTION_END) {
            return TFTF_SECTION_END;
20001456:	23fe      	movs	r3, #254	; 0xfe
        }
        section++;
    }
    return TFTF_SECTION_END;
}
20001458:	4618      	mov	r0, r3
2000145a:	bd10      	pop	{r4, pc}

2000145c <tftf_get_pid>:
    return 0;
}

uint32_t tftf_get_pid(const tftf_header *header)
{
    if (header)
2000145c:	b108      	cbz	r0, 20001462 <tftf_get_pid+0x6>
        return header->ara_pid;
2000145e:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
20001460:	4770      	bx	lr

    return 0xffffffff;
20001462:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
20001466:	4770      	bx	lr

20001468 <tftf_get_vid>:

uint32_t tftf_get_vid(const tftf_header *header)
{
    if (header)
20001468:	b108      	cbz	r0, 2000146e <tftf_get_vid+0x6>
        return header->ara_vid;
2000146a:	6d80      	ldr	r0, [r0, #88]	; 0x58
2000146c:	4770      	bx	lr

    return 0xffffffff;
2000146e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
20001472:	4770      	bx	lr

20001474 <tftf_get_load_addr>:

int tftf_get_load_addr(const tftf_header *header, uint8_t section_type, uint32_t *addr)
{
20001474:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
20001476:	4606      	mov	r6, r0
    const tftf_section_descriptor *section;
    bool section_contains_start = false;
20001478:	2400      	movs	r4, #0
    bool end_of_sections = false;
    uint16_t sIndex = 0;

    sIndex = get_section_index(section_type, &header->sections[0]);
2000147a:	4608      	mov	r0, r1
2000147c:	f106 0170 	add.w	r1, r6, #112	; 0x70

    return 0xffffffff;
}

int tftf_get_load_addr(const tftf_header *header, uint8_t section_type, uint32_t *addr)
{
20001480:	4617      	mov	r7, r2
    const tftf_section_descriptor *section;
    bool section_contains_start = false;
20001482:	f88d 4006 	strb.w	r4, [sp, #6]
    bool end_of_sections = false;
20001486:	f88d 4007 	strb.w	r4, [sp, #7]
    uint16_t sIndex = 0;

    sIndex = get_section_index(section_type, &header->sections[0]);
2000148a:	f7ff ffd5 	bl	20001438 <get_section_index>
    if(sIndex == TFTF_SECTION_END)
2000148e:	28fe      	cmp	r0, #254	; 0xfe
20001490:	d102      	bne.n	20001498 <tftf_get_load_addr+0x24>
        return -1;
20001492:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20001496:	e012      	b.n	200014be <tftf_get_load_addr+0x4a>
    section = &header->sections[sIndex];
20001498:	2314      	movs	r3, #20
2000149a:	fb03 f500 	mul.w	r5, r3, r0
2000149e:	f105 0070 	add.w	r0, r5, #112	; 0x70

    if (!valid_tftf_section(section, header, &section_contains_start, &end_of_sections))
200014a2:	4430      	add	r0, r6
200014a4:	4631      	mov	r1, r6
200014a6:	f10d 0206 	add.w	r2, sp, #6
200014aa:	f10d 0307 	add.w	r3, sp, #7
200014ae:	f7ff ff23 	bl	200012f8 <valid_tftf_section>
200014b2:	2800      	cmp	r0, #0
200014b4:	d0ed      	beq.n	20001492 <tftf_get_load_addr+0x1e>
        return -1;

    *addr = section->section_load_address;
200014b6:	4435      	add	r5, r6

    return 0;
200014b8:	4620      	mov	r0, r4
    section = &header->sections[sIndex];

    if (!valid_tftf_section(section, header, &section_contains_start, &end_of_sections))
        return -1;

    *addr = section->section_load_address;
200014ba:	6feb      	ldr	r3, [r5, #124]	; 0x7c
200014bc:	603b      	str	r3, [r7, #0]

    return 0;
}
200014be:	b003      	add	sp, #12
200014c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

200014c4 <get_manifest>:

#ifndef CONFIG_STANDALONE_MANFEST
const unsigned char *get_manifest(void)
{
    return manifest;
}
200014c4:	4800      	ldr	r0, [pc, #0]	; (200014c8 <get_manifest+0x4>)
200014c6:	4770      	bx	lr
200014c8:	200062cd 	.word	0x200062cd

200014cc <get_manifest_size>:

uint16_t get_manifest_size(void)
{
    return (uint16_t)sizeof(manifest);
}
200014cc:	f44f 70b2 	mov.w	r0, #356	; 0x164
200014d0:	4770      	bx	lr
	...

200014d4 <reset_systick>:
  uint64_t reserved[MAX_OTP_BLOCKS - MAX_KEY_REVOKES];
};

void reset_systick(void)
{
    SysTick->CTRL = 0UL;
200014d4:	4b02      	ldr	r3, [pc, #8]	; (200014e0 <reset_systick+0xc>)
200014d6:	2200      	movs	r2, #0
200014d8:	601a      	str	r2, [r3, #0]
    SysTick->LOAD = 0UL;
200014da:	605a      	str	r2, [r3, #4]
    SysTick->VAL = 0UL;
200014dc:	609a      	str	r2, [r3, #8]
200014de:	4770      	bx	lr
200014e0:	e000e010 	.word	0xe000e010

200014e4 <chip_reset_irqs>:
{
  volatile static uint32_t *nvic_ictr = ARM_NVIC_ICTR;
  volatile static uint32_t *nvic_icer = ARM_NVIC_ICER;
  uint32_t r;

  for (r = 0; r <  *nvic_ictr; r++) {
200014e4:	2200      	movs	r2, #0
200014e6:	4b07      	ldr	r3, [pc, #28]	; (20001504 <chip_reset_irqs+0x20>)
200014e8:	681b      	ldr	r3, [r3, #0]
200014ea:	429a      	cmp	r2, r3
200014ec:	d208      	bcs.n	20001500 <chip_reset_irqs+0x1c>
200014ee:	f102 2338 	add.w	r3, r2, #939538432	; 0x38003800
200014f2:	3360      	adds	r3, #96	; 0x60
200014f4:	009b      	lsls	r3, r3, #2
      nvic_icer[r] = 0xffffffff;
200014f6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
200014fa:	6019      	str	r1, [r3, #0]
{
  volatile static uint32_t *nvic_ictr = ARM_NVIC_ICTR;
  volatile static uint32_t *nvic_icer = ARM_NVIC_ICER;
  uint32_t r;

  for (r = 0; r <  *nvic_ictr; r++) {
200014fc:	3201      	adds	r2, #1
200014fe:	e7f2      	b.n	200014e6 <chip_reset_irqs+0x2>
      nvic_icer[r] = 0xffffffff;
  }
}
20001500:	4770      	bx	lr
20001502:	bf00      	nop
20001504:	e000e004 	.word	0xe000e004

20001508 <mods_is_spi_csn>:

#ifdef CONFIG_DATALINK_SPI
bool mods_is_spi_csn(uint16_t pin)
{
  return (pin == GPIO_PIN_SPI_CS_N);
}
20001508:	f5a0 5380 	sub.w	r3, r0, #4096	; 0x1000
2000150c:	4258      	negs	r0, r3
2000150e:	4158      	adcs	r0, r3
20001510:	4770      	bx	lr
	...

20001514 <get_chip_uid>:

int get_chip_uid(uint64_t *uid_high, uint64_t *uid_low)
{
  uint32_t regval;

  regval = getreg32(STM32_UID_BASE);
20001514:	4b08      	ldr	r3, [pc, #32]	; (20001538 <get_chip_uid+0x24>)
  return (pin == GPIO_PIN_SPI_CS_N);
}
#endif

int get_chip_uid(uint64_t *uid_high, uint64_t *uid_low)
{
20001516:	b570      	push	{r4, r5, r6, lr}
  uint32_t regval;

  regval = getreg32(STM32_UID_BASE);
20001518:	681e      	ldr	r6, [r3, #0]
  *uid_low = regval;

  regval = getreg32(STM32_UID_BASE + 4);
2000151a:	685c      	ldr	r4, [r3, #4]
  *uid_low |= ((uint64_t)regval) << 32;
2000151c:	4623      	mov	r3, r4
2000151e:	461d      	mov	r5, r3

  regval = getreg32(STM32_UID_BASE + 8);
20001520:	4b06      	ldr	r3, [pc, #24]	; (2000153c <get_chip_uid+0x28>)

  regval = getreg32(STM32_UID_BASE);
  *uid_low = regval;

  regval = getreg32(STM32_UID_BASE + 4);
  *uid_low |= ((uint64_t)regval) << 32;
20001522:	2200      	movs	r2, #0

  regval = getreg32(STM32_UID_BASE + 8);
20001524:	681b      	ldr	r3, [r3, #0]

  regval = getreg32(STM32_UID_BASE);
  *uid_low = regval;

  regval = getreg32(STM32_UID_BASE + 4);
  *uid_low |= ((uint64_t)regval) << 32;
20001526:	ea42 0406 	orr.w	r4, r2, r6
2000152a:	e9c1 4500 	strd	r4, r5, [r1]

  regval = getreg32(STM32_UID_BASE + 8);
  *uid_high = regval;
2000152e:	6003      	str	r3, [r0, #0]
20001530:	6042      	str	r2, [r0, #4]

  return 0;
}
20001532:	4610      	mov	r0, r2
20001534:	bd70      	pop	{r4, r5, r6, pc}
20001536:	bf00      	nop
20001538:	1fff7590 	.word	0x1fff7590
2000153c:	1fff7598 	.word	0x1fff7598

20001540 <SystemClock_Config>:

/** System Clock Configuration
 *  80 MHz
 */
void SystemClock_Config(void)
{
20001540:	b510      	push	{r4, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  __HAL_RCC_PWR_CLK_ENABLE();
20001542:	4b1b      	ldr	r3, [pc, #108]	; (200015b0 <SystemClock_Config+0x70>)
20001544:	6d9a      	ldr	r2, [r3, #88]	; 0x58
20001546:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000

/** System Clock Configuration
 *  80 MHz
 */
void SystemClock_Config(void)
{
2000154a:	b0b4      	sub	sp, #208	; 0xd0
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  __HAL_RCC_PWR_CLK_ENABLE();
2000154c:	659a      	str	r2, [r3, #88]	; 0x58
2000154e:	6d9b      	ldr	r3, [r3, #88]	; 0x58

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
20001550:	f44f 7280 	mov.w	r2, #256	; 0x100
20001554:	9209      	str	r2, [sp, #36]	; 0x24
  RCC_OscInitStruct.HSICalibrationValue = 16;
20001556:	2210      	movs	r2, #16
20001558:	920a      	str	r2, [sp, #40]	; 0x28
{
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  __HAL_RCC_PWR_CLK_ENABLE();
2000155a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
2000155e:	2201      	movs	r2, #1
{
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  __HAL_RCC_PWR_CLK_ENABLE();
20001560:	9300      	str	r3, [sp, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
20001562:	9211      	str	r2, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLN = 10;
20001564:	220a      	movs	r2, #10
{
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  __HAL_RCC_PWR_CLK_ENABLE();
20001566:	9b00      	ldr	r3, [sp, #0]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
20001568:	9212      	str	r2, [sp, #72]	; 0x48
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  __HAL_RCC_PWR_CLK_ENABLE();

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
2000156a:	2302      	movs	r3, #2
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
2000156c:	2207      	movs	r2, #7
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
2000156e:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
20001570:	9213      	str	r2, [sp, #76]	; 0x4c
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  __HAL_RCC_PWR_CLK_ENABLE();

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
20001572:	9306      	str	r3, [sp, #24]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
20001574:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
20001576:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
20001578:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
2000157a:	9315      	str	r3, [sp, #84]	; 0x54
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
2000157c:	f001 f836 	bl	200025ec <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
20001580:	230f      	movs	r3, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
20001582:	2400      	movs	r4, #0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
20001584:	9301      	str	r3, [sp, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
20001586:	2104      	movs	r1, #4
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
20001588:	2303      	movs	r3, #3
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
2000158a:	a801      	add	r0, sp, #4
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
2000158c:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
2000158e:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
20001590:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
20001592:	9405      	str	r4, [sp, #20]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
20001594:	f001 fbb8 	bl	20002d08 <HAL_RCC_ClockConfig>

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C2;
20001598:	2381      	movs	r3, #129	; 0x81
2000159a:	9316      	str	r3, [sp, #88]	; 0x58
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_HSI;
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
2000159c:	a816      	add	r0, sp, #88	; 0x58
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C2;
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_HSI;
2000159e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C2;
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
200015a2:	9420      	str	r4, [sp, #128]	; 0x80
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_HSI;
200015a4:	9327      	str	r3, [sp, #156]	; 0x9c
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
200015a6:	f001 fe85 	bl	200032b4 <HAL_RCCEx_PeriphCLKConfig>
}
200015aa:	b034      	add	sp, #208	; 0xd0
200015ac:	bd10      	pop	{r4, pc}
200015ae:	bf00      	nop
200015b0:	40021000 	.word	0x40021000

200015b4 <MX_USART_UART_Init>:

#ifdef _DEBUG
/* USART init function */
void MX_USART_UART_Init(void)
{
200015b4:	b508      	push	{r3, lr}
  device_console_init();
200015b6:	f000 f8b9 	bl	2000172c <device_console_init>

  huart.Instance = MOD_DEBUG_USART;
200015ba:	480a      	ldr	r0, [pc, #40]	; (200015e4 <MX_USART_UART_Init+0x30>)
  huart.Init.BaudRate = 115200;
200015bc:	4b0a      	ldr	r3, [pc, #40]	; (200015e8 <MX_USART_UART_Init+0x34>)
200015be:	f44f 3ee1 	mov.w	lr, #115200	; 0x1c200
200015c2:	e880 4008 	stmia.w	r0, {r3, lr}
  huart.Init.WordLength = UART_WORDLENGTH_8B;
200015c6:	2300      	movs	r3, #0
200015c8:	6083      	str	r3, [r0, #8]
  huart.Init.StopBits = UART_STOPBITS_1;
200015ca:	60c3      	str	r3, [r0, #12]
  huart.Init.Parity = UART_PARITY_NONE;
200015cc:	6103      	str	r3, [r0, #16]
  huart.Init.Mode = UART_MODE_TX;
200015ce:	2208      	movs	r2, #8
  huart.Init.HwFlowCtl = UART_HWCONTROL_NONE;
200015d0:	6183      	str	r3, [r0, #24]
  huart.Init.OverSampling = UART_OVERSAMPLING_16;
200015d2:	61c3      	str	r3, [r0, #28]
  huart.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED;
200015d4:	6203      	str	r3, [r0, #32]
  huart.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
200015d6:	6243      	str	r3, [r0, #36]	; 0x24
  HAL_UART_Init(&huart);
}
200015d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  huart.Instance = MOD_DEBUG_USART;
  huart.Init.BaudRate = 115200;
  huart.Init.WordLength = UART_WORDLENGTH_8B;
  huart.Init.StopBits = UART_STOPBITS_1;
  huart.Init.Parity = UART_PARITY_NONE;
  huart.Init.Mode = UART_MODE_TX;
200015dc:	6142      	str	r2, [r0, #20]
  huart.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart.Init.OverSampling = UART_OVERSAMPLING_16;
  huart.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED;
  huart.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  HAL_UART_Init(&huart);
200015de:	f003 bfc6 	b.w	2000556e <HAL_UART_Init>
200015e2:	bf00      	nop
200015e4:	20006904 	.word	0x20006904
200015e8:	40004800 	.word	0x40004800

200015ec <MX_DMA_Init>:
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
200015ec:	4b0f      	ldr	r3, [pc, #60]	; (2000162c <MX_DMA_Init+0x40>)

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
200015ee:	b507      	push	{r0, r1, r2, lr}
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
200015f0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
200015f2:	f042 0201 	orr.w	r2, r2, #1
200015f6:	649a      	str	r2, [r3, #72]	; 0x48
200015f8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200015fa:	f003 0301 	and.w	r3, r3, #1
200015fe:	9301      	str	r3, [sp, #4]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 4, 0);
20001600:	2104      	movs	r1, #4
20001602:	2200      	movs	r2, #0
20001604:	200e      	movs	r0, #14
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
20001606:	9b01      	ldr	r3, [sp, #4]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 4, 0);
20001608:	f002 f946 	bl	20003898 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);
2000160c:	200e      	movs	r0, #14
2000160e:	f002 f973 	bl	200038f8 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 4, 0);
20001612:	2104      	movs	r1, #4
20001614:	2200      	movs	r2, #0
20001616:	200f      	movs	r0, #15
20001618:	f002 f93e 	bl	20003898 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
2000161c:	200f      	movs	r0, #15
2000161e:	f002 f96b 	bl	200038f8 <HAL_NVIC_EnableIRQ>

  device_dma_init();
20001622:	f000 f927 	bl	20001874 <device_dma_init>
}
20001626:	b003      	add	sp, #12
20001628:	f85d fb04 	ldr.w	pc, [sp], #4
2000162c:	40021000 	.word	0x40021000

20001630 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
20001630:	b530      	push	{r4, r5, lr}

  /* GPIO Ports Clock Enable */
  mods_gpio_clk_enable();

  /*Configure GPIO pin : RDY/RFR */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
20001632:	2514      	movs	r5, #20
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
20001634:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  mods_gpio_clk_enable();
20001636:	f000 f831 	bl	2000169c <mods_gpio_clk_enable>

  /*Configure GPIO pin : RDY/RFR */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
2000163a:	462a      	mov	r2, r5
2000163c:	a801      	add	r0, sp, #4
2000163e:	2100      	movs	r1, #0
20001640:	f7fe fdca 	bl	200001d8 <memset>
  GPIO_InitStruct.Pin = GPIO_PIN_RFR;
20001644:	2304      	movs	r3, #4
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_RFR, &GPIO_InitStruct);
20001646:	eb0d 0103 	add.w	r1, sp, r3
  mods_gpio_clk_enable();

  /*Configure GPIO pin : RDY/RFR */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_RFR;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
2000164a:	2401      	movs	r4, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_RFR, &GPIO_InitStruct);
2000164c:	480c      	ldr	r0, [pc, #48]	; (20001680 <MX_GPIO_Init+0x50>)
  /* GPIO Ports Clock Enable */
  mods_gpio_clk_enable();

  /*Configure GPIO pin : RDY/RFR */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_RFR;
2000164e:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
20001650:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_RFR, &GPIO_InitStruct);
20001652:	f002 f98b 	bl	2000396c <HAL_GPIO_Init>

  mods_muc_int_set(PIN_RESET);
20001656:	2000      	movs	r0, #0
20001658:	f000 f9a4 	bl	200019a4 <mods_muc_int_set>
  mods_rfr_set(PIN_RESET);
2000165c:	2000      	movs	r0, #0
2000165e:	f000 f98d 	bl	2000197c <mods_rfr_set>

  /*Configure GPIO pin : WAKE_N (input) */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
20001662:	462a      	mov	r2, r5
20001664:	a801      	add	r0, sp, #4
20001666:	2100      	movs	r1, #0
20001668:	f7fe fdb6 	bl	200001d8 <memset>
  GPIO_InitStruct.Pin = GPIO_PIN_WAKE_N;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_WAKE_N, &GPIO_InitStruct);
2000166c:	4805      	ldr	r0, [pc, #20]	; (20001684 <MX_GPIO_Init+0x54>)
  mods_muc_int_set(PIN_RESET);
  mods_rfr_set(PIN_RESET);

  /*Configure GPIO pin : WAKE_N (input) */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_WAKE_N;
2000166e:	9401      	str	r4, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_WAKE_N, &GPIO_InitStruct);
20001670:	a901      	add	r1, sp, #4
20001672:	f002 f97b 	bl	2000396c <HAL_GPIO_Init>

  device_gpio_init();
20001676:	f000 f88b 	bl	20001790 <device_gpio_init>
}
2000167a:	b007      	add	sp, #28
2000167c:	bd30      	pop	{r4, r5, pc}
2000167e:	bf00      	nop
20001680:	48000800 	.word	0x48000800
20001684:	48000400 	.word	0x48000400

20001688 <chip_bootloader_is_readonly>:
bool chip_bootloader_is_readonly(void)
{
#ifdef CONFIG_RUN_FROM_FLASH
    return true;
#else
    uint32_t wrp1a = getreg32(OTP_WRPA_ADDR);
20001688:	4b03      	ldr	r3, [pc, #12]	; (20001698 <chip_bootloader_is_readonly+0x10>)
2000168a:	6818      	ldr	r0, [r3, #0]
    uint32_t wrp1a_start_page = (wrp1a) & 0x000000FF;
2000168c:	b2c0      	uxtb	r0, r0
    if ((wrp1a_start_page < 16))
        return true;
    else
        return false;
#endif
}
2000168e:	280f      	cmp	r0, #15
20001690:	bf8c      	ite	hi
20001692:	2000      	movhi	r0, #0
20001694:	2001      	movls	r0, #1
20001696:	4770      	bx	lr
20001698:	1fff7818 	.word	0x1fff7818

2000169c <mods_gpio_clk_enable>:
#include <stm32_hal_mod.h>
#include <stm32_mod_device.h>
#include <stm32l476xx.h>

void mods_gpio_clk_enable(void)
{
2000169c:	b510      	push	{r4, lr}
  /* GPIO Ports Clock Enable */
  __GPIOA_CLK_ENABLE();
2000169e:	4c22      	ldr	r4, [pc, #136]	; (20001728 <mods_gpio_clk_enable+0x8c>)
200016a0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
200016a2:	f043 0301 	orr.w	r3, r3, #1
200016a6:	64e3      	str	r3, [r4, #76]	; 0x4c
200016a8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
#include <stm32_hal_mod.h>
#include <stm32_mod_device.h>
#include <stm32l476xx.h>

void mods_gpio_clk_enable(void)
{
200016aa:	b088      	sub	sp, #32
  /* GPIO Ports Clock Enable */
  __GPIOA_CLK_ENABLE();
200016ac:	f003 0301 	and.w	r3, r3, #1
200016b0:	9301      	str	r3, [sp, #4]
200016b2:	9b01      	ldr	r3, [sp, #4]
  __GPIOB_CLK_ENABLE();
200016b4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
200016b6:	f043 0302 	orr.w	r3, r3, #2
200016ba:	64e3      	str	r3, [r4, #76]	; 0x4c
200016bc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
200016be:	f003 0302 	and.w	r3, r3, #2
200016c2:	9302      	str	r3, [sp, #8]
200016c4:	9b02      	ldr	r3, [sp, #8]
  __GPIOC_CLK_ENABLE();
200016c6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
200016c8:	f043 0304 	orr.w	r3, r3, #4
200016cc:	64e3      	str	r3, [r4, #76]	; 0x4c
200016ce:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
200016d0:	f003 0304 	and.w	r3, r3, #4
200016d4:	9303      	str	r3, [sp, #12]
200016d6:	9b03      	ldr	r3, [sp, #12]
  __GPIOD_CLK_ENABLE();
200016d8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
200016da:	f043 0308 	orr.w	r3, r3, #8
200016de:	64e3      	str	r3, [r4, #76]	; 0x4c
200016e0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
200016e2:	f003 0308 	and.w	r3, r3, #8
200016e6:	9304      	str	r3, [sp, #16]
200016e8:	9b04      	ldr	r3, [sp, #16]
  /* needed for port g */
  HAL_PWREx_EnableVddIO2();
200016ea:	f003 fcc7 	bl	2000507c <HAL_PWREx_EnableVddIO2>
  __HAL_RCC_PWR_CLK_ENABLE();
200016ee:	6da3      	ldr	r3, [r4, #88]	; 0x58
200016f0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
200016f4:	65a3      	str	r3, [r4, #88]	; 0x58
200016f6:	6da3      	ldr	r3, [r4, #88]	; 0x58
200016f8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
200016fc:	9305      	str	r3, [sp, #20]
200016fe:	9b05      	ldr	r3, [sp, #20]
  __GPIOG_CLK_ENABLE();
20001700:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
20001702:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20001706:	64e3      	str	r3, [r4, #76]	; 0x4c
20001708:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
2000170a:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000170e:	9306      	str	r3, [sp, #24]
20001710:	9b06      	ldr	r3, [sp, #24]
  __GPIOH_CLK_ENABLE();
20001712:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
20001714:	f043 0380 	orr.w	r3, r3, #128	; 0x80
20001718:	64e3      	str	r3, [r4, #76]	; 0x4c
2000171a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
2000171c:	f003 0380 	and.w	r3, r3, #128	; 0x80
20001720:	9307      	str	r3, [sp, #28]
20001722:	9b07      	ldr	r3, [sp, #28]
}
20001724:	b008      	add	sp, #32
20001726:	bd10      	pop	{r4, pc}
20001728:	40021000 	.word	0x40021000

2000172c <device_console_init>:

void device_console_init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct;

    __USART3_CLK_ENABLE();
2000172c:	4b16      	ldr	r3, [pc, #88]	; (20001788 <device_console_init+0x5c>)
  __GPIOG_CLK_ENABLE();
  __GPIOH_CLK_ENABLE();
}

void device_console_init(void)
{
2000172e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    GPIO_InitTypeDef GPIO_InitStruct;

    __USART3_CLK_ENABLE();
20001732:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    GPIO_InitStruct.Pin = GPIO_PIN_CONSOLE_TX;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIO_PORT_CONSOLE_TX, &GPIO_InitStruct);
20001734:	4c15      	ldr	r4, [pc, #84]	; (2000178c <device_console_init+0x60>)

void device_console_init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct;

    __USART3_CLK_ENABLE();
20001736:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2000173a:	659a      	str	r2, [r3, #88]	; 0x58
2000173c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  __GPIOG_CLK_ENABLE();
  __GPIOH_CLK_ENABLE();
}

void device_console_init(void)
{
2000173e:	b086      	sub	sp, #24
    GPIO_InitTypeDef GPIO_InitStruct;

    __USART3_CLK_ENABLE();
20001740:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20001744:	9300      	str	r3, [sp, #0]
20001746:	9b00      	ldr	r3, [sp, #0]

    GPIO_InitStruct.Pin = GPIO_PIN_CONSOLE_TX;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20001748:	f04f 0802 	mov.w	r8, #2
{
    GPIO_InitTypeDef GPIO_InitStruct;

    __USART3_CLK_ENABLE();

    GPIO_InitStruct.Pin = GPIO_PIN_CONSOLE_TX;
2000174c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
20001750:	2701      	movs	r7, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20001752:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
20001754:	2507      	movs	r5, #7
    HAL_GPIO_Init(GPIO_PORT_CONSOLE_TX, &GPIO_InitStruct);
20001756:	4620      	mov	r0, r4
20001758:	a901      	add	r1, sp, #4
{
    GPIO_InitTypeDef GPIO_InitStruct;

    __USART3_CLK_ENABLE();

    GPIO_InitStruct.Pin = GPIO_PIN_CONSOLE_TX;
2000175a:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2000175c:	f8cd 8008 	str.w	r8, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
20001760:	9703      	str	r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20001762:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
20001764:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIO_PORT_CONSOLE_TX, &GPIO_InitStruct);
20001766:	f002 f901 	bl	2000396c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_CONSOLE_RX;
2000176a:	f44f 6300 	mov.w	r3, #2048	; 0x800
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIO_PORT_CONSOLE_RX, &GPIO_InitStruct);
2000176e:	4620      	mov	r0, r4
20001770:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIO_PORT_CONSOLE_TX, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_CONSOLE_RX;
20001772:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20001774:	f8cd 8008 	str.w	r8, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
20001778:	9703      	str	r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
2000177a:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
2000177c:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIO_PORT_CONSOLE_RX, &GPIO_InitStruct);
2000177e:	f002 f8f5 	bl	2000396c <HAL_GPIO_Init>
}
20001782:	b006      	add	sp, #24
20001784:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20001788:	40021000 	.word	0x40021000
2000178c:	48000800 	.word	0x48000800

20001790 <device_gpio_init>:
    HAL_GPIO_DeInit(GPIO_PORT_CONSOLE_TX, GPIO_PIN_CONSOLE_TX);
    HAL_GPIO_DeInit(GPIO_PORT_CONSOLE_RX, GPIO_PIN_CONSOLE_RX);
}

void device_gpio_init(void)
{
20001790:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* will be changed to output during spi setup in SPI_NSS_INT_CTRL_Config */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_INT;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_MUC_INT, &GPIO_InitStruct);
20001792:	4f22      	ldr	r7, [pc, #136]	; (2000181c <device_gpio_init+0x8c>)
    HAL_GPIO_DeInit(GPIO_PORT_CONSOLE_TX, GPIO_PIN_CONSOLE_TX);
    HAL_GPIO_DeInit(GPIO_PORT_CONSOLE_RX, GPIO_PIN_CONSOLE_RX);
}

void device_gpio_init(void)
{
20001794:	b087      	sub	sp, #28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_FORCE_FLASH, &GPIO_InitStruct);
#else
  /* Use INT GPIO as 'force flash' */
  /* will be changed to output during spi setup in SPI_NSS_INT_CTRL_Config */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
20001796:	2414      	movs	r4, #20
20001798:	4622      	mov	r2, r4
2000179a:	a801      	add	r0, sp, #4
2000179c:	2100      	movs	r1, #0
2000179e:	f7fe fd1b 	bl	200001d8 <memset>
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_INT;
200017a2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_MUC_INT, &GPIO_InitStruct);
200017a6:	4638      	mov	r0, r7
200017a8:	a901      	add	r1, sp, #4
  HAL_GPIO_Init(GPIO_PORT_FORCE_FLASH, &GPIO_InitStruct);
#else
  /* Use INT GPIO as 'force flash' */
  /* will be changed to output during spi setup in SPI_NSS_INT_CTRL_Config */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_INT;
200017aa:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_MUC_INT, &GPIO_InitStruct);
200017ac:	f002 f8de 	bl	2000396c <HAL_GPIO_Init>
#endif

  /* Attach Detection */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
200017b0:	4622      	mov	r2, r4
200017b2:	a801      	add	r0, sp, #4
200017b4:	2100      	movs	r1, #0
200017b6:	f7fe fd0f 	bl	200001d8 <memset>
  GPIO_InitStruct.Pin = GPIO_MODS_SL_BPLUS_AIN_PIN;
200017ba:	2320      	movs	r3, #32
200017bc:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_MODS_SL_BPLUS_AIN_PORT, &GPIO_InitStruct);
200017be:	4638      	mov	r0, r7
#endif

  /* Attach Detection */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_MODS_SL_BPLUS_AIN_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
200017c0:	4b17      	ldr	r3, [pc, #92]	; (20001820 <device_gpio_init+0x90>)
200017c2:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_MODS_SL_BPLUS_AIN_PORT, &GPIO_InitStruct);
200017c4:	a901      	add	r1, sp, #4
200017c6:	f002 f8d1 	bl	2000396c <HAL_GPIO_Init>

  /* Configure GPIO pin : MUC_SPI_SEL */
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_SPI_SEL;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
200017ca:	2501      	movs	r5, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
200017cc:	2400      	movs	r4, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
200017ce:	2603      	movs	r6, #3
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_MODS_SL_BPLUS_AIN_PORT, &GPIO_InitStruct);

  /* Configure GPIO pin : MUC_SPI_SEL */
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_SPI_SEL;
200017d0:	2340      	movs	r3, #64	; 0x40
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GPIO_PORT_MUC_SPI_SEL, &GPIO_InitStruct);
200017d2:	4638      	mov	r0, r7
200017d4:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_MODS_SL_BPLUS_AIN_PORT, &GPIO_InitStruct);

  /* Configure GPIO pin : MUC_SPI_SEL */
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_SPI_SEL;
200017d6:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
200017d8:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
200017da:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
200017dc:	9604      	str	r6, [sp, #16]
  HAL_GPIO_Init(GPIO_PORT_MUC_SPI_SEL, &GPIO_InitStruct);
200017de:	f002 f8c5 	bl	2000396c <HAL_GPIO_Init>

  /* APBE power enable and reset */
  GPIO_InitStruct.Pin = GPIO_PIN_APBE_PWR_EN;
200017e2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GPIO_PORT_APBE_PWR_EN, &GPIO_InitStruct);
200017e6:	a901      	add	r1, sp, #4
200017e8:	480e      	ldr	r0, [pc, #56]	; (20001824 <device_gpio_init+0x94>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GPIO_PORT_MUC_SPI_SEL, &GPIO_InitStruct);

  /* APBE power enable and reset */
  GPIO_InitStruct.Pin = GPIO_PIN_APBE_PWR_EN;
200017ea:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
200017ec:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
200017ee:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
200017f0:	9604      	str	r6, [sp, #16]
  HAL_GPIO_Init(GPIO_PORT_APBE_PWR_EN, &GPIO_InitStruct);
200017f2:	f002 f8bb 	bl	2000396c <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = GPIO_PIN_APBE_RST_N;
200017f6:	2302      	movs	r3, #2
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GPIO_PORT_APBE_RST_N, &GPIO_InitStruct);
200017f8:	a901      	add	r1, sp, #4
200017fa:	480b      	ldr	r0, [pc, #44]	; (20001828 <device_gpio_init+0x98>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GPIO_PORT_APBE_PWR_EN, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_APBE_RST_N;
200017fc:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
200017fe:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
20001800:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20001802:	9604      	str	r6, [sp, #16]
  HAL_GPIO_Init(GPIO_PORT_APBE_RST_N, &GPIO_InitStruct);
20001804:	f002 f8b2 	bl	2000396c <HAL_GPIO_Init>

  HAL_NVIC_SetPriority(EXTI_MODS_SL_BPLUS_AIN_IRQ, 1, 0);
20001808:	4629      	mov	r1, r5
2000180a:	4622      	mov	r2, r4
2000180c:	2007      	movs	r0, #7
2000180e:	f002 f843 	bl	20003898 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI_MODS_SL_BPLUS_AIN_IRQ);
20001812:	2007      	movs	r0, #7
20001814:	f002 f870 	bl	200038f8 <HAL_NVIC_EnableIRQ>
  HAL_GPIO_Init(GPIO_PORT_PCARD_DET_N, &GPIO_InitStruct);

  HAL_NVIC_SetPriority(EXTI_IRQ_PCARD_DET_N, 2, 0);
  HAL_NVIC_EnableIRQ(EXTI_IRQ_PCARD_DET_N);
#endif
}
20001818:	b007      	add	sp, #28
2000181a:	bdf0      	pop	{r4, r5, r6, r7, pc}
2000181c:	48000800 	.word	0x48000800
20001820:	10310000 	.word	0x10310000
20001824:	48001800 	.word	0x48001800
20001828:	48001c00 	.word	0x48001c00

2000182c <device_handle_exti>:
    HAL_NVIC_SystemReset();
}
#endif

void device_handle_exti(uint16_t GPIO_Pin)
{
2000182c:	4770      	bx	lr
	...

20001830 <device_spi_mod_init>:
void device_spi_mod_init(SPI_HandleTypeDef *_hspi)
{
  _hspi->Instance = MOD_TO_BASE_SPI;
  _hspi->Init.Mode = SPI_MODE_SLAVE;
  _hspi->Init.Direction = SPI_DIRECTION_2LINES;
  _hspi->Init.DataSize = SPI_DATASIZE_8BIT;
20001830:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  }
#endif
}

void device_spi_mod_init(SPI_HandleTypeDef *_hspi)
{
20001834:	b510      	push	{r4, lr}
  _hspi->Instance = MOD_TO_BASE_SPI;
  _hspi->Init.Mode = SPI_MODE_SLAVE;
  _hspi->Init.Direction = SPI_DIRECTION_2LINES;
  _hspi->Init.DataSize = SPI_DATASIZE_8BIT;
20001836:	60c2      	str	r2, [r0, #12]
  _hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
  _hspi->Init.CLKPhase = SPI_PHASE_1EDGE;
  _hspi->Init.NSS = SPI_NSS_HARD_INPUT;
  _hspi->Init.FirstBit = SPI_FIRSTBIT_MSB;
  _hspi->Init.TIMode = SPI_TIMODE_DISABLED;
  _hspi->Init.CRCCalculation = SPI_CRCCALCULATION_ENABLED;
20001838:	f44f 5200 	mov.w	r2, #8192	; 0x2000
#endif
}

void device_spi_mod_init(SPI_HandleTypeDef *_hspi)
{
  _hspi->Instance = MOD_TO_BASE_SPI;
2000183c:	4b0c      	ldr	r3, [pc, #48]	; (20001870 <device_spi_mod_init+0x40>)
  _hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
  _hspi->Init.CLKPhase = SPI_PHASE_1EDGE;
  _hspi->Init.NSS = SPI_NSS_HARD_INPUT;
  _hspi->Init.FirstBit = SPI_FIRSTBIT_MSB;
  _hspi->Init.TIMode = SPI_TIMODE_DISABLED;
  _hspi->Init.CRCCalculation = SPI_CRCCALCULATION_ENABLED;
2000183e:	6282      	str	r2, [r0, #40]	; 0x28
  _hspi->Init.CRCPolynomial = 0x8005;
20001840:	f248 0205 	movw	r2, #32773	; 0x8005
  }
#endif
}

void device_spi_mod_init(SPI_HandleTypeDef *_hspi)
{
20001844:	4604      	mov	r4, r0
  _hspi->Instance = MOD_TO_BASE_SPI;
20001846:	6003      	str	r3, [r0, #0]
  _hspi->Init.CLKPhase = SPI_PHASE_1EDGE;
  _hspi->Init.NSS = SPI_NSS_HARD_INPUT;
  _hspi->Init.FirstBit = SPI_FIRSTBIT_MSB;
  _hspi->Init.TIMode = SPI_TIMODE_DISABLED;
  _hspi->Init.CRCCalculation = SPI_CRCCALCULATION_ENABLED;
  _hspi->Init.CRCPolynomial = 0x8005;
20001848:	62c2      	str	r2, [r0, #44]	; 0x2c
}

void device_spi_mod_init(SPI_HandleTypeDef *_hspi)
{
  _hspi->Instance = MOD_TO_BASE_SPI;
  _hspi->Init.Mode = SPI_MODE_SLAVE;
2000184a:	2300      	movs	r3, #0
  _hspi->Init.NSS = SPI_NSS_HARD_INPUT;
  _hspi->Init.FirstBit = SPI_FIRSTBIT_MSB;
  _hspi->Init.TIMode = SPI_TIMODE_DISABLED;
  _hspi->Init.CRCCalculation = SPI_CRCCALCULATION_ENABLED;
  _hspi->Init.CRCPolynomial = 0x8005;
  _hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
2000184c:	2202      	movs	r2, #2
}

void device_spi_mod_init(SPI_HandleTypeDef *_hspi)
{
  _hspi->Instance = MOD_TO_BASE_SPI;
  _hspi->Init.Mode = SPI_MODE_SLAVE;
2000184e:	6043      	str	r3, [r0, #4]
  _hspi->Init.Direction = SPI_DIRECTION_2LINES;
20001850:	6083      	str	r3, [r0, #8]
  _hspi->Init.DataSize = SPI_DATASIZE_8BIT;
  _hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
20001852:	6103      	str	r3, [r0, #16]
  _hspi->Init.CLKPhase = SPI_PHASE_1EDGE;
20001854:	6143      	str	r3, [r0, #20]
  _hspi->Init.NSS = SPI_NSS_HARD_INPUT;
20001856:	6183      	str	r3, [r0, #24]
  _hspi->Init.FirstBit = SPI_FIRSTBIT_MSB;
20001858:	6203      	str	r3, [r0, #32]
  _hspi->Init.TIMode = SPI_TIMODE_DISABLED;
2000185a:	6243      	str	r3, [r0, #36]	; 0x24
  _hspi->Init.CRCCalculation = SPI_CRCCALCULATION_ENABLED;
  _hspi->Init.CRCPolynomial = 0x8005;
  _hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
2000185c:	6302      	str	r2, [r0, #48]	; 0x30
  _hspi->Init.NSSPMode = SPI_NSS_PULSE_DISABLED;
2000185e:	6343      	str	r3, [r0, #52]	; 0x34

  HAL_SPI_Init(_hspi);
20001860:	f002 fbae 	bl	20003fc0 <HAL_SPI_Init>

  /* Enable Software Slave Management to prevent spurious receives */
  _hspi->Instance->CR1 |= SPI_CR1_SSM | SPI_CR1_SSI;
20001864:	6822      	ldr	r2, [r4, #0]
20001866:	6813      	ldr	r3, [r2, #0]
20001868:	f443 7340 	orr.w	r3, r3, #768	; 0x300
2000186c:	6013      	str	r3, [r2, #0]
2000186e:	bd10      	pop	{r4, pc}
20001870:	40003800 	.word	0x40003800

20001874 <device_dma_init>:
}

void device_dma_init(void)
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
20001874:	4b0e      	ldr	r3, [pc, #56]	; (200018b0 <device_dma_init+0x3c>)
  /* Enable Software Slave Management to prevent spurious receives */
  _hspi->Instance->CR1 |= SPI_CR1_SSM | SPI_CR1_SSI;
}

void device_dma_init(void)
{
20001876:	b507      	push	{r0, r1, r2, lr}
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
20001878:	6c9a      	ldr	r2, [r3, #72]	; 0x48
2000187a:	f042 0201 	orr.w	r2, r2, #1
2000187e:	649a      	str	r2, [r3, #72]	; 0x48
20001880:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20001882:	f003 0301 	and.w	r3, r3, #1
20001886:	9301      	str	r3, [sp, #4]
  /* SPI1 DMA used for spi flash stage*/
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 1, 0);
20001888:	2101      	movs	r1, #1
2000188a:	2200      	movs	r2, #0
2000188c:	200c      	movs	r0, #12
}

void device_dma_init(void)
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
2000188e:	9b01      	ldr	r3, [sp, #4]
  /* SPI1 DMA used for spi flash stage*/
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 1, 0);
20001890:	f002 f802 	bl	20003898 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
20001894:	200c      	movs	r0, #12
20001896:	f002 f82f 	bl	200038f8 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 1, 0);
2000189a:	2101      	movs	r1, #1
2000189c:	2200      	movs	r2, #0
2000189e:	200d      	movs	r0, #13
200018a0:	f001 fffa 	bl	20003898 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
200018a4:	200d      	movs	r0, #13
200018a6:	f002 f827 	bl	200038f8 <HAL_NVIC_EnableIRQ>
}
200018aa:	b003      	add	sp, #12
200018ac:	f85d fb04 	ldr.w	pc, [sp], #4
200018b0:	40021000 	.word	0x40021000

200018b4 <mods_force_flash_get>:
PinState mods_force_flash_get(void)
{
#ifdef GPIO_PIN_FORCE_FLASH
  return HAL_GPIO_ReadPin(GPIO_PORT_FORCE_FLASH, GPIO_PIN_FORCE_FLASH);
#else
  return HAL_GPIO_ReadPin(GPIO_PORT_MUC_INT, GPIO_PIN_MUC_INT);
200018b4:	4802      	ldr	r0, [pc, #8]	; (200018c0 <mods_force_flash_get+0xc>)
200018b6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
200018ba:	f002 b9cb 	b.w	20003c54 <HAL_GPIO_ReadPin>
200018be:	bf00      	nop
200018c0:	48000800 	.word	0x48000800

200018c4 <mod_dev_base_spi_reset>:
#endif
}

void mod_dev_base_spi_reset(void)
{
  __HAL_RCC_SPI2_FORCE_RESET();
200018c4:	4b04      	ldr	r3, [pc, #16]	; (200018d8 <mod_dev_base_spi_reset+0x14>)
200018c6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
200018c8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
200018cc:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_SPI2_RELEASE_RESET();
200018ce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
200018d0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
200018d4:	639a      	str	r2, [r3, #56]	; 0x38
200018d6:	4770      	bx	lr
200018d8:	40021000 	.word	0x40021000

200018dc <mod_dev_is_attached>:
}

/* Is the mod currently attached to a base? */
bool mod_dev_is_attached(void)
{
200018dc:	b508      	push	{r3, lr}
    PinState ps_attached;

    ps_attached = HAL_GPIO_ReadPin(GPIO_MODS_SL_BPLUS_AIN_PORT,
200018de:	2120      	movs	r1, #32
200018e0:	4803      	ldr	r0, [pc, #12]	; (200018f0 <mod_dev_is_attached+0x14>)
200018e2:	f002 f9b7 	bl	20003c54 <HAL_GPIO_ReadPin>
                                   GPIO_MODS_SL_BPLUS_AIN_PIN);
    return (ps_attached == PIN_SET);
}
200018e6:	1e43      	subs	r3, r0, #1
200018e8:	4258      	negs	r0, r3
200018ea:	4158      	adcs	r0, r3
200018ec:	bd08      	pop	{r3, pc}
200018ee:	bf00      	nop
200018f0:	48000800 	.word	0x48000800

200018f4 <apbe_reset>:

/* Hold apbe in reset while spi flashing */
void apbe_reset()
{
200018f4:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(GPIO_PORT_APBE_PWR_EN, GPIO_PIN_APBE_PWR_EN, GPIO_PIN_SET);
200018f6:	4806      	ldr	r0, [pc, #24]	; (20001910 <apbe_reset+0x1c>)
200018f8:	f44f 4180 	mov.w	r1, #16384	; 0x4000
200018fc:	2201      	movs	r2, #1
200018fe:	f002 f9af 	bl	20003c60 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIO_PORT_APBE_RST_N, GPIO_PIN_APBE_RST_N, GPIO_PIN_RESET);
20001902:	4804      	ldr	r0, [pc, #16]	; (20001914 <apbe_reset+0x20>)
20001904:	2102      	movs	r1, #2
20001906:	2200      	movs	r2, #0
}
20001908:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

/* Hold apbe in reset while spi flashing */
void apbe_reset()
{
  HAL_GPIO_WritePin(GPIO_PORT_APBE_PWR_EN, GPIO_PIN_APBE_PWR_EN, GPIO_PIN_SET);
  HAL_GPIO_WritePin(GPIO_PORT_APBE_RST_N, GPIO_PIN_APBE_RST_N, GPIO_PIN_RESET);
2000190c:	f002 b9a8 	b.w	20003c60 <HAL_GPIO_WritePin>
20001910:	48001800 	.word	0x48001800
20001914:	48001c00 	.word	0x48001c00

20001918 <mods_muc_set_spi_sel>:
{
    return HAL_GPIO_ReadPin(GPIO_PORT_MUC_SPI_SEL, GPIO_PIN_MUC_SPI_SEL);
}

void mods_muc_set_spi_sel(PinState pstate)
{
20001918:	4602      	mov	r2, r0
     HAL_GPIO_WritePin(GPIO_PORT_MUC_SPI_SEL, GPIO_PIN_MUC_SPI_SEL, pstate);
2000191a:	2140      	movs	r1, #64	; 0x40
2000191c:	4801      	ldr	r0, [pc, #4]	; (20001924 <mods_muc_set_spi_sel+0xc>)
2000191e:	f002 b99f 	b.w	20003c60 <HAL_GPIO_WritePin>
20001922:	bf00      	nop
20001924:	48000800 	.word	0x48000800

20001928 <device_spi_flash_init>:
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 1, 0);
  HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
}

void device_spi_flash_init(SPI_HandleTypeDef *_hspi)
{
20001928:	b510      	push	{r4, lr}
2000192a:	4604      	mov	r4, r0
  apbe_reset();
2000192c:	f7ff ffe2 	bl	200018f4 <apbe_reset>

  /* Set spi sel gpio to enable muc to flash spi interface */
  mods_muc_set_spi_sel(PIN_SET);
20001930:	2001      	movs	r0, #1
20001932:	f7ff fff1 	bl	20001918 <mods_muc_set_spi_sel>

  _hspi->Instance = MOD_TO_SPI_FLASH;
  _hspi->Init.Mode = SPI_MODE_MASTER;
20001936:	4a0d      	ldr	r2, [pc, #52]	; (2000196c <device_spi_flash_init+0x44>)
20001938:	f44f 7382 	mov.w	r3, #260	; 0x104
2000193c:	e884 000c 	stmia.w	r4, {r2, r3}
  _hspi->Init.Direction = SPI_DIRECTION_2LINES;
  _hspi->Init.DataSize = SPI_DATASIZE_8BIT;
20001940:	f44f 62e0 	mov.w	r2, #1792	; 0x700
20001944:	60e2      	str	r2, [r4, #12]
  _hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
20001946:	2218      	movs	r2, #24
  /* Set spi sel gpio to enable muc to flash spi interface */
  mods_muc_set_spi_sel(PIN_SET);

  _hspi->Instance = MOD_TO_SPI_FLASH;
  _hspi->Init.Mode = SPI_MODE_MASTER;
  _hspi->Init.Direction = SPI_DIRECTION_2LINES;
20001948:	2300      	movs	r3, #0
  _hspi->Init.DataSize = SPI_DATASIZE_8BIT;
  _hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
2000194a:	61e2      	str	r2, [r4, #28]
  _hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
  _hspi->Init.CLKPhase = SPI_PHASE_1EDGE;
  _hspi->Init.NSS = SPI_NSS_HARD_OUTPUT;;
2000194c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  /* Set spi sel gpio to enable muc to flash spi interface */
  mods_muc_set_spi_sel(PIN_SET);

  _hspi->Instance = MOD_TO_SPI_FLASH;
  _hspi->Init.Mode = SPI_MODE_MASTER;
  _hspi->Init.Direction = SPI_DIRECTION_2LINES;
20001950:	60a3      	str	r3, [r4, #8]
  _hspi->Init.DataSize = SPI_DATASIZE_8BIT;
  _hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
  _hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
20001952:	6123      	str	r3, [r4, #16]
  _hspi->Init.CLKPhase = SPI_PHASE_1EDGE;
20001954:	6163      	str	r3, [r4, #20]
  _hspi->Init.NSS = SPI_NSS_HARD_OUTPUT;;
20001956:	61a2      	str	r2, [r4, #24]
  _hspi->Init.FirstBit = SPI_FIRSTBIT_MSB;
20001958:	6223      	str	r3, [r4, #32]
  _hspi->Init.TIMode = SPI_TIMODE_DISABLED;
2000195a:	6263      	str	r3, [r4, #36]	; 0x24
  _hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
2000195c:	62a3      	str	r3, [r4, #40]	; 0x28
  _hspi->Init.NSSPMode = SPI_NSS_PULSE_DISABLED;
2000195e:	6363      	str	r3, [r4, #52]	; 0x34

  HAL_SPI_Init(_hspi);
20001960:	4620      	mov	r0, r4
}
20001962:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  _hspi->Init.FirstBit = SPI_FIRSTBIT_MSB;
  _hspi->Init.TIMode = SPI_TIMODE_DISABLED;
  _hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  _hspi->Init.NSSPMode = SPI_NSS_PULSE_DISABLED;

  HAL_SPI_Init(_hspi);
20001966:	f002 bb2b 	b.w	20003fc0 <HAL_SPI_Init>
2000196a:	bf00      	nop
2000196c:	40013000 	.word	0x40013000

20001970 <mods_muc_set_spi1_cs>:
{
     HAL_GPIO_WritePin(GPIO_PORT_MUC_SPI_SEL, GPIO_PIN_MUC_SPI_SEL, pstate);
}

void mods_muc_set_spi1_cs(PinState pstate)
{
20001970:	4602      	mov	r2, r0
    HAL_GPIO_WritePin(GPIO_PORT_SPI1_CS_N, GPIO_PIN_SPI1_CS_N, pstate);
20001972:	2110      	movs	r1, #16
20001974:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
20001978:	f002 b972 	b.w	20003c60 <HAL_GPIO_WritePin>

2000197c <mods_rfr_set>:

#define STM32_UID_BASE       0x1fff7590     /* 0x1fff7590-0x1fff759b: UID */
#define getreg32(a)         (*(volatile uint32_t *)(a))

void mods_rfr_set(PinState pstate)
{
2000197c:	4602      	mov	r2, r0
    /* On this board, RFR is active high */
    HAL_GPIO_WritePin(GPIO_PORT_RFR, GPIO_PIN_RFR, pstate);
2000197e:	2104      	movs	r1, #4
20001980:	4801      	ldr	r0, [pc, #4]	; (20001988 <mods_rfr_set+0xc>)
20001982:	f002 b96d 	b.w	20003c60 <HAL_GPIO_WritePin>
20001986:	bf00      	nop
20001988:	48000800 	.word	0x48000800

2000198c <mods_rfr_get>:
}

PinState mods_rfr_get(void)
{
    /* On this board, RFR is active high */
    return HAL_GPIO_ReadPin(GPIO_PORT_RFR, GPIO_PIN_RFR);
2000198c:	4801      	ldr	r0, [pc, #4]	; (20001994 <mods_rfr_get+0x8>)
2000198e:	2104      	movs	r1, #4
20001990:	f002 b960 	b.w	20003c54 <HAL_GPIO_ReadPin>
20001994:	48000800 	.word	0x48000800

20001998 <mods_wake_n_get>:
}

PinState mods_wake_n_get(void)
{
    /* On this board, WAKE_N is active low */
    return HAL_GPIO_ReadPin(GPIO_PORT_WAKE_N, GPIO_PIN_WAKE_N);
20001998:	4801      	ldr	r0, [pc, #4]	; (200019a0 <mods_wake_n_get+0x8>)
2000199a:	2101      	movs	r1, #1
2000199c:	f002 b95a 	b.w	20003c54 <HAL_GPIO_ReadPin>
200019a0:	48000400 	.word	0x48000400

200019a4 <mods_muc_int_set>:
}

void mods_muc_int_set(PinState pstate)
{
200019a4:	4602      	mov	r2, r0
    /* On this board, MUC_INT is active high */
    HAL_GPIO_WritePin(GPIO_PORT_MUC_INT, GPIO_PIN_MUC_INT, pstate);
200019a6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
200019aa:	4801      	ldr	r0, [pc, #4]	; (200019b0 <mods_muc_int_set+0xc>)
200019ac:	f002 b958 	b.w	20003c60 <HAL_GPIO_WritePin>
200019b0:	48000800 	.word	0x48000800

200019b4 <mods_muc_int_get>:
}

PinState mods_muc_int_get(void)
{
    /* On this board, MUC_INT is active high */
    return HAL_GPIO_ReadPin(GPIO_PORT_MUC_INT, GPIO_PIN_MUC_INT);
200019b4:	4802      	ldr	r0, [pc, #8]	; (200019c0 <mods_muc_int_get+0xc>)
200019b6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
200019ba:	f002 b94b 	b.w	20003c54 <HAL_GPIO_ReadPin>
200019be:	bf00      	nop
200019c0:	48000800 	.word	0x48000800

200019c4 <mods_getms>:
/**
 * Get the time in milliseconds.
 */
uint32_t mods_getms(void)
{
    return HAL_GetTick();
200019c4:	f001 bf44 	b.w	20003850 <HAL_GetTick>

200019c8 <mods_ack_received>:
/**
 * Set the MISO line to reflect the ACK or NACK of the
 * message from the core.
 */
void mods_ack_received(bool rx_success)
{
200019c8:	b570      	push	{r4, r5, r6, lr}
200019ca:	b086      	sub	sp, #24

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
200019cc:	4d0a      	ldr	r5, [pc, #40]	; (200019f8 <mods_ack_received+0x30>)
{
    GPIO_InitTypeDef GPIO_InitStruct;
    PinState pstate = rx_success ? PIN_SET : PIN_RESET;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
200019ce:	2301      	movs	r3, #1
200019d0:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
200019d2:	2300      	movs	r3, #0
/**
 * Set the MISO line to reflect the ACK or NACK of the
 * message from the core.
 */
void mods_ack_received(bool rx_success)
{
200019d4:	4606      	mov	r6, r0
    GPIO_InitTypeDef GPIO_InitStruct;
    PinState pstate = rx_success ? PIN_SET : PIN_RESET;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN;
200019d6:	f44f 4480 	mov.w	r4, #16384	; 0x4000
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
200019da:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
200019dc:	4628      	mov	r0, r5
    PinState pstate = rx_success ? PIN_SET : PIN_RESET;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
200019de:	2303      	movs	r3, #3
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
200019e0:	a901      	add	r1, sp, #4
    PinState pstate = rx_success ? PIN_SET : PIN_RESET;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
200019e2:	9304      	str	r3, [sp, #16]
void mods_ack_received(bool rx_success)
{
    GPIO_InitTypeDef GPIO_InitStruct;
    PinState pstate = rx_success ? PIN_SET : PIN_RESET;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN;
200019e4:	9401      	str	r4, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
200019e6:	f001 ffc1 	bl	2000396c <HAL_GPIO_Init>

    HAL_GPIO_WritePin(GPIO_MODS_SPI_PORT, GPIO_MODS_SPI_MISO_PIN, pstate);
200019ea:	4628      	mov	r0, r5
200019ec:	4621      	mov	r1, r4
200019ee:	4632      	mov	r2, r6
200019f0:	f002 f936 	bl	20003c60 <HAL_GPIO_WritePin>
}
200019f4:	b006      	add	sp, #24
200019f6:	bd70      	pop	{r4, r5, r6, pc}
200019f8:	48000400 	.word	0x48000400

200019fc <mods_ack_transmitted_setup>:
/**
 * Set the MOSI line as a gpio input so we can
 * read the ack back from the base
 */
void mods_ack_transmitted_setup(void)
{
200019fc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    GPIO_InitTypeDef GPIO_InitStruct;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MOSI_PIN;
200019fe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
20001a02:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
20001a04:	2300      	movs	r3, #0
20001a06:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20001a08:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
20001a0a:	4804      	ldr	r0, [pc, #16]	; (20001a1c <mods_ack_transmitted_setup+0x20>)
    GPIO_InitTypeDef GPIO_InitStruct;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MOSI_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20001a0c:	2303      	movs	r3, #3
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
20001a0e:	a901      	add	r1, sp, #4
    GPIO_InitTypeDef GPIO_InitStruct;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MOSI_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20001a10:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
20001a12:	f001 ffab 	bl	2000396c <HAL_GPIO_Init>
}
20001a16:	b007      	add	sp, #28
20001a18:	f85d fb04 	ldr.w	pc, [sp], #4
20001a1c:	48000400 	.word	0x48000400

20001a20 <mods_ack_transmitted_get>:
/**
 * See if the transmitted value has been ACK'ed
 */
uint8_t mods_ack_transmitted_get(void)
{
    return HAL_GPIO_ReadPin(GPIO_MODS_SPI_PORT, GPIO_MODS_SPI_MOSI_PIN);
20001a20:	4802      	ldr	r0, [pc, #8]	; (20001a2c <mods_ack_transmitted_get+0xc>)
20001a22:	f44f 4100 	mov.w	r1, #32768	; 0x8000
20001a26:	f002 b915 	b.w	20003c54 <HAL_GPIO_ReadPin>
20001a2a:	bf00      	nop
20001a2c:	48000400 	.word	0x48000400

20001a30 <mods_spi_restore>:

/**
 * Undo the configuration of the MISO and MOSI lines as a gpios.
 */
void mods_spi_restore(void)
{
20001a30:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    GPIO_InitTypeDef GPIO_InitStruct;

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN | GPIO_MODS_SPI_MOSI_PIN;
20001a32:	f44f 4340 	mov.w	r3, #49152	; 0xc000
20001a36:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20001a38:	2302      	movs	r3, #2
20001a3a:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20001a3c:	2300      	movs	r3, #0
20001a3e:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20001a40:	2303      	movs	r3, #3
20001a42:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
20001a44:	4804      	ldr	r0, [pc, #16]	; (20001a58 <mods_spi_restore+0x28>)

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN | GPIO_MODS_SPI_MOSI_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
20001a46:	2305      	movs	r3, #5
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
20001a48:	a901      	add	r1, sp, #4

    GPIO_InitStruct.Pin = GPIO_MODS_SPI_MISO_PIN | GPIO_MODS_SPI_MOSI_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
20001a4a:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
20001a4c:	f001 ff8e 	bl	2000396c <HAL_GPIO_Init>
}
20001a50:	b007      	add	sp, #28
20001a52:	f85d fb04 	ldr.w	pc, [sp], #4
20001a56:	bf00      	nop
20001a58:	48000400 	.word	0x48000400

20001a5c <SPI_NSS_INT_CTRL_Config>:
#endif

void SPI_NSS_INT_CTRL_Config(void)
{
20001a5c:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Configure GPIO pin : MUC_INT */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
20001a5e:	2414      	movs	r4, #20
    HAL_GPIO_Init(GPIO_MODS_SPI_PORT, &GPIO_InitStruct);
}
#endif

void SPI_NSS_INT_CTRL_Config(void)
{
20001a60:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Configure GPIO pin : MUC_INT */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
20001a62:	4622      	mov	r2, r4
20001a64:	a801      	add	r0, sp, #4
20001a66:	2100      	movs	r1, #0
20001a68:	f7fe fbb6 	bl	200001d8 <memset>
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_INT;
20001a6c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20001a70:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
20001a72:	2301      	movs	r3, #1
20001a74:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GPIO_PORT_MUC_INT, &GPIO_InitStruct);
20001a76:	a901      	add	r1, sp, #4
  /* Configure GPIO pin : MUC_INT */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_INT;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20001a78:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIO_PORT_MUC_INT, &GPIO_InitStruct);
20001a7a:	480e      	ldr	r0, [pc, #56]	; (20001ab4 <SPI_NSS_INT_CTRL_Config+0x58>)
  /* Configure GPIO pin : MUC_INT */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_MUC_INT;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
20001a7c:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(GPIO_PORT_MUC_INT, &GPIO_InitStruct);
20001a7e:	f001 ff75 	bl	2000396c <HAL_GPIO_Init>

#ifdef CONFIG_DATALINK_SPI
  /*Configure GPIO pin : PB12 */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
20001a82:	4622      	mov	r2, r4
20001a84:	a801      	add	r0, sp, #4
20001a86:	2100      	movs	r1, #0
20001a88:	f7fe fba6 	bl	200001d8 <memset>
  GPIO_InitStruct.Pin = GPIO_PIN_SPI_CS_N;
20001a8c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
20001a90:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_SPI_CS_N, &GPIO_InitStruct);
20001a92:	a901      	add	r1, sp, #4

#ifdef CONFIG_DATALINK_SPI
  /*Configure GPIO pin : PB12 */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_SPI_CS_N;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
20001a94:	4b08      	ldr	r3, [pc, #32]	; (20001ab8 <SPI_NSS_INT_CTRL_Config+0x5c>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_SPI_CS_N, &GPIO_InitStruct);
20001a96:	4809      	ldr	r0, [pc, #36]	; (20001abc <SPI_NSS_INT_CTRL_Config+0x60>)

#ifdef CONFIG_DATALINK_SPI
  /*Configure GPIO pin : PB12 */
  memset(&GPIO_InitStruct, 0, sizeof(GPIO_InitStruct));
  GPIO_InitStruct.Pin = GPIO_PIN_SPI_CS_N;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
20001a98:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_PORT_SPI_CS_N, &GPIO_InitStruct);
20001a9a:	f001 ff67 	bl	2000396c <HAL_GPIO_Init>
#endif

  /* Enable and set EXTI line 12 Interrupt to the lowest priority */
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 0);
20001a9e:	2102      	movs	r1, #2
20001aa0:	2200      	movs	r2, #0
20001aa2:	2028      	movs	r0, #40	; 0x28
20001aa4:	f001 fef8 	bl	20003898 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
20001aa8:	2028      	movs	r0, #40	; 0x28
20001aaa:	f001 ff25 	bl	200038f8 <HAL_NVIC_EnableIRQ>
}
20001aae:	b006      	add	sp, #24
20001ab0:	bd10      	pop	{r4, pc}
20001ab2:	bf00      	nop
20001ab4:	48000800 	.word	0x48000800
20001ab8:	10210000 	.word	0x10210000
20001abc:	48000400 	.word	0x48000400

20001ac0 <dl_call_sent_cb>:
    g_spi_data.sent_ctx = ctx;
}

static inline void dl_call_sent_cb(int status)
{
    msg_sent_cb cb = g_spi_data.sent_cb;
20001ac0:	4b05      	ldr	r3, [pc, #20]	; (20001ad8 <dl_call_sent_cb+0x18>)
20001ac2:	685a      	ldr	r2, [r3, #4]
    void *ctx = g_spi_data.sent_ctx;
20001ac4:	6899      	ldr	r1, [r3, #8]
    g_spi_data.sent_cb  = cb;
    g_spi_data.sent_ctx = ctx;
}

static inline void dl_call_sent_cb(int status)
{
20001ac6:	b510      	push	{r4, lr}
    return g_spi_data.sent_cb;
}

static inline void dl_set_sent_cb(msg_sent_cb cb, void *ctx)
{
    g_spi_data.sent_cb  = cb;
20001ac8:	2400      	movs	r4, #0
20001aca:	605c      	str	r4, [r3, #4]
    g_spi_data.sent_ctx = ctx;
20001acc:	609c      	str	r4, [r3, #8]
{
    msg_sent_cb cb = g_spi_data.sent_cb;
    void *ctx = g_spi_data.sent_ctx;

    dl_set_sent_cb(NULL, NULL);
    if (cb)
20001ace:	b112      	cbz	r2, 20001ad6 <dl_call_sent_cb+0x16>
        cb(status, ctx);
}
20001ad0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    msg_sent_cb cb = g_spi_data.sent_cb;
    void *ctx = g_spi_data.sent_ctx;

    dl_set_sent_cb(NULL, NULL);
    if (cb)
        cb(status, ctx);
20001ad4:	4710      	bx	r2
20001ad6:	bd10      	pop	{r4, pc}
20001ad8:	200069d8 	.word	0x200069d8

20001adc <dl_bus_config_cb>:

#ifdef CONFIG_DEBUG_DATALINK
    dbgprintx32("dl_bus_config_cb(0x", status, ",");
    dbgprintx32(" 0x", pl_size, ")\r\n");
#endif
    g_spi_data.payload_size = pl_size;
20001adc:	4b01      	ldr	r3, [pc, #4]	; (20001ae4 <dl_bus_config_cb+0x8>)
20001ade:	8059      	strh	r1, [r3, #2]
20001ae0:	4770      	bx	lr
20001ae2:	bf00      	nop
20001ae4:	200069d8 	.word	0x200069d8

20001ae8 <dump>:

static void dump(void)
{
  uint32_t buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;

  dbgprintx32("DR:     0x", gb_hspi.Instance->DR, "\r\n");
20001ae8:	4b15      	ldr	r3, [pc, #84]	; (20001b40 <dump+0x58>)
20001aea:	4816      	ldr	r0, [pc, #88]	; (20001b44 <dump+0x5c>)
20001aec:	681b      	ldr	r3, [r3, #0]

    return rc;
}

static void dump(void)
{
20001aee:	b570      	push	{r4, r5, r6, lr}
  uint32_t buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;

  dbgprintx32("DR:     0x", gb_hspi.Instance->DR, "\r\n");
20001af0:	4c15      	ldr	r4, [pc, #84]	; (20001b48 <dump+0x60>)
    return rc;
}

static void dump(void)
{
  uint32_t buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;
20001af2:	4d16      	ldr	r5, [pc, #88]	; (20001b4c <dump+0x64>)

  dbgprintx32("DR:     0x", gb_hspi.Instance->DR, "\r\n");
20001af4:	68d9      	ldr	r1, [r3, #12]
    return rc;
}

static void dump(void)
{
  uint32_t buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;
20001af6:	886e      	ldrh	r6, [r5, #2]

  dbgprintx32("DR:     0x", gb_hspi.Instance->DR, "\r\n");
20001af8:	4622      	mov	r2, r4
20001afa:	f003 fb04 	bl	20005106 <dbgprintx32>
  dbgprintx32("INT:      ", mods_muc_int_get(), "\r\n");
20001afe:	f7ff ff59 	bl	200019b4 <mods_muc_int_get>
20001b02:	4622      	mov	r2, r4
20001b04:	4601      	mov	r1, r0
20001b06:	4812      	ldr	r0, [pc, #72]	; (20001b50 <dump+0x68>)
20001b08:	f003 fafd 	bl	20005106 <dbgprintx32>
  dbgprintx32("RFR:      ", mods_rfr_get(), "\r\n");
20001b0c:	f7ff ff3e 	bl	2000198c <mods_rfr_get>
    return rc;
}

static void dump(void)
{
  uint32_t buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;
20001b10:	3602      	adds	r6, #2

  dbgprintx32("DR:     0x", gb_hspi.Instance->DR, "\r\n");
  dbgprintx32("INT:      ", mods_muc_int_get(), "\r\n");
  dbgprintx32("RFR:      ", mods_rfr_get(), "\r\n");
20001b12:	4601      	mov	r1, r0
20001b14:	4622      	mov	r2, r4
20001b16:	480f      	ldr	r0, [pc, #60]	; (20001b54 <dump+0x6c>)
20001b18:	f003 faf5 	bl	20005106 <dbgprintx32>
  dbgprintx32("buf_sz  0x", buf_size, "\r\n");
20001b1c:	4631      	mov	r1, r6
20001b1e:	4622      	mov	r2, r4
20001b20:	480d      	ldr	r0, [pc, #52]	; (20001b58 <dump+0x70>)
20001b22:	f003 faf0 	bl	20005106 <dbgprintx32>
  dbgprintx32("respReady ", g_spi_data.respReady, "\r\n");
20001b26:	7b29      	ldrb	r1, [r5, #12]
20001b28:	480c      	ldr	r0, [pc, #48]	; (20001b5c <dump+0x74>)
20001b2a:	4622      	mov	r2, r4
20001b2c:	f003 faeb 	bl	20005106 <dbgprintx32>
  dbgprintx32("armDMA    ", g_spi_data.armDMA, "\r\n");
20001b30:	7829      	ldrb	r1, [r5, #0]
20001b32:	480b      	ldr	r0, [pc, #44]	; (20001b60 <dump+0x78>)
20001b34:	4622      	mov	r2, r4
}
20001b36:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  dbgprintx32("DR:     0x", gb_hspi.Instance->DR, "\r\n");
  dbgprintx32("INT:      ", mods_muc_int_get(), "\r\n");
  dbgprintx32("RFR:      ", mods_rfr_get(), "\r\n");
  dbgprintx32("buf_sz  0x", buf_size, "\r\n");
  dbgprintx32("respReady ", g_spi_data.respReady, "\r\n");
  dbgprintx32("armDMA    ", g_spi_data.armDMA, "\r\n");
20001b3a:	f003 bae4 	b.w	20005106 <dbgprintx32>
20001b3e:	bf00      	nop
20001b40:	20006974 	.word	0x20006974
20001b44:	20006431 	.word	0x20006431
20001b48:	20005e34 	.word	0x20005e34
20001b4c:	200069d8 	.word	0x200069d8
20001b50:	2000643c 	.word	0x2000643c
20001b54:	20006447 	.word	0x20006447
20001b58:	20006452 	.word	0x20006452
20001b5c:	2000645d 	.word	0x2000645d
20001b60:	20006468 	.word	0x20006468

20001b64 <ack_handler.part.0>:
/*
 * returns: true if the messages were acknowledged successfully
 *          (or the caller should behave as if they were) and
 *          can delete the message.
 */
static bool ack_handler(bool tx_attempted, enum ack ack_req)
20001b64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20001b66:	460d      	mov	r5, r1
20001b68:	4606      	mov	r6, r0
#endif

    if (!g_spi_data.ack_supported)
        return true;

    start = mods_getms();
20001b6a:	f7ff ff2b 	bl	200019c4 <mods_getms>
20001b6e:	4604      	mov	r4, r0
#ifdef CONFIG_DEBUG_DATALINK
    dbgprintx32("start 0x", start, "\r\n");
#endif

    /* Send ACK to base (if requested) */
    mods_ack_received((ack_req == ACK_NEEDED) ? 1 : 0);
20001b70:	fab5 f085 	clz	r0, r5
20001b74:	0940      	lsrs	r0, r0, #5
20001b76:	f7ff ff27 	bl	200019c8 <mods_ack_received>

    /* We transmitted something so look for ACK from base */
    mods_ack_transmitted_setup();
20001b7a:	f7ff ff3f 	bl	200019fc <mods_ack_transmitted_setup>
    if (tx_attempted) {
20001b7e:	b19e      	cbz	r6, 20001ba8 <ack_handler.part.0+0x44>
        do {
            ack = mods_ack_transmitted_get();
20001b80:	f7ff ff4e 	bl	20001a20 <mods_ack_transmitted_get>
20001b84:	4607      	mov	r7, r0
            wake_n = mods_wake_n_get();
20001b86:	f7ff ff07 	bl	20001998 <mods_wake_n_get>
20001b8a:	4606      	mov	r6, r0
            timeout = ((mods_getms() - start) >= DL_ACK_TIMEOUT_MS);
20001b8c:	f7ff ff1a 	bl	200019c4 <mods_getms>
20001b90:	1b00      	subs	r0, r0, r4
        } while (!ack && wake_n && !timeout);
20001b92:	b91f      	cbnz	r7, 20001b9c <ack_handler.part.0+0x38>
20001b94:	b116      	cbz	r6, 20001b9c <ack_handler.part.0+0x38>
20001b96:	2863      	cmp	r0, #99	; 0x63
20001b98:	d9f2      	bls.n	20001b80 <ack_handler.part.0+0x1c>
20001b9a:	e014      	b.n	20001bc6 <ack_handler.part.0+0x62>
                dbgprint("Abort: No ACK received\r\n");
#endif
                g_spi_data.tx_remaining = DL_NUM_TRIES;
                return true;
            }
        } else if (g_spi_data.tx_remaining != DL_NUM_TRIES) {
20001b9c:	4b15      	ldr	r3, [pc, #84]	; (20001bf4 <ack_handler.part.0+0x90>)
20001b9e:	691a      	ldr	r2, [r3, #16]
20001ba0:	2a03      	cmp	r2, #3
#ifdef CONFIG_DEBUG_DATALINK
            dbgprint("Retry successful\r\n");
#endif
            g_spi_data.tx_remaining = DL_NUM_TRIES;
20001ba2:	bf1c      	itt	ne
20001ba4:	2203      	movne	r2, #3
20001ba6:	611a      	strne	r2, [r3, #16]
        }
    }

    if (ack_req == ACK_ERROR) {
20001ba8:	2d02      	cmp	r5, #2
20001baa:	d003      	beq.n	20001bb4 <ack_handler.part.0+0x50>
         * so it is okay to return true.
         */
        return true;
    }
#endif
    return true;
20001bac:	2001      	movs	r0, #1
20001bae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (ack_req == ACK_ERROR) {
        /* Must block long enough to ensure base does not see false ACK. */
        do {
            wake_n = mods_wake_n_get();
            timeout = ((mods_getms() - start) >= (2 * DL_ACK_TIMEOUT_MS));
        } while (wake_n && !timeout);
20001bb0:	28c7      	cmp	r0, #199	; 0xc7
20001bb2:	d8fb      	bhi.n	20001bac <ack_handler.part.0+0x48>
    }

    if (ack_req == ACK_ERROR) {
        /* Must block long enough to ensure base does not see false ACK. */
        do {
            wake_n = mods_wake_n_get();
20001bb4:	f7ff fef0 	bl	20001998 <mods_wake_n_get>
20001bb8:	4605      	mov	r5, r0
            timeout = ((mods_getms() - start) >= (2 * DL_ACK_TIMEOUT_MS));
20001bba:	f7ff ff03 	bl	200019c4 <mods_getms>
20001bbe:	1b00      	subs	r0, r0, r4
        } while (wake_n && !timeout);
20001bc0:	2d00      	cmp	r5, #0
20001bc2:	d1f5      	bne.n	20001bb0 <ack_handler.part.0+0x4c>
20001bc4:	e7f2      	b.n	20001bac <ack_handler.part.0+0x48>
        if (!ack && wake_n) {
           /*
            * Since both TX and RX (potentially) failed, need
            * to spin longer to ensure base does not see false ACK.
            */
            if (ack_req == ACK_ERROR) {
20001bc6:	2d02      	cmp	r5, #2
20001bc8:	d106      	bne.n	20001bd8 <ack_handler.part.0+0x74>
                do {
                    wake_n = mods_wake_n_get();
20001bca:	f7ff fee5 	bl	20001998 <mods_wake_n_get>
20001bce:	4605      	mov	r5, r0
                    timeout = (mods_getms() - start) >= (2 * DL_ACK_TIMEOUT_MS);
20001bd0:	f7ff fef8 	bl	200019c4 <mods_getms>
20001bd4:	1b00      	subs	r0, r0, r4
                } while (wake_n && !timeout);
20001bd6:	b93d      	cbnz	r5, 20001be8 <ack_handler.part.0+0x84>
            }

            if (--g_spi_data.tx_remaining > 0) {
20001bd8:	4a06      	ldr	r2, [pc, #24]	; (20001bf4 <ack_handler.part.0+0x90>)
20001bda:	6913      	ldr	r3, [r2, #16]
20001bdc:	3b01      	subs	r3, #1
20001bde:	2b00      	cmp	r3, #0
20001be0:	dd05      	ble.n	20001bee <ack_handler.part.0+0x8a>
20001be2:	6113      	str	r3, [r2, #16]
#ifdef CONFIG_DEBUG_DATALINK
                dbgprint("Retry: No ACK received\r\n");
#endif
                return false;
20001be4:	2000      	movs	r0, #0
20001be6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            */
            if (ack_req == ACK_ERROR) {
                do {
                    wake_n = mods_wake_n_get();
                    timeout = (mods_getms() - start) >= (2 * DL_ACK_TIMEOUT_MS);
                } while (wake_n && !timeout);
20001be8:	28c7      	cmp	r0, #199	; 0xc7
20001bea:	d9ee      	bls.n	20001bca <ack_handler.part.0+0x66>
20001bec:	e7f4      	b.n	20001bd8 <ack_handler.part.0+0x74>
                return false;
            } else {
#ifdef CONFIG_DEBUG_DATALINK
                dbgprint("Abort: No ACK received\r\n");
#endif
                g_spi_data.tx_remaining = DL_NUM_TRIES;
20001bee:	2303      	movs	r3, #3
20001bf0:	6113      	str	r3, [r2, #16]
20001bf2:	e7db      	b.n	20001bac <ack_handler.part.0+0x48>
20001bf4:	200069d8 	.word	0x200069d8

20001bf8 <Error_Handler>:
    memset(aRxBuffer, 0, MAX_DMA_BUF_SIZE);
    return 0;
}

static void Error_Handler(SPI_HandleTypeDef *_hspi)
{
20001bf8:	b570      	push	{r4, r5, r6, lr}
20001bfa:	4605      	mov	r5, r0
  bool tx_retry = false;

  mods_rfr_set(PIN_RESET);
20001bfc:	2000      	movs	r0, #0
20001bfe:	f7ff febd 	bl	2000197c <mods_rfr_set>
  mods_muc_int_set(PIN_RESET);
20001c02:	2000      	movs	r0, #0
20001c04:	f7ff fece 	bl	200019a4 <mods_muc_int_set>
  _hspi->Instance->CR1 |= (SPI_CR1_SSM | SPI_CR1_SSI);
20001c08:	682a      	ldr	r2, [r5, #0]
20001c0a:	6813      	ldr	r3, [r2, #0]
20001c0c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
20001c10:	6013      	str	r3, [r2, #0]

  tx_retry = !ack_handler(g_spi_data.respReady, ACK_ERROR);
20001c12:	4b19      	ldr	r3, [pc, #100]	; (20001c78 <Error_Handler+0x80>)
#ifdef CONFIG_DEBUG_DATALINK
    uint32_t dbg_tx_rx = tx_attempted << 16 | (uint16_t)ack_req;
    dbgprintx32("ack_handler 0x", dbg_tx_rx, "\r\n");
#endif

    if (!g_spi_data.ack_supported)
20001c14:	7b5a      	ldrb	r2, [r3, #13]

  mods_rfr_set(PIN_RESET);
  mods_muc_int_set(PIN_RESET);
  _hspi->Instance->CR1 |= (SPI_CR1_SSM | SPI_CR1_SSI);

  tx_retry = !ack_handler(g_spi_data.respReady, ACK_ERROR);
20001c16:	7b18      	ldrb	r0, [r3, #12]
20001c18:	461e      	mov	r6, r3
#ifdef CONFIG_DEBUG_DATALINK
    uint32_t dbg_tx_rx = tx_attempted << 16 | (uint16_t)ack_req;
    dbgprintx32("ack_handler 0x", dbg_tx_rx, "\r\n");
#endif

    if (!g_spi_data.ack_supported)
20001c1a:	b11a      	cbz	r2, 20001c24 <Error_Handler+0x2c>
20001c1c:	2102      	movs	r1, #2
20001c1e:	f7ff ffa1 	bl	20001b64 <ack_handler.part.0>
20001c22:	e000      	b.n	20001c26 <Error_Handler+0x2e>
        return true;
20001c24:	2001      	movs	r0, #1

  mods_rfr_set(PIN_RESET);
  mods_muc_int_set(PIN_RESET);
  _hspi->Instance->CR1 |= (SPI_CR1_SSM | SPI_CR1_SSI);

  tx_retry = !ack_handler(g_spi_data.respReady, ACK_ERROR);
20001c26:	f080 0401 	eor.w	r4, r0, #1
  if (!tx_retry)
20001c2a:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    g_spi_data.respReady = false;
  dbgprintx32("SPIERR : 0x", _hspi->ErrorCode, "\r\n");
20001c2e:	6e29      	ldr	r1, [r5, #96]	; 0x60
20001c30:	4a12      	ldr	r2, [pc, #72]	; (20001c7c <Error_Handler+0x84>)
20001c32:	4813      	ldr	r0, [pc, #76]	; (20001c80 <Error_Handler+0x88>)
  mods_muc_int_set(PIN_RESET);
  _hspi->Instance->CR1 |= (SPI_CR1_SSM | SPI_CR1_SSI);

  tx_retry = !ack_handler(g_spi_data.respReady, ACK_ERROR);
  if (!tx_retry)
    g_spi_data.respReady = false;
20001c34:	bf08      	it	eq
20001c36:	7334      	strbeq	r4, [r6, #12]
  dbgprintx32("SPIERR : 0x", _hspi->ErrorCode, "\r\n");
20001c38:	f003 fa65 	bl	20005106 <dbgprintx32>
  dump();
20001c3c:	f7ff ff54 	bl	20001ae8 <dump>
  HAL_SPI_DeInit(_hspi);
20001c40:	4628      	mov	r0, r5
20001c42:	f002 fa14 	bl	2000406e <HAL_SPI_DeInit>
  mod_dev_base_spi_reset();
20001c46:	f7ff fe3d 	bl	200018c4 <mod_dev_base_spi_reset>
  device_spi_mod_init(_hspi);
20001c4a:	4628      	mov	r0, r5
20001c4c:	f7ff fdf0 	bl	20001830 <device_spi_mod_init>
  if (!tx_retry)
20001c50:	b94c      	cbnz	r4, 20001c66 <Error_Handler+0x6e>
    hdr->bits = bits;
}

static inline void dl_setup_for_dummy_tx(void)
{
    memset(aTxBuffer, 0, MAX_DMA_BUF_SIZE);
20001c52:	4d0c      	ldr	r5, [pc, #48]	; (20001c84 <Error_Handler+0x8c>)
20001c54:	4621      	mov	r1, r4
20001c56:	4628      	mov	r0, r5
20001c58:	f640 0202 	movw	r2, #2050	; 0x802
20001c5c:	f7fe fabc 	bl	200001d8 <memset>

static inline void dl_set_txp_hdr(uint8_t *buf, uint16_t bits)
{
    struct spi_msg_hdr *hdr = (struct spi_msg_hdr *)buf;

    hdr->bits = bits;
20001c60:	2302      	movs	r3, #2
20001c62:	702c      	strb	r4, [r5, #0]
20001c64:	706b      	strb	r3, [r5, #1]
  HAL_SPI_DeInit(_hspi);
  mod_dev_base_spi_reset();
  device_spi_mod_init(_hspi);
  if (!tx_retry)
    dl_setup_for_dummy_tx();
  memset(aRxBuffer, 0, MAX_DMA_BUF_SIZE);
20001c66:	4808      	ldr	r0, [pc, #32]	; (20001c88 <Error_Handler+0x90>)
20001c68:	2100      	movs	r1, #0
20001c6a:	f640 0202 	movw	r2, #2050	; 0x802
20001c6e:	f7fe fab3 	bl	200001d8 <memset>
  g_spi_data.armDMA = true;
20001c72:	2301      	movs	r3, #1
20001c74:	7033      	strb	r3, [r6, #0]
20001c76:	bd70      	pop	{r4, r5, r6, pc}
20001c78:	200069d8 	.word	0x200069d8
20001c7c:	20005e34 	.word	0x20005e34
20001c80:	20006473 	.word	0x20006473
20001c84:	200072e2 	.word	0x200072e2
20001c88:	20006ae0 	.word	0x20006ae0

20001c8c <greybus_get_operation_header>:

/* TODO: migrate to gbcore.c */
struct gb_operation_hdr *greybus_get_operation_header(void)
{
    return (struct gb_operation_hdr *)&aTxBuffer[DL_HEADER_BITS_SIZE + NW_HEADER_SIZE];
}
20001c8c:	4800      	ldr	r0, [pc, #0]	; (20001c90 <greybus_get_operation_header+0x4>)
20001c8e:	4770      	bx	lr
20001c90:	200072e6 	.word	0x200072e6

20001c94 <datalink_get_max_payload_size>:
}

uint16_t datalink_get_max_payload_size(void)
{
     return g_spi_data.payload_size;
}
20001c94:	4b01      	ldr	r3, [pc, #4]	; (20001c9c <datalink_get_max_payload_size+0x8>)
20001c96:	8858      	ldrh	r0, [r3, #2]
20001c98:	4770      	bx	lr
20001c9a:	bf00      	nop
20001c9c:	200069d8 	.word	0x200069d8

20001ca0 <dl_init>:
    if (cb)
        cb(status, ctx);
}

void dl_init(void)
{
20001ca0:	b508      	push	{r3, lr}
#ifdef CONFIG_DEBUG_DATALINK
    dbgprint("dl_init\r\n");
#endif
    device_spi_mod_init(&gb_hspi);
20001ca2:	480b      	ldr	r0, [pc, #44]	; (20001cd0 <dl_init+0x30>)
20001ca4:	f7ff fdc4 	bl	20001830 <device_spi_mod_init>
    mods_rfr_set(PIN_RESET);
20001ca8:	2000      	movs	r0, #0
20001caa:	f7ff fe67 	bl	2000197c <mods_rfr_set>
    mods_muc_int_set(PIN_RESET);
20001cae:	2000      	movs	r0, #0
20001cb0:	f7ff fe78 	bl	200019a4 <mods_muc_int_set>
    g_spi_data.respReady = false;
20001cb4:	4b07      	ldr	r3, [pc, #28]	; (20001cd4 <dl_init+0x34>)
    g_spi_data.armDMA = true;
20001cb6:	2101      	movs	r1, #1
    dbgprint("dl_init\r\n");
#endif
    device_spi_mod_init(&gb_hspi);
    mods_rfr_set(PIN_RESET);
    mods_muc_int_set(PIN_RESET);
    g_spi_data.respReady = false;
20001cb8:	2200      	movs	r2, #0
    g_spi_data.armDMA = true;
20001cba:	7019      	strb	r1, [r3, #0]
    g_spi_data.ack_supported = false;
    g_spi_data.tx_remaining = DL_NUM_TRIES;
20001cbc:	2103      	movs	r1, #3
20001cbe:	6119      	str	r1, [r3, #16]
    dl_set_sent_cb(NULL, NULL);
    g_spi_data.payload_size = INITIAL_DMA_BUF_SIZE;
    g_spi_data.proto_ver = 0;
20001cc0:	751a      	strb	r2, [r3, #20]
    g_spi_data.respReady = false;
    g_spi_data.armDMA = true;
    g_spi_data.ack_supported = false;
    g_spi_data.tx_remaining = DL_NUM_TRIES;
    dl_set_sent_cb(NULL, NULL);
    g_spi_data.payload_size = INITIAL_DMA_BUF_SIZE;
20001cc2:	2120      	movs	r1, #32
    dbgprint("dl_init\r\n");
#endif
    device_spi_mod_init(&gb_hspi);
    mods_rfr_set(PIN_RESET);
    mods_muc_int_set(PIN_RESET);
    g_spi_data.respReady = false;
20001cc4:	731a      	strb	r2, [r3, #12]
    g_spi_data.armDMA = true;
    g_spi_data.ack_supported = false;
20001cc6:	735a      	strb	r2, [r3, #13]
    return g_spi_data.sent_cb;
}

static inline void dl_set_sent_cb(msg_sent_cb cb, void *ctx)
{
    g_spi_data.sent_cb  = cb;
20001cc8:	605a      	str	r2, [r3, #4]
    g_spi_data.sent_ctx = ctx;
20001cca:	609a      	str	r2, [r3, #8]
    g_spi_data.respReady = false;
    g_spi_data.armDMA = true;
    g_spi_data.ack_supported = false;
    g_spi_data.tx_remaining = DL_NUM_TRIES;
    dl_set_sent_cb(NULL, NULL);
    g_spi_data.payload_size = INITIAL_DMA_BUF_SIZE;
20001ccc:	8059      	strh	r1, [r3, #2]
    g_spi_data.proto_ver = 0;
20001cce:	bd08      	pop	{r3, pc}
20001cd0:	20006974 	.word	0x20006974
20001cd4:	200069d8 	.word	0x200069d8

20001cd8 <dl_exit>:
}

void dl_exit(void)
{
20001cd8:	b508      	push	{r3, lr}
#ifdef CONFIG_DEBUG_DATALINK
    dbgprint("dl_exit\r\n");
#endif
    mods_rfr_set(PIN_RESET);
20001cda:	2000      	movs	r0, #0
20001cdc:	f7ff fe4e 	bl	2000197c <mods_rfr_set>
    mods_muc_int_set(PIN_RESET);
20001ce0:	2000      	movs	r0, #0
20001ce2:	f7ff fe5f 	bl	200019a4 <mods_muc_int_set>
    HAL_SPI_DMAStop(&gb_hspi);
20001ce6:	4803      	ldr	r0, [pc, #12]	; (20001cf4 <dl_exit+0x1c>)
20001ce8:	f002 f9e2 	bl	200040b0 <HAL_SPI_DMAStop>
    mod_dev_base_spi_reset();
}
20001cec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    dbgprint("dl_exit\r\n");
#endif
    mods_rfr_set(PIN_RESET);
    mods_muc_int_set(PIN_RESET);
    HAL_SPI_DMAStop(&gb_hspi);
    mod_dev_base_spi_reset();
20001cf0:	f7ff bde8 	b.w	200018c4 <mod_dev_base_spi_reset>
20001cf4:	20006974 	.word	0x20006974

20001cf8 <datalink_send>:
}

/* called from network layer */
/* buf should point to the start of a network message */
int datalink_send(uint8_t *buf, size_t len, msg_sent_cb cb, void *ctx)
{
20001cf8:	b510      	push	{r4, lr}

static inline void dl_set_txp_hdr(uint8_t *buf, uint16_t bits)
{
    struct spi_msg_hdr *hdr = (struct spi_msg_hdr *)buf;

    hdr->bits = bits;
20001cfa:	f06f 013f 	mvn.w	r1, #63	; 0x3f
20001cfe:	f800 1c02 	strb.w	r1, [r0, #-2]
/* buf should point to the start of a network message */
int datalink_send(uint8_t *buf, size_t len, msg_sent_cb cb, void *ctx)
{
    dl_set_txp_hdr(&buf[-sizeof(struct spi_msg_hdr)],
        HDR_BIT_PKT1 | MSG_TYPE_NW | HDR_BIT_VALID);
    g_spi_data.respReady = true;
20001d02:	4904      	ldr	r1, [pc, #16]	; (20001d14 <datalink_send+0x1c>)

static inline void dl_set_txp_hdr(uint8_t *buf, uint16_t bits)
{
    struct spi_msg_hdr *hdr = (struct spi_msg_hdr *)buf;

    hdr->bits = bits;
20001d04:	2401      	movs	r4, #1
20001d06:	f800 4c01 	strb.w	r4, [r0, #-1]
/* buf should point to the start of a network message */
int datalink_send(uint8_t *buf, size_t len, msg_sent_cb cb, void *ctx)
{
    dl_set_txp_hdr(&buf[-sizeof(struct spi_msg_hdr)],
        HDR_BIT_PKT1 | MSG_TYPE_NW | HDR_BIT_VALID);
    g_spi_data.respReady = true;
20001d0a:	730c      	strb	r4, [r1, #12]
    return g_spi_data.sent_cb;
}

static inline void dl_set_sent_cb(msg_sent_cb cb, void *ctx)
{
    g_spi_data.sent_cb  = cb;
20001d0c:	604a      	str	r2, [r1, #4]
    g_spi_data.sent_ctx = ctx;
20001d0e:	608b      	str	r3, [r1, #8]
        HDR_BIT_PKT1 | MSG_TYPE_NW | HDR_BIT_VALID);
    g_spi_data.respReady = true;
    dl_set_sent_cb(cb, ctx);

    return 0;
}
20001d10:	2000      	movs	r0, #0
20001d12:	bd10      	pop	{r4, pc}
20001d14:	200069d8 	.word	0x200069d8

20001d18 <dl_muc_handler>:
 * @brief handle message at datalink layer
 * @param msg - datalink message
 * @returns 0 on success
 */
int dl_muc_handler(void *msg)
{
20001d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int rc = 0;

#ifdef CONFIG_DEBUG_DATALINK
    dbgprint("dl_muc_handler\r\n");
#endif
    if (dl_msg->mesg_id & GB_TYPE_RESPONSE) {
20001d1a:	7803      	ldrb	r3, [r0, #0]
20001d1c:	061a      	lsls	r2, r3, #24
 * @brief handle message at datalink layer
 * @param msg - datalink message
 * @returns 0 on success
 */
int dl_muc_handler(void *msg)
{
20001d1e:	4607      	mov	r7, r0
    int rc = 0;

#ifdef CONFIG_DEBUG_DATALINK
    dbgprint("dl_muc_handler\r\n");
#endif
    if (dl_msg->mesg_id & GB_TYPE_RESPONSE) {
20001d20:	d43a      	bmi.n	20001d98 <dl_muc_handler+0x80>
        return GB_OP_PROTOCOL_BAD;
    }

    switch (dl_msg->mesg_id) {
20001d22:	2b00      	cmp	r3, #0
20001d24:	d133      	bne.n	20001d8e <dl_muc_handler+0x76>
        MAX_NW_PL_SIZE
    };

    g_spi_data.proto_ver = req->version;

    resp.version = PROTO_VER;
20001d26:	4c1d      	ldr	r4, [pc, #116]	; (20001d9c <dl_muc_handler+0x84>)
    static struct dl_muc_bus_config_resp resp = {
        15000000,
        MAX_NW_PL_SIZE
    };

    g_spi_data.proto_ver = req->version;
20001d28:	7902      	ldrb	r2, [r0, #4]

    resp.version = PROTO_VER;
    resp.features = 0;
20001d2a:	71a3      	strb	r3, [r4, #6]
        MAX_NW_PL_SIZE
    };

    g_spi_data.proto_ver = req->version;

    resp.version = PROTO_VER;
20001d2c:	2102      	movs	r1, #2
20001d2e:	71e1      	strb	r1, [r4, #7]
    resp.features = 0;

#ifdef CONFIG_GREYBUS_MODS_ACK
    if (req->features & DL_BIT_ACK) {
20001d30:	78c3      	ldrb	r3, [r0, #3]
    static struct dl_muc_bus_config_resp resp = {
        15000000,
        MAX_NW_PL_SIZE
    };

    g_spi_data.proto_ver = req->version;
20001d32:	4e1b      	ldr	r6, [pc, #108]	; (20001da0 <dl_muc_handler+0x88>)

    resp.version = PROTO_VER;
    resp.features = 0;

#ifdef CONFIG_GREYBUS_MODS_ACK
    if (req->features & DL_BIT_ACK) {
20001d34:	07db      	lsls	r3, r3, #31
    static struct dl_muc_bus_config_resp resp = {
        15000000,
        MAX_NW_PL_SIZE
    };

    g_spi_data.proto_ver = req->version;
20001d36:	7532      	strb	r2, [r6, #20]

    resp.version = PROTO_VER;
    resp.features = 0;

#ifdef CONFIG_GREYBUS_MODS_ACK
    if (req->features & DL_BIT_ACK) {
20001d38:	d507      	bpl.n	20001d4a <dl_muc_handler+0x32>
        g_spi_data.ack_supported = true;
20001d3a:	2501      	movs	r5, #1
20001d3c:	7375      	strb	r5, [r6, #13]
        resp.features |= DL_BIT_ACK;
20001d3e:	71a5      	strb	r5, [r4, #6]

      /* Bases that support ACKing must use PROTO_VER_ACK or later */
      if (!BASE_SUPPORTS(&g_spi_data, ACK))
20001d40:	b91a      	cbnz	r2, 20001d4a <dl_muc_handler+0x32>
        {
          dbgprint("ACK requires newer protocol version\r\n");
20001d42:	4818      	ldr	r0, [pc, #96]	; (20001da4 <dl_muc_handler+0x8c>)
20001d44:	f003 f9ac 	bl	200050a0 <dbgprint>
          g_spi_data.proto_ver = PROTO_VER_ACK;
20001d48:	7535      	strb	r5, [r6, #20]
#ifdef CONFIG_DEBUG_DATALINK
    dbgprintx32("ack_supported = ", g_spi_data.ack_supported, "\r\n");
#endif
#endif

    if (req->max_pl_size < MAX_NW_PL_SIZE) {
20001d4a:	f8b7 3001 	ldrh.w	r3, [r7, #1]
20001d4e:	b29a      	uxth	r2, r3
20001d50:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
        resp.pl_size = req->max_pl_size;
    } else {
        resp.pl_size = MAX_NW_PL_SIZE;
20001d54:	bf23      	ittte	cs
20001d56:	2300      	movcs	r3, #0
20001d58:	7123      	strbcs	r3, [r4, #4]
20001d5a:	2308      	movcs	r3, #8
    dbgprintx32("ack_supported = ", g_spi_data.ack_supported, "\r\n");
#endif
#endif

    if (req->max_pl_size < MAX_NW_PL_SIZE) {
        resp.pl_size = req->max_pl_size;
20001d5c:	80a3      	strhcc	r3, [r4, #4]
    } else {
        resp.pl_size = MAX_NW_PL_SIZE;
20001d5e:	bf28      	it	cs
20001d60:	7163      	strbcs	r3, [r4, #5]
{
    struct spi_msg *spi_msg = (struct spi_msg *)aTxBuffer;
    struct spi_dl_msg *spi_dl_msg = (struct spi_dl_msg *)spi_msg->payload;
    uint8_t *payload = spi_dl_msg->payload;

    spi_dl_msg->mesg_id = id | status;
20001d62:	783a      	ldrb	r2, [r7, #0]
20001d64:	4b10      	ldr	r3, [pc, #64]	; (20001da8 <dl_muc_handler+0x90>)
    dbgprintx32(" 0x", resp.pl_size, ")\r\n");
#endif

    return dl_send_dl_msg(dl_msg->mesg_id, GB_TYPE_RESPONSE, (uint8_t *)&resp,
                          sizeof(resp), dl_bus_config_cb,
                          (void *)(uint32_t)resp.pl_size);
20001d66:	88a1      	ldrh	r1, [r4, #4]
}

static inline void dl_set_sent_cb(msg_sent_cb cb, void *ctx)
{
    g_spi_data.sent_cb  = cb;
    g_spi_data.sent_ctx = ctx;
20001d68:	60b1      	str	r1, [r6, #8]
{
    struct spi_msg *spi_msg = (struct spi_msg *)aTxBuffer;
    struct spi_dl_msg *spi_dl_msg = (struct spi_dl_msg *)spi_msg->payload;
    uint8_t *payload = spi_dl_msg->payload;

    spi_dl_msg->mesg_id = id | status;
20001d6a:	f062 027f 	orn	r2, r2, #127	; 0x7f
20001d6e:	709a      	strb	r2, [r3, #2]

    if (payload_size != 0 && payload_data != NULL) {
        memcpy(payload, payload_data, payload_size);
20001d70:	6822      	ldr	r2, [r4, #0]
20001d72:	f8c3 2003 	str.w	r2, [r3, #3]
20001d76:	6862      	ldr	r2, [r4, #4]
20001d78:	f8c3 2007 	str.w	r2, [r3, #7]

static inline void dl_set_txp_hdr(uint8_t *buf, uint16_t bits)
{
    struct spi_msg_hdr *hdr = (struct spi_msg_hdr *)buf;

    hdr->bits = bits;
20001d7c:	f06f 027f 	mvn.w	r2, #127	; 0x7f
20001d80:	701a      	strb	r2, [r3, #0]
20001d82:	2201      	movs	r2, #1
20001d84:	705a      	strb	r2, [r3, #1]
    return g_spi_data.sent_cb;
}

static inline void dl_set_sent_cb(msg_sent_cb cb, void *ctx)
{
    g_spi_data.sent_cb  = cb;
20001d86:	4b09      	ldr	r3, [pc, #36]	; (20001dac <dl_muc_handler+0x94>)
    if (payload_size != 0 && payload_data != NULL) {
        memcpy(payload, payload_data, payload_size);
    }

    dl_set_txp_hdr(&aTxBuffer[0], MSG_TYPE_DL | HDR_BIT_VALID | HDR_BIT_PKT1);
    g_spi_data.respReady = true;
20001d88:	7332      	strb	r2, [r6, #12]
    return g_spi_data.sent_cb;
}

static inline void dl_set_sent_cb(msg_sent_cb cb, void *ctx)
{
    g_spi_data.sent_cb  = cb;
20001d8a:	6073      	str	r3, [r6, #4]
20001d8c:	e002      	b.n	20001d94 <dl_muc_handler+0x7c>
    switch (dl_msg->mesg_id) {
    case DL_MUC_OP_BUS_CONFIG:
        rc = dl_bus_config(dl_msg);
        break;
    default:
        dbgprint("DLDFLT\r\n");
20001d8e:	4808      	ldr	r0, [pc, #32]	; (20001db0 <dl_muc_handler+0x98>)
20001d90:	f003 f986 	bl	200050a0 <dbgprint>
        break;
    }

    return rc;
20001d94:	2000      	movs	r0, #0
    case DL_MUC_OP_BUS_CONFIG:
        rc = dl_bus_config(dl_msg);
        break;
    default:
        dbgprint("DLDFLT\r\n");
        break;
20001d96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

#ifdef CONFIG_DEBUG_DATALINK
    dbgprint("dl_muc_handler\r\n");
#endif
    if (dl_msg->mesg_id & GB_TYPE_RESPONSE) {
        return GB_OP_PROTOCOL_BAD;
20001d98:	2004      	movs	r0, #4
        dbgprint("DLDFLT\r\n");
        break;
    }

    return rc;
}
20001d9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
20001d9c:	200066be 	.word	0x200066be
20001da0:	200069d8 	.word	0x200069d8
20001da4:	2000647f 	.word	0x2000647f
20001da8:	200072e2 	.word	0x200072e2
20001dac:	20001add 	.word	0x20001add
20001db0:	200064a5 	.word	0x200064a5

20001db4 <dl_spi_error_handler>:
  memset(aRxBuffer, 0, MAX_DMA_BUF_SIZE);
  g_spi_data.armDMA = true;
}

void dl_spi_error_handler(SPI_HandleTypeDef *_hspi)
{
20001db4:	b508      	push	{r3, lr}
  Error_Handler(_hspi);
20001db6:	f7ff ff1f 	bl	20001bf8 <Error_Handler>
  dl_call_sent_cb(-1);
20001dba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
20001dbe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

void dl_spi_error_handler(SPI_HandleTypeDef *_hspi)
{
  Error_Handler(_hspi);
  dl_call_sent_cb(-1);
20001dc2:	f7ff be7d 	b.w	20001ac0 <dl_call_sent_cb>
	...

20001dc8 <dl_spi_transfer_complete>:
}

void dl_spi_transfer_complete(SPI_HandleTypeDef *_hspi)
{
20001dc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
20001dcc:	4604      	mov	r4, r0
  mods_rfr_set(PIN_RESET);
20001dce:	2000      	movs	r0, #0
20001dd0:	f7ff fdd4 	bl	2000197c <mods_rfr_set>
  mods_muc_int_set(PIN_RESET);
20001dd4:	2000      	movs	r0, #0
20001dd6:	f7ff fde5 	bl	200019a4 <mods_muc_int_set>

  /* Enable Software Slave Management to prevent spurious receives */
  _hspi->Instance->CR1 |= (SPI_CR1_SSM | SPI_CR1_SSI);
20001dda:	6822      	ldr	r2, [r4, #0]

static inline bool dl_is_msg_dummy(void *msg)
{
    struct spi_msg *spi_msg = (struct spi_msg *)msg;

    return (BASE_SUPPORTS(&g_spi_data, DUMMY)) ?
20001ddc:	4e2e      	ldr	r6, [pc, #184]	; (20001e98 <dl_spi_transfer_complete+0xd0>)
{
  mods_rfr_set(PIN_RESET);
  mods_muc_int_set(PIN_RESET);

  /* Enable Software Slave Management to prevent spurious receives */
  _hspi->Instance->CR1 |= (SPI_CR1_SSM | SPI_CR1_SSI);
20001dde:	6813      	ldr	r3, [r2, #0]
20001de0:	f443 7340 	orr.w	r3, r3, #768	; 0x300
20001de4:	6013      	str	r3, [r2, #0]
static inline bool dl_is_msg_valid_rx(void *msg)
{
    struct spi_msg *spi_msg = (struct spi_msg *)msg;
    uint16_t valid_mask = (HDR_BIT_VALID | HDR_BIT_PKT1);

    return ((spi_msg->hdr.bits & valid_mask) == valid_mask);
20001de6:	4b2d      	ldr	r3, [pc, #180]	; (20001e9c <dl_spi_transfer_complete+0xd4>)
20001de8:	881c      	ldrh	r4, [r3, #0]
20001dea:	f404 75c0 	and.w	r5, r4, #384	; 0x180
20001dee:	f5a5 72c0 	sub.w	r2, r5, #384	; 0x180
20001df2:	4255      	negs	r5, r2
20001df4:	4155      	adcs	r5, r2
static inline bool dl_is_msg_dummy(void *msg)
{
    struct spi_msg *spi_msg = (struct spi_msg *)msg;

    return (BASE_SUPPORTS(&g_spi_data, DUMMY)) ?
            !!(spi_msg->hdr.bits & HDR_BIT_DUMMY) :
20001df6:	7d32      	ldrb	r2, [r6, #20]
20001df8:	2a01      	cmp	r2, #1
20001dfa:	461f      	mov	r7, r3
20001dfc:	bf96      	itet	ls
20001dfe:	fab4 f484 	clzls	r4, r4
20001e02:	f3c4 2440 	ubfxhi	r4, r4, #9, #1
20001e06:	0964      	lsrls	r4, r4, #5
    bool rx_valid = dl_is_msg_valid_rx(aRxBuffer);
    bool rx_dummy = dl_is_msg_dummy(aRxBuffer);
    enum ack rx_ack_req;
    bool tx_retry = false;

    if (rx_valid) {
20001e08:	b925      	cbnz	r5, 20001e14 <dl_spi_transfer_complete+0x4c>
        rx_ack_req = ACK_NEEDED;
    } else if (!rx_dummy) {
        rx_ack_req = ACK_ERROR;
    } else {
        rx_ack_req = ACK_NOT_NEEDED;
20001e0a:	2c00      	cmp	r4, #0
20001e0c:	bf0c      	ite	eq
20001e0e:	2102      	moveq	r1, #2
20001e10:	2101      	movne	r1, #1
20001e12:	e000      	b.n	20001e16 <dl_spi_transfer_complete+0x4e>
    bool rx_dummy = dl_is_msg_dummy(aRxBuffer);
    enum ack rx_ack_req;
    bool tx_retry = false;

    if (rx_valid) {
        rx_ack_req = ACK_NEEDED;
20001e14:	2100      	movs	r1, #0
#ifdef CONFIG_DEBUG_DATALINK
    uint32_t dbg_tx_rx = tx_attempted << 16 | (uint16_t)ack_req;
    dbgprintx32("ack_handler 0x", dbg_tx_rx, "\r\n");
#endif

    if (!g_spi_data.ack_supported)
20001e16:	7b73      	ldrb	r3, [r6, #13]
        rx_ack_req = ACK_ERROR;
    } else {
        rx_ack_req = ACK_NOT_NEEDED;
    }

    tx_retry = !ack_handler(g_spi_data.respReady, rx_ack_req);
20001e18:	7b30      	ldrb	r0, [r6, #12]
#ifdef CONFIG_DEBUG_DATALINK
    uint32_t dbg_tx_rx = tx_attempted << 16 | (uint16_t)ack_req;
    dbgprintx32("ack_handler 0x", dbg_tx_rx, "\r\n");
#endif

    if (!g_spi_data.ack_supported)
20001e1a:	b11b      	cbz	r3, 20001e24 <dl_spi_transfer_complete+0x5c>
20001e1c:	f7ff fea2 	bl	20001b64 <ack_handler.part.0>
20001e20:	4680      	mov	r8, r0
20001e22:	e001      	b.n	20001e28 <dl_spi_transfer_complete+0x60>
        return true;
20001e24:	f04f 0801 	mov.w	r8, #1
        rx_ack_req = ACK_NOT_NEEDED;
    }

    tx_retry = !ack_handler(g_spi_data.respReady, rx_ack_req);

    if (rx_valid) {
20001e28:	b155      	cbz	r5, 20001e40 <dl_spi_transfer_complete+0x78>
        if ((spi_msg->hdr.bits & HDR_BIT_TYPE) == MSG_TYPE_NW) {
20001e2a:	883b      	ldrh	r3, [r7, #0]
            /* Send up to network layer */
            network_recv(spi_msg->payload, g_spi_data.payload_size);
20001e2c:	481c      	ldr	r0, [pc, #112]	; (20001ea0 <dl_spi_transfer_complete+0xd8>)
    }

    tx_retry = !ack_handler(g_spi_data.respReady, rx_ack_req);

    if (rx_valid) {
        if ((spi_msg->hdr.bits & HDR_BIT_TYPE) == MSG_TYPE_NW) {
20001e2e:	065b      	lsls	r3, r3, #25
20001e30:	d503      	bpl.n	20001e3a <dl_spi_transfer_complete+0x72>
            /* Send up to network layer */
            network_recv(spi_msg->payload, g_spi_data.payload_size);
20001e32:	8871      	ldrh	r1, [r6, #2]
20001e34:	f7ff fa1c 	bl	20001270 <network_recv>
20001e38:	e023      	b.n	20001e82 <dl_spi_transfer_complete+0xba>
        } else if ((spi_msg->hdr.bits & HDR_BIT_TYPE) == MSG_TYPE_DL) {
            /* handle at our level */
            (void)dl_muc_handler(spi_msg->payload);
20001e3a:	f7ff ff6d 	bl	20001d18 <dl_muc_handler>
20001e3e:	e020      	b.n	20001e82 <dl_spi_transfer_complete+0xba>
        } else {
            return 0;
        }
    } else if (g_spi_data.respReady) {
20001e40:	7b33      	ldrb	r3, [r6, #12]
20001e42:	b1c3      	cbz	r3, 20001e76 <dl_spi_transfer_complete+0xae>
        /* we were sending a message so handle it */
        mods_rfr_set(PIN_RESET);
20001e44:	4628      	mov	r0, r5
20001e46:	f7ff fd99 	bl	2000197c <mods_rfr_set>
        mods_muc_int_set(PIN_RESET);
20001e4a:	4628      	mov	r0, r5
20001e4c:	f7ff fdaa 	bl	200019a4 <mods_muc_int_set>
        if (!tx_retry) {
20001e50:	f1b8 0f00 	cmp.w	r8, #0
20001e54:	d00b      	beq.n	20001e6e <dl_spi_transfer_complete+0xa6>
    hdr->bits = bits;
}

static inline void dl_setup_for_dummy_tx(void)
{
    memset(aTxBuffer, 0, MAX_DMA_BUF_SIZE);
20001e56:	4c13      	ldr	r4, [pc, #76]	; (20001ea4 <dl_spi_transfer_complete+0xdc>)
    } else if (g_spi_data.respReady) {
        /* we were sending a message so handle it */
        mods_rfr_set(PIN_RESET);
        mods_muc_int_set(PIN_RESET);
        if (!tx_retry) {
            g_spi_data.respReady = false;
20001e58:	4b0f      	ldr	r3, [pc, #60]	; (20001e98 <dl_spi_transfer_complete+0xd0>)
    hdr->bits = bits;
}

static inline void dl_setup_for_dummy_tx(void)
{
    memset(aTxBuffer, 0, MAX_DMA_BUF_SIZE);
20001e5a:	4620      	mov	r0, r4
20001e5c:	4629      	mov	r1, r5
20001e5e:	f640 0202 	movw	r2, #2050	; 0x802
    } else if (g_spi_data.respReady) {
        /* we were sending a message so handle it */
        mods_rfr_set(PIN_RESET);
        mods_muc_int_set(PIN_RESET);
        if (!tx_retry) {
            g_spi_data.respReady = false;
20001e62:	731d      	strb	r5, [r3, #12]
    hdr->bits = bits;
}

static inline void dl_setup_for_dummy_tx(void)
{
    memset(aTxBuffer, 0, MAX_DMA_BUF_SIZE);
20001e64:	f7fe f9b8 	bl	200001d8 <memset>

static inline void dl_set_txp_hdr(uint8_t *buf, uint16_t bits)
{
    struct spi_msg_hdr *hdr = (struct spi_msg_hdr *)buf;

    hdr->bits = bits;
20001e68:	2302      	movs	r3, #2
20001e6a:	7025      	strb	r5, [r4, #0]
20001e6c:	7063      	strb	r3, [r4, #1]
        mods_muc_int_set(PIN_RESET);
        if (!tx_retry) {
            g_spi_data.respReady = false;
            dl_setup_for_dummy_tx();
        }
        dl_call_sent_cb(0);
20001e6e:	2000      	movs	r0, #0
20001e70:	f7ff fe26 	bl	20001ac0 <dl_call_sent_cb>
20001e74:	e005      	b.n	20001e82 <dl_spi_transfer_complete+0xba>
    } else if (!rx_dummy) {
20001e76:	b924      	cbnz	r4, 20001e82 <dl_spi_transfer_complete+0xba>
        dbgprint("UNEXPECTED MSG!!\r\n");
20001e78:	480b      	ldr	r0, [pc, #44]	; (20001ea8 <dl_spi_transfer_complete+0xe0>)
20001e7a:	f003 f911 	bl	200050a0 <dbgprint>
        dump();
20001e7e:	f7ff fe33 	bl	20001ae8 <dump>
    }

    memset(aRxBuffer, 0, MAX_DMA_BUF_SIZE);
20001e82:	4806      	ldr	r0, [pc, #24]	; (20001e9c <dl_spi_transfer_complete+0xd4>)
20001e84:	2100      	movs	r1, #0
20001e86:	f640 0202 	movw	r2, #2050	; 0x802
20001e8a:	f7fe f9a5 	bl	200001d8 <memset>
  dbgprint("TxRxCpltCB\r\n");
#endif

  dl_process_msg();

  g_spi_data.armDMA = true;
20001e8e:	2301      	movs	r3, #1
20001e90:	7033      	strb	r3, [r6, #0]
20001e92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20001e96:	bf00      	nop
20001e98:	200069d8 	.word	0x200069d8
20001e9c:	20006ae0 	.word	0x20006ae0
20001ea0:	20006ae2 	.word	0x20006ae2
20001ea4:	200072e2 	.word	0x200072e2
20001ea8:	200064ae 	.word	0x200064ae

20001eac <setup_exchange>:
}

void setup_exchange(void)
{
20001eac:	b538      	push	{r3, r4, r5, lr}
  uint32_t buf_size;

  if (g_spi_data.armDMA == true) {
20001eae:	4c22      	ldr	r4, [pc, #136]	; (20001f38 <setup_exchange+0x8c>)
20001eb0:	7823      	ldrb	r3, [r4, #0]
20001eb2:	2b00      	cmp	r3, #0
20001eb4:	d03e      	beq.n	20001f34 <setup_exchange+0x88>
    if (g_spi_data.respReady == true) {
20001eb6:	7b23      	ldrb	r3, [r4, #12]
20001eb8:	b1eb      	cbz	r3, 20001ef6 <setup_exchange+0x4a>
      /* we have something to send */
#ifdef CONFIG_DEBUG_DATALINK
      dbgprint("RSP\r\n");
#endif
      buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;
20001eba:	8863      	ldrh	r3, [r4, #2]
      if (HAL_SPI_TransmitReceive_DMA(&gb_hspi, (uint8_t*)aTxBuffer,
20001ebc:	481f      	ldr	r0, [pc, #124]	; (20001f3c <setup_exchange+0x90>)
20001ebe:	4920      	ldr	r1, [pc, #128]	; (20001f40 <setup_exchange+0x94>)
20001ec0:	4a20      	ldr	r2, [pc, #128]	; (20001f44 <setup_exchange+0x98>)
20001ec2:	4d1e      	ldr	r5, [pc, #120]	; (20001f3c <setup_exchange+0x90>)
    if (g_spi_data.respReady == true) {
      /* we have something to send */
#ifdef CONFIG_DEBUG_DATALINK
      dbgprint("RSP\r\n");
#endif
      buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;
20001ec4:	3302      	adds	r3, #2
      if (HAL_SPI_TransmitReceive_DMA(&gb_hspi, (uint8_t*)aTxBuffer,
20001ec6:	b29b      	uxth	r3, r3
20001ec8:	f002 f8e7 	bl	2000409a <HAL_SPI_TransmitReceive_DMA>
20001ecc:	b110      	cbz	r0, 20001ed4 <setup_exchange+0x28>
                                          (uint8_t *)aRxBuffer, buf_size) != HAL_OK) {
        /* Transfer error in transmission process */
        Error_Handler(&gb_hspi);
20001ece:	4628      	mov	r0, r5
20001ed0:	f7ff fe92 	bl	20001bf8 <Error_Handler>
      }

#ifdef CONFIG_DEBUG_DATALINK
      dbgprintx32("ARMED(0x", buf_size, ")\r\n");
#endif
      g_spi_data.armDMA = false;
20001ed4:	2300      	movs	r3, #0
20001ed6:	7023      	strb	r3, [r4, #0]

      /* We are ready to send, allow the hardware to manage the NSS */
      mods_spi_restore();
20001ed8:	f7ff fdaa 	bl	20001a30 <mods_spi_restore>
      gb_hspi.Instance->CR1 &= ~(SPI_CR1_SSM | SPI_CR1_SSI);
20001edc:	682a      	ldr	r2, [r5, #0]
20001ede:	6813      	ldr	r3, [r2, #0]
20001ee0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20001ee4:	6013      	str	r3, [r2, #0]
      mods_rfr_set(PIN_SET);
20001ee6:	2001      	movs	r0, #1
20001ee8:	f7ff fd48 	bl	2000197c <mods_rfr_set>
      mods_muc_int_set(PIN_SET);
20001eec:	2001      	movs	r0, #1
      mods_spi_restore();
      gb_hspi.Instance->CR1 &= ~(SPI_CR1_SSM | SPI_CR1_SSI);
      mods_rfr_set(PIN_SET);
    }
  }
}
20001eee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

      /* We are ready to send, allow the hardware to manage the NSS */
      mods_spi_restore();
      gb_hspi.Instance->CR1 &= ~(SPI_CR1_SSM | SPI_CR1_SSI);
      mods_rfr_set(PIN_SET);
      mods_muc_int_set(PIN_SET);
20001ef2:	f7ff bd57 	b.w	200019a4 <mods_muc_int_set>
    } else if (mods_wake_n_get() != PIN_SET) {
20001ef6:	f7ff fd4f 	bl	20001998 <mods_wake_n_get>
20001efa:	2801      	cmp	r0, #1
20001efc:	d01a      	beq.n	20001f34 <setup_exchange+0x88>
      /* host is telling us to setup to receive */
#ifdef CONFIG_DEBUG_DATALINK
      dbgprint("WKE-L\r\n");
#endif
      buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;
20001efe:	8863      	ldrh	r3, [r4, #2]
      if (HAL_SPI_TransmitReceive_DMA(&gb_hspi, (uint8_t*)aTxBuffer,
20001f00:	480e      	ldr	r0, [pc, #56]	; (20001f3c <setup_exchange+0x90>)
20001f02:	490f      	ldr	r1, [pc, #60]	; (20001f40 <setup_exchange+0x94>)
20001f04:	4a0f      	ldr	r2, [pc, #60]	; (20001f44 <setup_exchange+0x98>)
20001f06:	4d0d      	ldr	r5, [pc, #52]	; (20001f3c <setup_exchange+0x90>)
    } else if (mods_wake_n_get() != PIN_SET) {
      /* host is telling us to setup to receive */
#ifdef CONFIG_DEBUG_DATALINK
      dbgprint("WKE-L\r\n");
#endif
      buf_size =  g_spi_data.payload_size + DL_HEADER_BITS_SIZE;
20001f08:	3302      	adds	r3, #2
      if (HAL_SPI_TransmitReceive_DMA(&gb_hspi, (uint8_t*)aTxBuffer,
20001f0a:	b29b      	uxth	r3, r3
20001f0c:	f002 f8c5 	bl	2000409a <HAL_SPI_TransmitReceive_DMA>
20001f10:	b110      	cbz	r0, 20001f18 <setup_exchange+0x6c>
                                      (uint8_t *)aRxBuffer, buf_size) != HAL_OK) {
        /* Transfer error in transmission process */
        Error_Handler(&gb_hspi);
20001f12:	4628      	mov	r0, r5
20001f14:	f7ff fe70 	bl	20001bf8 <Error_Handler>
      }

#ifdef CONFIG_DEBUG_DATALINK
      dbgprintx32("ARMED(0x", buf_size, ")\r\n");
#endif
      g_spi_data.armDMA = false;
20001f18:	2300      	movs	r3, #0
20001f1a:	7023      	strb	r3, [r4, #0]

      /* We are ready to receive, allow the hardware to manage the NSS */
      mods_spi_restore();
20001f1c:	f7ff fd88 	bl	20001a30 <mods_spi_restore>
      gb_hspi.Instance->CR1 &= ~(SPI_CR1_SSM | SPI_CR1_SSI);
20001f20:	682a      	ldr	r2, [r5, #0]
20001f22:	6813      	ldr	r3, [r2, #0]
20001f24:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20001f28:	6013      	str	r3, [r2, #0]
      mods_rfr_set(PIN_SET);
20001f2a:	2001      	movs	r0, #1
    }
  }
}
20001f2c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      g_spi_data.armDMA = false;

      /* We are ready to receive, allow the hardware to manage the NSS */
      mods_spi_restore();
      gb_hspi.Instance->CR1 &= ~(SPI_CR1_SSM | SPI_CR1_SSI);
      mods_rfr_set(PIN_SET);
20001f30:	f7ff bd24 	b.w	2000197c <mods_rfr_set>
20001f34:	bd38      	pop	{r3, r4, r5, pc}
20001f36:	bf00      	nop
20001f38:	200069d8 	.word	0x200069d8
20001f3c:	20006974 	.word	0x20006974
20001f40:	200072e2 	.word	0x200072e2
20001f44:	20006ae0 	.word	0x20006ae0

20001f48 <spi_flash_finish>:

    return result;
}

static int spi_flash_finish(void) {
    spi_flash_device = NULL;
20001f48:	4b01      	ldr	r3, [pc, #4]	; (20001f50 <spi_flash_finish+0x8>)
20001f4a:	2000      	movs	r0, #0
20001f4c:	6018      	str	r0, [r3, #0]
    return 0;
}
20001f4e:	4770      	bx	lr
20001f50:	200069f0 	.word	0x200069f0

20001f54 <spi_flash_get_capacity>:

static size_t spi_flash_get_capacity(void) {
    return spi_flash_device ? spi_flash_device->sector_size * spi_flash_device->num_sectors : 0;
20001f54:	4b03      	ldr	r3, [pc, #12]	; (20001f64 <spi_flash_get_capacity+0x10>)
20001f56:	6818      	ldr	r0, [r3, #0]
20001f58:	b118      	cbz	r0, 20001f62 <spi_flash_get_capacity+0xe>
20001f5a:	68c2      	ldr	r2, [r0, #12]
20001f5c:	6883      	ldr	r3, [r0, #8]
20001f5e:	fb03 f002 	mul.w	r0, r3, r2
}
20001f62:	4770      	bx	lr
20001f64:	200069f0 	.word	0x200069f0

20001f68 <spi_flash_get_erase_size>:

static size_t spi_flash_get_erase_size(void) {
    return spi_flash_device ? spi_flash_device->erase_size : 0;
20001f68:	4b02      	ldr	r3, [pc, #8]	; (20001f74 <spi_flash_get_erase_size+0xc>)
20001f6a:	6818      	ldr	r0, [r3, #0]
20001f6c:	b100      	cbz	r0, 20001f70 <spi_flash_get_erase_size+0x8>
20001f6e:	6940      	ldr	r0, [r0, #20]
}
20001f70:	4770      	bx	lr
20001f72:	bf00      	nop
20001f74:	200069f0 	.word	0x200069f0

20001f78 <spi_flash_wait_for_not_busy>:
    }

    return 0;
}

static void spi_flash_wait_for_not_busy(void) {
20001f78:	b507      	push	{r0, r1, r2, lr}
    uint8_t txbuf[STATUS_CMD_SIZE];
    memset(txbuf, 0, STATUS_CMD_SIZE);
20001f7a:	2300      	movs	r3, #0
20001f7c:	f8ad 3004 	strh.w	r3, [sp, #4]
    txbuf[0] = STATUS_CMD;
20001f80:	2305      	movs	r3, #5
20001f82:	f88d 3004 	strb.w	r3, [sp, #4]
    while (1) {
        chip_spi_exchange(txbuf, txbuf, STATUS_CMD_SIZE);
20001f86:	a801      	add	r0, sp, #4
20001f88:	4601      	mov	r1, r0
20001f8a:	2202      	movs	r2, #2
20001f8c:	f000 fa70 	bl	20002470 <chip_spi_exchange>
        if ((txbuf[1] & STATUS_BUSY) == 0) {
20001f90:	f89d 3005 	ldrb.w	r3, [sp, #5]
20001f94:	07db      	lsls	r3, r3, #31
20001f96:	d4f6      	bmi.n	20001f86 <spi_flash_wait_for_not_busy+0xe>
            break;
        }
    }
}
20001f98:	b003      	add	sp, #12
20001f9a:	f85d fb04 	ldr.w	pc, [sp], #4

20001f9e <spi_flash_write_enable>:
    }

    return 0;
}

static int spi_flash_write_enable(void) {
20001f9e:	b513      	push	{r0, r1, r4, lr}
    uint8_t txbuf[STATUS_CMD_SIZE];

    memset(txbuf, 0, STATUS_CMD_SIZE);
    txbuf[0] = WRITE_ENABLE_CMD;

    chip_spi_exchange(txbuf, txbuf, WRITE_ENABLE_CMD_SIZE);
20001fa0:	a801      	add	r0, sp, #4

static int spi_flash_write_enable(void) {
    uint8_t txbuf[STATUS_CMD_SIZE];

    memset(txbuf, 0, STATUS_CMD_SIZE);
    txbuf[0] = WRITE_ENABLE_CMD;
20001fa2:	2306      	movs	r3, #6
}

static int spi_flash_write_enable(void) {
    uint8_t txbuf[STATUS_CMD_SIZE];

    memset(txbuf, 0, STATUS_CMD_SIZE);
20001fa4:	2400      	movs	r4, #0
    txbuf[0] = WRITE_ENABLE_CMD;

    chip_spi_exchange(txbuf, txbuf, WRITE_ENABLE_CMD_SIZE);
20001fa6:	4601      	mov	r1, r0
20001fa8:	2201      	movs	r2, #1
}

static int spi_flash_write_enable(void) {
    uint8_t txbuf[STATUS_CMD_SIZE];

    memset(txbuf, 0, STATUS_CMD_SIZE);
20001faa:	f8ad 4004 	strh.w	r4, [sp, #4]
    txbuf[0] = WRITE_ENABLE_CMD;
20001fae:	f88d 3004 	strb.w	r3, [sp, #4]

    chip_spi_exchange(txbuf, txbuf, WRITE_ENABLE_CMD_SIZE);
20001fb2:	f000 fa5d 	bl	20002470 <chip_spi_exchange>

    memset(txbuf, 0, STATUS_CMD_SIZE);
    txbuf[0] = STATUS_CMD;
20001fb6:	2305      	movs	r3, #5
    memset(txbuf, 0, STATUS_CMD_SIZE);
    txbuf[0] = WRITE_ENABLE_CMD;

    chip_spi_exchange(txbuf, txbuf, WRITE_ENABLE_CMD_SIZE);

    memset(txbuf, 0, STATUS_CMD_SIZE);
20001fb8:	f8ad 4004 	strh.w	r4, [sp, #4]
    txbuf[0] = STATUS_CMD;
20001fbc:	f88d 3004 	strb.w	r3, [sp, #4]
    while (1) {
        chip_spi_exchange(txbuf, txbuf, STATUS_CMD_SIZE);
20001fc0:	a801      	add	r0, sp, #4
20001fc2:	4601      	mov	r1, r0
20001fc4:	2202      	movs	r2, #2
20001fc6:	f000 fa53 	bl	20002470 <chip_spi_exchange>

        if ((txbuf[1] & STATUS_WRITE_ENABLE_LATCH) == STATUS_WRITE_ENABLE_LATCH) {
20001fca:	f89d 3005 	ldrb.w	r3, [sp, #5]
20001fce:	079b      	lsls	r3, r3, #30
20001fd0:	d5f6      	bpl.n	20001fc0 <spi_flash_write_enable+0x22>
            break;
        }
    }

    return 0;
}
20001fd2:	2000      	movs	r0, #0
20001fd4:	b002      	add	sp, #8
20001fd6:	bd10      	pop	{r4, pc}

20001fd8 <spi_flash_erase_all>:
    result = spi_flash_read_id();

    return result;
}

static int spi_flash_erase_all(void) {
20001fd8:	b513      	push	{r0, r1, r4, lr}
    uint8_t txbuf[ERASE_ALL_CMD_SIZE];

    spi_flash_write_enable();
20001fda:	f7ff ffe0 	bl	20001f9e <spi_flash_write_enable>
    memset(txbuf, 0, ERASE_CMD_SIZE);
    txbuf[0] = ERASE_ALL_CMD;
    chip_spi_exchange(txbuf, txbuf, ERASE_ALL_CMD_SIZE);
20001fde:	a801      	add	r0, sp, #4
static int spi_flash_erase_all(void) {
    uint8_t txbuf[ERASE_ALL_CMD_SIZE];

    spi_flash_write_enable();
    memset(txbuf, 0, ERASE_CMD_SIZE);
    txbuf[0] = ERASE_ALL_CMD;
20001fe0:	2360      	movs	r3, #96	; 0x60

static int spi_flash_erase_all(void) {
    uint8_t txbuf[ERASE_ALL_CMD_SIZE];

    spi_flash_write_enable();
    memset(txbuf, 0, ERASE_CMD_SIZE);
20001fe2:	2400      	movs	r4, #0
    txbuf[0] = ERASE_ALL_CMD;
    chip_spi_exchange(txbuf, txbuf, ERASE_ALL_CMD_SIZE);
20001fe4:	4601      	mov	r1, r0
20001fe6:	2201      	movs	r2, #1

static int spi_flash_erase_all(void) {
    uint8_t txbuf[ERASE_ALL_CMD_SIZE];

    spi_flash_write_enable();
    memset(txbuf, 0, ERASE_CMD_SIZE);
20001fe8:	9401      	str	r4, [sp, #4]
    txbuf[0] = ERASE_ALL_CMD;
20001fea:	f88d 3004 	strb.w	r3, [sp, #4]
    chip_spi_exchange(txbuf, txbuf, ERASE_ALL_CMD_SIZE);
20001fee:	f000 fa3f 	bl	20002470 <chip_spi_exchange>

    spi_flash_wait_for_not_busy();
20001ff2:	f7ff ffc1 	bl	20001f78 <spi_flash_wait_for_not_busy>
    return 0;
}
20001ff6:	4620      	mov	r0, r4
20001ff8:	b002      	add	sp, #8
20001ffa:	bd10      	pop	{r4, pc}

20001ffc <spi_flash_init>:
            break;
        }
    }
}

static int spi_flash_init(void) {
20001ffc:	b537      	push	{r0, r1, r2, r4, r5, lr}
}

static int spi_flash_read_id(void) {
    uint8_t txbuf[JEDEC_ID_CMD_SIZE];

    memset(txbuf, 0, JEDEC_ID_CMD_SIZE);
20001ffe:	2300      	movs	r3, #0

    txbuf[0] = JEDEC_ID_CMD;
    chip_spi_exchange(txbuf, txbuf, JEDEC_ID_CMD_SIZE);
20002000:	a801      	add	r0, sp, #4
    dbgprintx32("spi_flash_read_id ..", txbuf[1], "\r\n");
20002002:	ad02      	add	r5, sp, #8
}

static int spi_flash_read_id(void) {
    uint8_t txbuf[JEDEC_ID_CMD_SIZE];

    memset(txbuf, 0, JEDEC_ID_CMD_SIZE);
20002004:	9301      	str	r3, [sp, #4]

    txbuf[0] = JEDEC_ID_CMD;
    chip_spi_exchange(txbuf, txbuf, JEDEC_ID_CMD_SIZE);
20002006:	4601      	mov	r1, r0
static int spi_flash_read_id(void) {
    uint8_t txbuf[JEDEC_ID_CMD_SIZE];

    memset(txbuf, 0, JEDEC_ID_CMD_SIZE);

    txbuf[0] = JEDEC_ID_CMD;
20002008:	239f      	movs	r3, #159	; 0x9f
    chip_spi_exchange(txbuf, txbuf, JEDEC_ID_CMD_SIZE);
2000200a:	2204      	movs	r2, #4
static int spi_flash_read_id(void) {
    uint8_t txbuf[JEDEC_ID_CMD_SIZE];

    memset(txbuf, 0, JEDEC_ID_CMD_SIZE);

    txbuf[0] = JEDEC_ID_CMD;
2000200c:	f88d 3004 	strb.w	r3, [sp, #4]
    chip_spi_exchange(txbuf, txbuf, JEDEC_ID_CMD_SIZE);
20002010:	f000 fa2e 	bl	20002470 <chip_spi_exchange>
    dbgprintx32("spi_flash_read_id ..", txbuf[1], "\r\n");
20002014:	f815 1d03 	ldrb.w	r1, [r5, #-3]!
20002018:	480f      	ldr	r0, [pc, #60]	; (20002058 <spi_flash_init+0x5c>)
2000201a:	4a10      	ldr	r2, [pc, #64]	; (2000205c <spi_flash_init+0x60>)
2000201c:	4c10      	ldr	r4, [pc, #64]	; (20002060 <spi_flash_init+0x64>)
2000201e:	f003 f872 	bl	20005106 <dbgprintx32>
static const struct spi_flash_device *spi_flash_device;

static const struct spi_flash_device * spi_find_device(const uint8_t *jedec_id) {
    size_t i;
    for (i = 0; i < sizeof(SPI_FLASH_DEVICES)/sizeof(SPI_FLASH_DEVICES[0]); i++) {
        int result = memcmp(jedec_id, SPI_FLASH_DEVICES[i].jedec_id, sizeof(SPI_FLASH_DEVICES[i].jedec_id));
20002022:	4628      	mov	r0, r5
20002024:	490e      	ldr	r1, [pc, #56]	; (20002060 <spi_flash_init+0x64>)
20002026:	2203      	movs	r2, #3
20002028:	f003 fdfa 	bl	20005c20 <memcmp>
        if (!result) {
2000202c:	b158      	cbz	r0, 20002046 <spi_flash_init+0x4a>
static const struct spi_flash_device *spi_flash_device;

static const struct spi_flash_device * spi_find_device(const uint8_t *jedec_id) {
    size_t i;
    for (i = 0; i < sizeof(SPI_FLASH_DEVICES)/sizeof(SPI_FLASH_DEVICES[0]); i++) {
        int result = memcmp(jedec_id, SPI_FLASH_DEVICES[i].jedec_id, sizeof(SPI_FLASH_DEVICES[i].jedec_id));
2000202e:	4628      	mov	r0, r5
20002030:	f104 0124 	add.w	r1, r4, #36	; 0x24
20002034:	2203      	movs	r2, #3
20002036:	f003 fdf3 	bl	20005c20 <memcmp>
        if (!result) {
2000203a:	b118      	cbz	r0, 20002044 <spi_flash_init+0x48>
            return &SPI_FLASH_DEVICES[i];
        }
    }

    dbgprint("WARNING: JEDEC ID not found\n");
2000203c:	4809      	ldr	r0, [pc, #36]	; (20002064 <spi_flash_init+0x68>)
2000203e:	f003 f82f 	bl	200050a0 <dbgprint>
20002042:	e003      	b.n	2000204c <spi_flash_init+0x50>

static const struct spi_flash_device *spi_flash_device;

static const struct spi_flash_device * spi_find_device(const uint8_t *jedec_id) {
    size_t i;
    for (i = 0; i < sizeof(SPI_FLASH_DEVICES)/sizeof(SPI_FLASH_DEVICES[0]); i++) {
20002044:	2001      	movs	r0, #1
        int result = memcmp(jedec_id, SPI_FLASH_DEVICES[i].jedec_id, sizeof(SPI_FLASH_DEVICES[i].jedec_id));
        if (!result) {
            return &SPI_FLASH_DEVICES[i];
20002046:	2324      	movs	r3, #36	; 0x24
20002048:	fb03 4400 	mla	r4, r3, r0, r4
    memset(txbuf, 0, JEDEC_ID_CMD_SIZE);

    txbuf[0] = JEDEC_ID_CMD;
    chip_spi_exchange(txbuf, txbuf, JEDEC_ID_CMD_SIZE);
    dbgprintx32("spi_flash_read_id ..", txbuf[1], "\r\n");
    spi_flash_device = spi_find_device(&txbuf[1]);
2000204c:	4b06      	ldr	r3, [pc, #24]	; (20002068 <spi_flash_init+0x6c>)
    int result;

    result = spi_flash_read_id();

    return result;
}
2000204e:	2000      	movs	r0, #0
    memset(txbuf, 0, JEDEC_ID_CMD_SIZE);

    txbuf[0] = JEDEC_ID_CMD;
    chip_spi_exchange(txbuf, txbuf, JEDEC_ID_CMD_SIZE);
    dbgprintx32("spi_flash_read_id ..", txbuf[1], "\r\n");
    spi_flash_device = spi_find_device(&txbuf[1]);
20002050:	601c      	str	r4, [r3, #0]
    int result;

    result = spi_flash_read_id();

    return result;
}
20002052:	b003      	add	sp, #12
20002054:	bd30      	pop	{r4, r5, pc}
20002056:	bf00      	nop
20002058:	2000650c 	.word	0x2000650c
2000205c:	20005e34 	.word	0x20005e34
20002060:	200064c4 	.word	0x200064c4
20002064:	20006521 	.word	0x20006521
20002068:	200069f0 	.word	0x200069f0

2000206c <spi_flash_write_address>:
    dbgprint("WARNING: JEDEC ID not found\n");
    return &SPI_FLASH_DEVICES[0];
}

static void spi_flash_write_address(uint32_t address, uint8_t buffer[]) {
    if (spi_flash_device->address_width == 3) {
2000206c:	4b0b      	ldr	r3, [pc, #44]	; (2000209c <spi_flash_write_address+0x30>)
2000206e:	681b      	ldr	r3, [r3, #0]
20002070:	685b      	ldr	r3, [r3, #4]
20002072:	2b03      	cmp	r3, #3
20002074:	d105      	bne.n	20002082 <spi_flash_write_address+0x16>
        buffer[0] = (address >> 16) & 0x0ff;
20002076:	0c03      	lsrs	r3, r0, #16
20002078:	700b      	strb	r3, [r1, #0]
        buffer[1] = (address >>  8) & 0x0ff;
2000207a:	0a03      	lsrs	r3, r0, #8
2000207c:	704b      	strb	r3, [r1, #1]
        buffer[2] = (address >>  0) & 0x0ff;
2000207e:	7088      	strb	r0, [r1, #2]
20002080:	4770      	bx	lr
    } else if (spi_flash_device->address_width == 4) {
20002082:	2b04      	cmp	r3, #4
20002084:	d107      	bne.n	20002096 <spi_flash_write_address+0x2a>
        buffer[0] = (address >> 24) & 0x0ff;
20002086:	0e03      	lsrs	r3, r0, #24
20002088:	700b      	strb	r3, [r1, #0]
        buffer[1] = (address >> 16) & 0x0ff;
2000208a:	0c03      	lsrs	r3, r0, #16
2000208c:	704b      	strb	r3, [r1, #1]
        buffer[2] = (address >>  8) & 0x0ff;
2000208e:	0a03      	lsrs	r3, r0, #8
20002090:	708b      	strb	r3, [r1, #2]
        buffer[3] = (address >>  0) & 0x0ff;
20002092:	70c8      	strb	r0, [r1, #3]
20002094:	4770      	bx	lr
    } else {
        dbgprint("ERROR: invalid address width");
20002096:	4802      	ldr	r0, [pc, #8]	; (200020a0 <spi_flash_write_address+0x34>)
20002098:	f003 b802 	b.w	200050a0 <dbgprint>
2000209c:	200069f0 	.word	0x200069f0
200020a0:	2000653e 	.word	0x2000653e

200020a4 <spi_flash_verify>:
    }

    return 0;
}

static int spi_flash_verify(uint32_t dst, void *src, uint32_t length) {
200020a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t rxbuf[READ_CMD_SIZE + length];
200020a8:	f102 030b 	add.w	r3, r2, #11
200020ac:	f023 0307 	bic.w	r3, r3, #7
    }

    return 0;
}

static int spi_flash_verify(uint32_t dst, void *src, uint32_t length) {
200020b0:	af00      	add	r7, sp, #0
    uint8_t rxbuf[READ_CMD_SIZE + length];
200020b2:	1d15      	adds	r5, r2, #4
200020b4:	ebad 0d03 	sub.w	sp, sp, r3
    }

    return 0;
}

static int spi_flash_verify(uint32_t dst, void *src, uint32_t length) {
200020b8:	4614      	mov	r4, r2
200020ba:	4680      	mov	r8, r0
200020bc:	460e      	mov	r6, r1
    uint8_t rxbuf[READ_CMD_SIZE + length];
    int result;

    spi_flash_wait_for_not_busy();
200020be:	f7ff ff5b 	bl	20001f78 <spi_flash_wait_for_not_busy>

    memset(rxbuf, 0, (READ_CMD_SIZE + length));
200020c2:	462a      	mov	r2, r5
200020c4:	2100      	movs	r1, #0
200020c6:	4668      	mov	r0, sp
200020c8:	f7fe f886 	bl	200001d8 <memset>
    rxbuf[0] = READ_CMD;
200020cc:	4669      	mov	r1, sp
200020ce:	2303      	movs	r3, #3
200020d0:	f801 3b01 	strb.w	r3, [r1], #1
    spi_flash_write_address(dst, &rxbuf[1]);
200020d4:	4640      	mov	r0, r8
200020d6:	f7ff ffc9 	bl	2000206c <spi_flash_write_address>

    chip_spi_exchange(rxbuf, rxbuf, (length + READ_CMD_SIZE));
200020da:	4669      	mov	r1, sp
200020dc:	462a      	mov	r2, r5
200020de:	4668      	mov	r0, sp
200020e0:	f000 f9c6 	bl	20002470 <chip_spi_exchange>

    result = memcmp(&rxbuf[READ_CMD_SIZE], src, length);
200020e4:	4622      	mov	r2, r4
200020e6:	a801      	add	r0, sp, #4
200020e8:	4631      	mov	r1, r6
200020ea:	f003 fd99 	bl	20005c20 <memcmp>
    if (result) {
200020ee:	4604      	mov	r4, r0
200020f0:	b120      	cbz	r0, 200020fc <spi_flash_verify+0x58>
        dbgprintx32("ERROR: flash verify failed\n", result, "\r\n");
200020f2:	4804      	ldr	r0, [pc, #16]	; (20002104 <spi_flash_verify+0x60>)
200020f4:	4a04      	ldr	r2, [pc, #16]	; (20002108 <spi_flash_verify+0x64>)
200020f6:	4621      	mov	r1, r4
200020f8:	f003 f805 	bl	20005106 <dbgprintx32>
        return result;
    }

    return result;
}
200020fc:	4620      	mov	r0, r4
200020fe:	46bd      	mov	sp, r7
20002100:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20002104:	2000655b 	.word	0x2000655b
20002108:	20005e34 	.word	0x20005e34

2000210c <spi_flash_write>:

    dbgprint("\n");
    return 0;
}

static int spi_flash_write(uint32_t _dst, void *_src, uint32_t length) {
2000210c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint8_t txbuf[WRITE_CMD_SIZE + spi_flash_device->page_size];
20002110:	4e22      	ldr	r6, [pc, #136]	; (2000219c <spi_flash_write+0x90>)
20002112:	6833      	ldr	r3, [r6, #0]
20002114:	691b      	ldr	r3, [r3, #16]
20002116:	330b      	adds	r3, #11
20002118:	f023 0307 	bic.w	r3, r3, #7

    dbgprint("\n");
    return 0;
}

static int spi_flash_write(uint32_t _dst, void *_src, uint32_t length) {
2000211c:	af00      	add	r7, sp, #0
    uint8_t txbuf[WRITE_CMD_SIZE + spi_flash_device->page_size];
2000211e:	ebad 0d03 	sub.w	sp, sp, r3

    dbgprint("\n");
    return 0;
}

static int spi_flash_write(uint32_t _dst, void *_src, uint32_t length) {
20002122:	4682      	mov	sl, r0
20002124:	460d      	mov	r5, r1
    uint8_t txbuf[WRITE_CMD_SIZE + spi_flash_device->page_size];
20002126:	46e8      	mov	r8, sp
    uint32_t dst = _dst;
    uint8_t *src = _src;
    uint8_t *src_end = src + length;
20002128:	eb01 0902 	add.w	r9, r1, r2
    dbgprintx32("write dst end ", (_dst + length), "\r\n");
    dbgprintx32("write src ", ((uint32_t)_src), "\r\n");
    dbgprintx32("write src end ", (((uint32_t)src) + length), "\r\n");
#endif

    while (src < src_end) {
2000212c:	454d      	cmp	r5, r9
2000212e:	d230      	bcs.n	20002192 <spi_flash_write+0x86>
        memset(txbuf, 0, WRITE_CMD_SIZE + spi_flash_device->page_size);
20002130:	6833      	ldr	r3, [r6, #0]
20002132:	691a      	ldr	r2, [r3, #16]
20002134:	2100      	movs	r1, #0
20002136:	3204      	adds	r2, #4
20002138:	4640      	mov	r0, r8
2000213a:	f7fe f84d 	bl	200001d8 <memset>
        spi_flash_write_enable();
2000213e:	f7ff ff2e 	bl	20001f9e <spi_flash_write_enable>

        uint32_t len = MIN(src_end - src, spi_flash_device->page_size);
20002142:	6833      	ldr	r3, [r6, #0]
20002144:	691c      	ldr	r4, [r3, #16]

        /* Align the destination on a page boundary. */
        uint32_t page_offset = (dst % spi_flash_device->page_size);
20002146:	fbba f2f4 	udiv	r2, sl, r4
2000214a:	fb04 a212 	mls	r2, r4, r2, sl

    while (src < src_end) {
        memset(txbuf, 0, WRITE_CMD_SIZE + spi_flash_device->page_size);
        spi_flash_write_enable();

        uint32_t len = MIN(src_end - src, spi_flash_device->page_size);
2000214e:	ebc5 0309 	rsb	r3, r5, r9

        /* Align the destination on a page boundary. */
        uint32_t page_offset = (dst % spi_flash_device->page_size);
        if (page_offset) {
20002152:	b102      	cbz	r2, 20002156 <spi_flash_write+0x4a>
            len = MIN(src_end - src, spi_flash_device->page_size - page_offset);
20002154:	1aa4      	subs	r4, r4, r2
20002156:	429c      	cmp	r4, r3
        }

        txbuf[0] = WRITE_CMD;
20002158:	4641      	mov	r1, r8
        uint32_t len = MIN(src_end - src, spi_flash_device->page_size);

        /* Align the destination on a page boundary. */
        uint32_t page_offset = (dst % spi_flash_device->page_size);
        if (page_offset) {
            len = MIN(src_end - src, spi_flash_device->page_size - page_offset);
2000215a:	bf28      	it	cs
2000215c:	461c      	movcs	r4, r3
        }

        txbuf[0] = WRITE_CMD;
2000215e:	2302      	movs	r3, #2
20002160:	f801 3b01 	strb.w	r3, [r1], #1
#ifdef CONFIG_DEBUG_SPI_FLASH
        dbgprintx32("page dst ", dst, "\r\n");
#endif
        spi_flash_write_address(dst, &txbuf[1]);
20002164:	4650      	mov	r0, sl
20002166:	f7ff ff81 	bl	2000206c <spi_flash_write_address>
        memcpy(&txbuf[WRITE_CMD_SIZE], src, len);
2000216a:	4629      	mov	r1, r5
2000216c:	4622      	mov	r2, r4
2000216e:	f108 0004 	add.w	r0, r8, #4
20002172:	f003 fd87 	bl	20005c84 <memcpy>

        chip_spi_exchange(txbuf, txbuf, (WRITE_CMD_SIZE + len));
20002176:	4641      	mov	r1, r8
20002178:	1d22      	adds	r2, r4, #4
2000217a:	4640      	mov	r0, r8
2000217c:	f000 f978 	bl	20002470 <chip_spi_exchange>

        chip_delay(spi_flash_device->program_delay);
20002180:	6833      	ldr	r3, [r6, #0]
20002182:	69d8      	ldr	r0, [r3, #28]
20002184:	f000 f9ca 	bl	2000251c <chip_delay>

        spi_flash_wait_for_not_busy();

        dst += len;
20002188:	44a2      	add	sl, r4

        chip_spi_exchange(txbuf, txbuf, (WRITE_CMD_SIZE + len));

        chip_delay(spi_flash_device->program_delay);

        spi_flash_wait_for_not_busy();
2000218a:	f7ff fef5 	bl	20001f78 <spi_flash_wait_for_not_busy>

        dst += len;
        src += len;
2000218e:	4425      	add	r5, r4
20002190:	e7cc      	b.n	2000212c <spi_flash_write+0x20>
    }

    return 0;
}
20002192:	2000      	movs	r0, #0
20002194:	46bd      	mov	sp, r7
20002196:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
2000219a:	bf00      	nop
2000219c:	200069f0 	.word	0x200069f0

200021a0 <spi_flash_erase>:

    spi_flash_wait_for_not_busy();
    return 0;
}

static int spi_flash_erase(uint32_t dst, uint32_t length) {
200021a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
#ifdef CONFIG_DEBUG_SPI_FLASH
    dbgprintx32("erase len ", length, "\n");
    dbgprintx32("erase dst ", dst, "\n");
    dbgprintx32("erase dst end ", (dst + length), "\n");
#endif
    dbgprintx32("erasing ", length, " bytes\r\n");
200021a2:	4a15      	ldr	r2, [pc, #84]	; (200021f8 <spi_flash_erase+0x58>)

    spi_flash_wait_for_not_busy();
    return 0;
}

static int spi_flash_erase(uint32_t dst, uint32_t length) {
200021a4:	4604      	mov	r4, r0
    uint8_t txbuf[ERASE_CMD_SIZE];
    uint32_t dst_end = dst + length;
200021a6:	1846      	adds	r6, r0, r1
#ifdef CONFIG_DEBUG_SPI_FLASH
    dbgprintx32("erase len ", length, "\n");
    dbgprintx32("erase dst ", dst, "\n");
    dbgprintx32("erase dst end ", (dst + length), "\n");
#endif
    dbgprintx32("erasing ", length, " bytes\r\n");
200021a8:	4814      	ldr	r0, [pc, #80]	; (200021fc <spi_flash_erase+0x5c>)
200021aa:	f002 ffac 	bl	20005106 <dbgprintx32>
    while (dst < dst_end) {
200021ae:	42b4      	cmp	r4, r6
200021b0:	d21b      	bcs.n	200021ea <spi_flash_erase+0x4a>
        memset(txbuf, 0, ERASE_CMD_SIZE);
200021b2:	2300      	movs	r3, #0
200021b4:	9301      	str	r3, [sp, #4]
        spi_flash_write_enable();
200021b6:	f7ff fef2 	bl	20001f9e <spi_flash_write_enable>

        txbuf[0] = ERASE_CMD;
200021ba:	2320      	movs	r3, #32
        spi_flash_write_address(dst, &txbuf[1]);
200021bc:	4620      	mov	r0, r4
200021be:	f10d 0105 	add.w	r1, sp, #5
    dbgprintx32("erasing ", length, " bytes\r\n");
    while (dst < dst_end) {
        memset(txbuf, 0, ERASE_CMD_SIZE);
        spi_flash_write_enable();

        txbuf[0] = ERASE_CMD;
200021c2:	f88d 3004 	strb.w	r3, [sp, #4]
        spi_flash_write_address(dst, &txbuf[1]);
        chip_spi_exchange(txbuf, txbuf, ERASE_CMD_SIZE);

        chip_delay(spi_flash_device->erase_delay);
200021c6:	4d0e      	ldr	r5, [pc, #56]	; (20002200 <spi_flash_erase+0x60>)
    while (dst < dst_end) {
        memset(txbuf, 0, ERASE_CMD_SIZE);
        spi_flash_write_enable();

        txbuf[0] = ERASE_CMD;
        spi_flash_write_address(dst, &txbuf[1]);
200021c8:	f7ff ff50 	bl	2000206c <spi_flash_write_address>
        chip_spi_exchange(txbuf, txbuf, ERASE_CMD_SIZE);
200021cc:	a801      	add	r0, sp, #4
200021ce:	4601      	mov	r1, r0
200021d0:	2204      	movs	r2, #4
200021d2:	f000 f94d 	bl	20002470 <chip_spi_exchange>

        chip_delay(spi_flash_device->erase_delay);
200021d6:	682b      	ldr	r3, [r5, #0]
200021d8:	6a18      	ldr	r0, [r3, #32]
200021da:	f000 f99f 	bl	2000251c <chip_delay>

        spi_flash_wait_for_not_busy();
200021de:	f7ff fecb 	bl	20001f78 <spi_flash_wait_for_not_busy>
        dst += spi_flash_device->erase_size;
200021e2:	682b      	ldr	r3, [r5, #0]
200021e4:	695b      	ldr	r3, [r3, #20]
200021e6:	441c      	add	r4, r3
200021e8:	e7e1      	b.n	200021ae <spi_flash_erase+0xe>
#ifdef CONFIG_DEBUG_SPI_FLASH
        dbgprintx32("erase dst addr", dst, "\r\n");
#endif
    }

    dbgprint("\n");
200021ea:	4806      	ldr	r0, [pc, #24]	; (20002204 <spi_flash_erase+0x64>)
200021ec:	f002 ff58 	bl	200050a0 <dbgprint>
    return 0;
}
200021f0:	2000      	movs	r0, #0
200021f2:	b002      	add	sp, #8
200021f4:	bd70      	pop	{r4, r5, r6, pc}
200021f6:	bf00      	nop
200021f8:	20006580 	.word	0x20006580
200021fc:	20006577 	.word	0x20006577
20002200:	200069f0 	.word	0x200069f0
20002204:	20005e35 	.word	0x20005e35

20002208 <Error_Handler>:
    total_section_length = 0;
}

static void Error_Handler(SPI_HandleTypeDef *hspi)
{
    wTransferState = TRANSFER_ERROR;
20002208:	4b10      	ldr	r3, [pc, #64]	; (2000224c <Error_Handler+0x44>)
    dst = FLASH_START;
    total_section_length = 0;
}

static void Error_Handler(SPI_HandleTypeDef *hspi)
{
2000220a:	b510      	push	{r4, lr}
    wTransferState = TRANSFER_ERROR;
2000220c:	2202      	movs	r2, #2
    dst = FLASH_START;
    total_section_length = 0;
}

static void Error_Handler(SPI_HandleTypeDef *hspi)
{
2000220e:	4604      	mov	r4, r0
    wTransferState = TRANSFER_ERROR;
    /* reset spi */
    mods_muc_set_spi1_cs(PIN_SET);
20002210:	2001      	movs	r0, #1
    total_section_length = 0;
}

static void Error_Handler(SPI_HandleTypeDef *hspi)
{
    wTransferState = TRANSFER_ERROR;
20002212:	601a      	str	r2, [r3, #0]
    /* reset spi */
    mods_muc_set_spi1_cs(PIN_SET);
20002214:	f7ff fbac 	bl	20001970 <mods_muc_set_spi1_cs>
    HAL_SPI_DeInit(hspi);
20002218:	4620      	mov	r0, r4
2000221a:	f001 ff28 	bl	2000406e <HAL_SPI_DeInit>
    dbgprint("SPI Flash DeInit\r\n");
2000221e:	480c      	ldr	r0, [pc, #48]	; (20002250 <Error_Handler+0x48>)
20002220:	f002 ff3e 	bl	200050a0 <dbgprint>
    device_spi_flash_init(hspi);
20002224:	4620      	mov	r0, r4
20002226:	f7ff fb7f 	bl	20001928 <device_spi_flash_init>
    dbgprint("SPI Flash Re-Init\r\n");
    memset(aTxBuffer_spiFlash, 0, MAX_DMA_BUF_SIZE);
2000222a:	f640 0402 	movw	r4, #2050	; 0x802
    /* reset spi */
    mods_muc_set_spi1_cs(PIN_SET);
    HAL_SPI_DeInit(hspi);
    dbgprint("SPI Flash DeInit\r\n");
    device_spi_flash_init(hspi);
    dbgprint("SPI Flash Re-Init\r\n");
2000222e:	4809      	ldr	r0, [pc, #36]	; (20002254 <Error_Handler+0x4c>)
20002230:	f002 ff36 	bl	200050a0 <dbgprint>
    memset(aTxBuffer_spiFlash, 0, MAX_DMA_BUF_SIZE);
20002234:	4622      	mov	r2, r4
20002236:	2100      	movs	r1, #0
20002238:	4807      	ldr	r0, [pc, #28]	; (20002258 <Error_Handler+0x50>)
2000223a:	f7fd ffcd 	bl	200001d8 <memset>
    memset(aRxBuffer_spiFlash, 0, MAX_DMA_BUF_SIZE);
2000223e:	4622      	mov	r2, r4
20002240:	4806      	ldr	r0, [pc, #24]	; (2000225c <Error_Handler+0x54>)
20002242:	2100      	movs	r1, #0
}
20002244:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_SPI_DeInit(hspi);
    dbgprint("SPI Flash DeInit\r\n");
    device_spi_flash_init(hspi);
    dbgprint("SPI Flash Re-Init\r\n");
    memset(aTxBuffer_spiFlash, 0, MAX_DMA_BUF_SIZE);
    memset(aRxBuffer_spiFlash, 0, MAX_DMA_BUF_SIZE);
20002248:	f7fd bfc6 	b.w	200001d8 <memset>
2000224c:	200069f8 	.word	0x200069f8
20002250:	200065ac 	.word	0x200065ac
20002254:	200065bf 	.word	0x200065bf
20002258:	200082e6 	.word	0x200082e6
2000225c:	20007ae4 	.word	0x20007ae4

20002260 <spi_flash_hal_init>:
static uint32_t dst = FLASH_START;
static uint32_t total_section_length;

void spi_flash_hal_init(void)
{
    device_spi_flash_init(&hspi_flash);
20002260:	4801      	ldr	r0, [pc, #4]	; (20002268 <spi_flash_hal_init+0x8>)
20002262:	f7ff bb61 	b.w	20001928 <device_spi_flash_init>
20002266:	bf00      	nop
20002268:	20006a00 	.word	0x20006a00

2000226c <spi_write_calc_total_len>:
}

int spi_write_calc_total_len(void *data)
{
    tftf_header *tf_header = (tftf_header *)data;
    tftf_section_descriptor *section = tf_header->sections;
2000226c:	f100 0370 	add.w	r3, r0, #112	; 0x70
    uint32_t num_sections = 0;

    total_section_length = 0;
    while (section->section_type != TFTF_SECTION_END) {
20002270:	2000      	movs	r0, #0
20002272:	781a      	ldrb	r2, [r3, #0]
20002274:	2afe      	cmp	r2, #254	; 0xfe
20002276:	d003      	beq.n	20002280 <spi_write_calc_total_len+0x14>
        total_section_length += section->section_length;
20002278:	689a      	ldr	r2, [r3, #8]
        num_sections++;
        section++;
2000227a:	3314      	adds	r3, #20
    tftf_section_descriptor *section = tf_header->sections;
    uint32_t num_sections = 0;

    total_section_length = 0;
    while (section->section_type != TFTF_SECTION_END) {
        total_section_length += section->section_length;
2000227c:	4410      	add	r0, r2
2000227e:	e7f8      	b.n	20002272 <spi_write_calc_total_len+0x6>
20002280:	4b01      	ldr	r3, [pc, #4]	; (20002288 <spi_write_calc_total_len+0x1c>)
20002282:	6018      	str	r0, [r3, #0]
    dbgprintx32("spi flash tftf num_sections ",  num_sections, "\r\n");
    dbgprintx32("spi flash tftf total_section_length ", total_section_length, "\r\n");
#endif

    return total_section_length;
}
20002284:	4770      	bx	lr
20002286:	bf00      	nop
20002288:	200069f4 	.word	0x200069f4

2000228c <spi_write_to_flash_header>:

int spi_write_to_flash_header(const data_write_ops *ops, void *data)
{
2000228c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int result = 0;
    tftf_header *tf_header = (tftf_header *)data;
    ffff_header tmp_header;
    const uint32_t header0_start = dst;
20002290:	4e57      	ldr	r6, [pc, #348]	; (200023f0 <spi_write_to_flash_header+0x164>)
    const uint32_t header1_start = header0_start + sizeof(tmp_header);
    const uint32_t tftf_start = header1_start + sizeof(tmp_header);

    result = ops->init();
20002292:	6803      	ldr	r3, [r0, #0]
int spi_write_to_flash_header(const data_write_ops *ops, void *data)
{
    int result = 0;
    tftf_header *tf_header = (tftf_header *)data;
    ffff_header tmp_header;
    const uint32_t header0_start = dst;
20002294:	6834      	ldr	r4, [r6, #0]

    return total_section_length;
}

int spi_write_to_flash_header(const data_write_ops *ops, void *data)
{
20002296:	f5ad 5d80 	sub.w	sp, sp, #4096	; 0x1000
2000229a:	b081      	sub	sp, #4
2000229c:	460d      	mov	r5, r1
2000229e:	4680      	mov	r8, r0
    ffff_header tmp_header;
    const uint32_t header0_start = dst;
    const uint32_t header1_start = header0_start + sizeof(tmp_header);
    const uint32_t tftf_start = header1_start + sizeof(tmp_header);

    result = ops->init();
200022a0:	4798      	blx	r3
200022a2:	46b1      	mov	r9, r6
    if (result) {
200022a4:	4601      	mov	r1, r0
200022a6:	2800      	cmp	r0, #0
200022a8:	f040 809c 	bne.w	200023e4 <spi_write_to_flash_header+0x158>
        goto error;
    }

    memset(&tmp_header, 0, sizeof(tmp_header));
200022ac:	4668      	mov	r0, sp
200022ae:	f44f 5280 	mov.w	r2, #4096	; 0x1000
200022b2:	f7fd ff91 	bl	200001d8 <memset>
    memcpy(tmp_header.sentinel_value, FFFF_SENTINEL_VALUE,
200022b6:	4b4f      	ldr	r3, [pc, #316]	; (200023f4 <spi_write_to_flash_header+0x168>)
{
    int result = 0;
    tftf_header *tf_header = (tftf_header *)data;
    ffff_header tmp_header;
    const uint32_t header0_start = dst;
    const uint32_t header1_start = header0_start + sizeof(tmp_header);
200022b8:	f504 5780 	add.w	r7, r4, #4096	; 0x1000
    const uint32_t tftf_start = header1_start + sizeof(tmp_header);
200022bc:	f504 5600 	add.w	r6, r4, #8192	; 0x2000
    if (result) {
        goto error;
    }

    memset(&tmp_header, 0, sizeof(tmp_header));
    memcpy(tmp_header.sentinel_value, FFFF_SENTINEL_VALUE,
200022c0:	46ee      	mov	lr, sp
200022c2:	f103 0c10 	add.w	ip, r3, #16
200022c6:	6818      	ldr	r0, [r3, #0]
200022c8:	6859      	ldr	r1, [r3, #4]
200022ca:	4672      	mov	r2, lr
200022cc:	c203      	stmia	r2!, {r0, r1}
200022ce:	3308      	adds	r3, #8
200022d0:	4563      	cmp	r3, ip
200022d2:	4696      	mov	lr, r2
200022d4:	d1f7      	bne.n	200022c6 <spi_write_to_flash_header+0x3a>
                                          sizeof(tmp_header.sentinel_value));
    memcpy(tmp_header.build_timestamp, tf_header->build_timestamp,
200022d6:	f105 0308 	add.w	r3, r5, #8
200022da:	f10d 0e10 	add.w	lr, sp, #16
200022de:	f105 0c18 	add.w	ip, r5, #24
200022e2:	6818      	ldr	r0, [r3, #0]
200022e4:	6859      	ldr	r1, [r3, #4]
200022e6:	4672      	mov	r2, lr
200022e8:	c203      	stmia	r2!, {r0, r1}
200022ea:	3308      	adds	r3, #8
200022ec:	4563      	cmp	r3, ip
200022ee:	4696      	mov	lr, r2
200022f0:	d1f7      	bne.n	200022e2 <spi_write_to_flash_header+0x56>
                                            sizeof(tmp_header.build_timestamp));
    memcpy(tmp_header.flash_image_name, tf_header->firmware_package_name,
200022f2:	f105 0318 	add.w	r3, r5, #24
200022f6:	f10d 0e20 	add.w	lr, sp, #32
200022fa:	f105 0c48 	add.w	ip, r5, #72	; 0x48
200022fe:	6818      	ldr	r0, [r3, #0]
20002300:	6859      	ldr	r1, [r3, #4]
20002302:	4672      	mov	r2, lr
20002304:	c203      	stmia	r2!, {r0, r1}
20002306:	3308      	adds	r3, #8
20002308:	4563      	cmp	r3, ip
2000230a:	4696      	mov	lr, r2
2000230c:	d1f7      	bne.n	200022fe <spi_write_to_flash_header+0x72>
                                               sizeof(tmp_header.flash_image_name));
    tmp_header.flash_capacity = ops->get_capacity();
2000230e:	f8d8 3018 	ldr.w	r3, [r8, #24]
20002312:	4798      	blx	r3
    tmp_header.erase_block_size = ops->get_erase_size();
20002314:	f8d8 301c 	ldr.w	r3, [r8, #28]
                                          sizeof(tmp_header.sentinel_value));
    memcpy(tmp_header.build_timestamp, tf_header->build_timestamp,
                                            sizeof(tmp_header.build_timestamp));
    memcpy(tmp_header.flash_image_name, tf_header->firmware_package_name,
                                               sizeof(tmp_header.flash_image_name));
    tmp_header.flash_capacity = ops->get_capacity();
20002318:	9014      	str	r0, [sp, #80]	; 0x50
    tmp_header.erase_block_size = ops->get_erase_size();
2000231a:	4798      	blx	r3
    tmp_header.header_size = sizeof(tmp_header);
2000231c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
20002320:	9316      	str	r3, [sp, #88]	; 0x58
    tmp_header.flash_image_length =
                   2 * sizeof(tmp_header) + sizeof(*tf_header) + total_section_length;
20002322:	4b35      	ldr	r3, [pc, #212]	; (200023f8 <spi_write_to_flash_header+0x16c>)
    memcpy(tmp_header.build_timestamp, tf_header->build_timestamp,
                                            sizeof(tmp_header.build_timestamp));
    memcpy(tmp_header.flash_image_name, tf_header->firmware_package_name,
                                               sizeof(tmp_header.flash_image_name));
    tmp_header.flash_capacity = ops->get_capacity();
    tmp_header.erase_block_size = ops->get_erase_size();
20002324:	9015      	str	r0, [sp, #84]	; 0x54
    tmp_header.header_size = sizeof(tmp_header);
    tmp_header.flash_image_length =
                   2 * sizeof(tmp_header) + sizeof(*tf_header) + total_section_length;
20002326:	681a      	ldr	r2, [r3, #0]
    tmp_header.header_generation = 1;
20002328:	2301      	movs	r3, #1
    tmp_header.elements[0].element_type = FFFF_ELEMENT_STAGE_2_FW;
2000232a:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
    tmp_header.elements[0].element_class = 0;
2000232e:	991d      	ldr	r1, [sp, #116]	; 0x74
    tmp_header.flash_capacity = ops->get_capacity();
    tmp_header.erase_block_size = ops->get_erase_size();
    tmp_header.header_size = sizeof(tmp_header);
    tmp_header.flash_image_length =
                   2 * sizeof(tmp_header) + sizeof(*tf_header) + total_section_length;
    tmp_header.header_generation = 1;
20002330:	9318      	str	r3, [sp, #96]	; 0x60
    tmp_header.elements[0].element_type = FFFF_ELEMENT_STAGE_2_FW;
    tmp_header.elements[0].element_class = 0;
20002332:	f36f 211f 	bfc	r1, #8, #24
20002336:	911d      	str	r1, [sp, #116]	; 0x74
    tmp_header.elements[0].element_id = 1;
20002338:	931e      	str	r3, [sp, #120]	; 0x78
    tmp_header.elements[0].element_length = sizeof(*tf_header) + total_section_length;
    tmp_header.elements[0].element_location = tftf_start - dst;
2000233a:	f8d9 c000 	ldr.w	ip, [r9]
    tmp_header.elements[0].element_generation = 1;
2000233e:	9321      	str	r3, [sp, #132]	; 0x84
    tmp_header.elements[1].element_type = FFFF_ELEMENT_END;
20002340:	23fe      	movs	r3, #254	; 0xfe
                                               sizeof(tmp_header.flash_image_name));
    tmp_header.flash_capacity = ops->get_capacity();
    tmp_header.erase_block_size = ops->get_erase_size();
    tmp_header.header_size = sizeof(tmp_header);
    tmp_header.flash_image_length =
                   2 * sizeof(tmp_header) + sizeof(*tf_header) + total_section_length;
20002342:	f502 5e08 	add.w	lr, r2, #8704	; 0x2200
    tmp_header.elements[0].element_class = 0;
    tmp_header.elements[0].element_id = 1;
    tmp_header.elements[0].element_length = sizeof(*tf_header) + total_section_length;
    tmp_header.elements[0].element_location = tftf_start - dst;
    tmp_header.elements[0].element_generation = 1;
    tmp_header.elements[1].element_type = FFFF_ELEMENT_END;
20002346:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
                   2 * sizeof(tmp_header) + sizeof(*tf_header) + total_section_length;
    tmp_header.header_generation = 1;
    tmp_header.elements[0].element_type = FFFF_ELEMENT_STAGE_2_FW;
    tmp_header.elements[0].element_class = 0;
    tmp_header.elements[0].element_id = 1;
    tmp_header.elements[0].element_length = sizeof(*tf_header) + total_section_length;
2000234a:	f502 7200 	add.w	r2, r2, #512	; 0x200
    tmp_header.elements[0].element_location = tftf_start - dst;
    tmp_header.elements[0].element_generation = 1;
    tmp_header.elements[1].element_type = FFFF_ELEMENT_END;
    memcpy(tmp_header.trailing_sentinel_value, FFFF_SENTINEL_VALUE,
2000234e:	4b29      	ldr	r3, [pc, #164]	; (200023f4 <spi_write_to_flash_header+0x168>)
                   2 * sizeof(tmp_header) + sizeof(*tf_header) + total_section_length;
    tmp_header.header_generation = 1;
    tmp_header.elements[0].element_type = FFFF_ELEMENT_STAGE_2_FW;
    tmp_header.elements[0].element_class = 0;
    tmp_header.elements[0].element_id = 1;
    tmp_header.elements[0].element_length = sizeof(*tf_header) + total_section_length;
20002350:	921f      	str	r2, [sp, #124]	; 0x7c
    tmp_header.elements[0].element_location = tftf_start - dst;
20002352:	ebcc 0206 	rsb	r2, ip, r6
    memcpy(tmp_header.flash_image_name, tf_header->firmware_package_name,
                                               sizeof(tmp_header.flash_image_name));
    tmp_header.flash_capacity = ops->get_capacity();
    tmp_header.erase_block_size = ops->get_erase_size();
    tmp_header.header_size = sizeof(tmp_header);
    tmp_header.flash_image_length =
20002356:	f8cd e05c 	str.w	lr, [sp, #92]	; 0x5c
    tmp_header.header_generation = 1;
    tmp_header.elements[0].element_type = FFFF_ELEMENT_STAGE_2_FW;
    tmp_header.elements[0].element_class = 0;
    tmp_header.elements[0].element_id = 1;
    tmp_header.elements[0].element_length = sizeof(*tf_header) + total_section_length;
    tmp_header.elements[0].element_location = tftf_start - dst;
2000235a:	9220      	str	r2, [sp, #128]	; 0x80
    tmp_header.elements[0].element_generation = 1;
    tmp_header.elements[1].element_type = FFFF_ELEMENT_END;
    memcpy(tmp_header.trailing_sentinel_value, FFFF_SENTINEL_VALUE,
2000235c:	f50d 6a7f 	add.w	sl, sp, #4080	; 0xff0
20002360:	f103 0b10 	add.w	fp, r3, #16
20002364:	6818      	ldr	r0, [r3, #0]
20002366:	6859      	ldr	r1, [r3, #4]
20002368:	4652      	mov	r2, sl
2000236a:	c203      	stmia	r2!, {r0, r1}
2000236c:	3308      	adds	r3, #8
2000236e:	455b      	cmp	r3, fp
20002370:	4692      	mov	sl, r2
20002372:	d1f7      	bne.n	20002364 <spi_write_to_flash_header+0xd8>
                                          sizeof(tmp_header.trailing_sentinel_value));

    ops->erase(dst, tmp_header.flash_image_length);
20002374:	4671      	mov	r1, lr
20002376:	4660      	mov	r0, ip
20002378:	f8d8 3008 	ldr.w	r3, [r8, #8]
2000237c:	4798      	blx	r3
    ops->write(header0_start, &tmp_header, sizeof(tmp_header));
2000237e:	f8d8 300c 	ldr.w	r3, [r8, #12]
20002382:	4620      	mov	r0, r4
20002384:	4669      	mov	r1, sp
20002386:	f44f 5280 	mov.w	r2, #4096	; 0x1000
2000238a:	4798      	blx	r3
    result |= ops->verify(header0_start, &tmp_header, sizeof(tmp_header));
2000238c:	f8d8 3010 	ldr.w	r3, [r8, #16]
20002390:	4620      	mov	r0, r4
20002392:	4669      	mov	r1, sp
20002394:	f44f 5280 	mov.w	r2, #4096	; 0x1000
20002398:	4798      	blx	r3

    ops->write(header1_start, &tmp_header, sizeof(tmp_header));
2000239a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    memcpy(tmp_header.trailing_sentinel_value, FFFF_SENTINEL_VALUE,
                                          sizeof(tmp_header.trailing_sentinel_value));

    ops->erase(dst, tmp_header.flash_image_length);
    ops->write(header0_start, &tmp_header, sizeof(tmp_header));
    result |= ops->verify(header0_start, &tmp_header, sizeof(tmp_header));
2000239e:	4682      	mov	sl, r0

    ops->write(header1_start, &tmp_header, sizeof(tmp_header));
200023a0:	4669      	mov	r1, sp
200023a2:	4638      	mov	r0, r7
200023a4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
200023a8:	4798      	blx	r3
    result |= ops->verify(header1_start, &tmp_header, sizeof(tmp_header));
200023aa:	f8d8 3010 	ldr.w	r3, [r8, #16]
200023ae:	4638      	mov	r0, r7
200023b0:	4669      	mov	r1, sp
200023b2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
200023b6:	4798      	blx	r3

    ops->write(tftf_start, tf_header, sizeof(*tf_header));
200023b8:	f8d8 300c 	ldr.w	r3, [r8, #12]
    ops->erase(dst, tmp_header.flash_image_length);
    ops->write(header0_start, &tmp_header, sizeof(tmp_header));
    result |= ops->verify(header0_start, &tmp_header, sizeof(tmp_header));

    ops->write(header1_start, &tmp_header, sizeof(tmp_header));
    result |= ops->verify(header1_start, &tmp_header, sizeof(tmp_header));
200023bc:	ea40 070a 	orr.w	r7, r0, sl

    ops->write(tftf_start, tf_header, sizeof(*tf_header));
200023c0:	4629      	mov	r1, r5
200023c2:	f44f 7200 	mov.w	r2, #512	; 0x200
200023c6:	4630      	mov	r0, r6
200023c8:	4798      	blx	r3
    result |= ops->verify(tftf_start, tf_header, sizeof(*tf_header));
200023ca:	4629      	mov	r1, r5
200023cc:	f8d8 3010 	ldr.w	r3, [r8, #16]
200023d0:	4630      	mov	r0, r6
200023d2:	f44f 7200 	mov.w	r2, #512	; 0x200
200023d6:	4798      	blx	r3

    dst = tftf_start + sizeof(*tf_header);
200023d8:	f504 5408 	add.w	r4, r4, #8704	; 0x2200

    ops->write(header1_start, &tmp_header, sizeof(tmp_header));
    result |= ops->verify(header1_start, &tmp_header, sizeof(tmp_header));

    ops->write(tftf_start, tf_header, sizeof(*tf_header));
    result |= ops->verify(tftf_start, tf_header, sizeof(*tf_header));
200023dc:	ea47 0100 	orr.w	r1, r7, r0

    dst = tftf_start + sizeof(*tf_header);
200023e0:	f8c9 4000 	str.w	r4, [r9]
error:
    return result;
}
200023e4:	4608      	mov	r0, r1
200023e6:	f50d 5d80 	add.w	sp, sp, #4096	; 0x1000
200023ea:	b001      	add	sp, #4
200023ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
200023f0:	200069fc 	.word	0x200069fc
200023f4:	200065d3 	.word	0x200065d3
200023f8:	200069f4 	.word	0x200069f4

200023fc <spi_write_to_flash_data>:

int spi_write_to_flash_data(const data_write_ops *ops, void *src, uint32_t len)
{
200023fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = 0;

#ifdef CONFIG_DEBUG_SPI_FLASH
    dbgprintx32("spi_write_to_flash_data dst ", dst, "\r\n");
#endif
    ops->write(dst, src, len);
200023fe:	4c08      	ldr	r4, [pc, #32]	; (20002420 <spi_write_to_flash_data+0x24>)
20002400:	68c3      	ldr	r3, [r0, #12]
error:
    return result;
}

int spi_write_to_flash_data(const data_write_ops *ops, void *src, uint32_t len)
{
20002402:	4606      	mov	r6, r0
20002404:	4615      	mov	r5, r2
20002406:	460f      	mov	r7, r1
    int result = 0;

#ifdef CONFIG_DEBUG_SPI_FLASH
    dbgprintx32("spi_write_to_flash_data dst ", dst, "\r\n");
#endif
    ops->write(dst, src, len);
20002408:	6820      	ldr	r0, [r4, #0]
2000240a:	4798      	blx	r3
    result = ops->verify(dst, src, len);
2000240c:	462a      	mov	r2, r5
2000240e:	6933      	ldr	r3, [r6, #16]
20002410:	6820      	ldr	r0, [r4, #0]
20002412:	4639      	mov	r1, r7
20002414:	4798      	blx	r3

    dst += len;
20002416:	6822      	ldr	r2, [r4, #0]
20002418:	442a      	add	r2, r5
2000241a:	6022      	str	r2, [r4, #0]
    return result;
}
2000241c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000241e:	bf00      	nop
20002420:	200069fc 	.word	0x200069fc

20002424 <spi_write_to_flash_finish>:

void spi_write_to_flash_finish(const data_write_ops *ops)
{
20002424:	b510      	push	{r4, lr}
20002426:	4604      	mov	r4, r0
    dbgprint("spi_write_to_flash_finish\r\n");
20002428:	4805      	ldr	r0, [pc, #20]	; (20002440 <spi_write_to_flash_finish+0x1c>)
2000242a:	f002 fe39 	bl	200050a0 <dbgprint>
    ops->finish();
2000242e:	6963      	ldr	r3, [r4, #20]
20002430:	4798      	blx	r3
    dst = FLASH_START;
20002432:	4a04      	ldr	r2, [pc, #16]	; (20002444 <spi_write_to_flash_finish+0x20>)
20002434:	2300      	movs	r3, #0
20002436:	6013      	str	r3, [r2, #0]
    total_section_length = 0;
20002438:	4a03      	ldr	r2, [pc, #12]	; (20002448 <spi_write_to_flash_finish+0x24>)
2000243a:	6013      	str	r3, [r2, #0]
2000243c:	bd10      	pop	{r4, pc}
2000243e:	bf00      	nop
20002440:	200065e4 	.word	0x200065e4
20002444:	200069fc 	.word	0x200069fc
20002448:	200069f4 	.word	0x200069f4

2000244c <spi_flash_transfer_complete>:
void spi_flash_transfer_complete(SPI_HandleTypeDef *_hspi)
{
#ifdef CONFIG_DEBUG_SPI_FLASH
  dbgprint("spi_flash_transfer_complete\r\n");
#endif
  wTransferState = TRANSFER_COMPLETE;
2000244c:	4b01      	ldr	r3, [pc, #4]	; (20002454 <spi_flash_transfer_complete+0x8>)
2000244e:	2201      	movs	r2, #1
20002450:	601a      	str	r2, [r3, #0]
20002452:	4770      	bx	lr
20002454:	200069f8 	.word	0x200069f8

20002458 <spi_flash_error_handler>:
}

void spi_flash_error_handler(SPI_HandleTypeDef *_hspi)
{
20002458:	b510      	push	{r4, lr}
2000245a:	4604      	mov	r4, r0
    dbgprint("spi_flash_transfer_error\r\n");
2000245c:	4803      	ldr	r0, [pc, #12]	; (2000246c <spi_flash_error_handler+0x14>)
2000245e:	f002 fe1f 	bl	200050a0 <dbgprint>
    Error_Handler(_hspi);
20002462:	4620      	mov	r0, r4
}
20002464:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

void spi_flash_error_handler(SPI_HandleTypeDef *_hspi)
{
    dbgprint("spi_flash_transfer_error\r\n");
    Error_Handler(_hspi);
20002468:	f7ff bece 	b.w	20002208 <Error_Handler>
2000246c:	20006600 	.word	0x20006600

20002470 <chip_spi_exchange>:
 * @param txbuffer pointer to the data to send
 * @param rxbuffer pointer to the buffer to receive data into
 * @param nbytes number of bytes to exchange,
 * @return 0 on success, negative errno on error
 */
int chip_spi_exchange(void *txbuffer, void *rxbuffer, uint32_t nbytes) {
20002470:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
20002474:	4680      	mov	r8, r0
20002476:	4689      	mov	r9, r1
20002478:	4615      	mov	r5, r2

    uint32_t len;
    int remaining_bytes = nbytes;
    int buf_offset = 0;
2000247a:	2600      	movs	r6, #0

    while (remaining_bytes > 0) {
2000247c:	2d00      	cmp	r5, #0
2000247e:	dd3c      	ble.n	200024fa <chip_spi_exchange+0x8a>

        memset(aTxBuffer_spiFlash, 0, MAX_DMA_BUF_SIZE);
20002480:	f640 0402 	movw	r4, #2050	; 0x802
20002484:	4622      	mov	r2, r4
20002486:	2100      	movs	r1, #0
20002488:	481f      	ldr	r0, [pc, #124]	; (20002508 <chip_spi_exchange+0x98>)
2000248a:	f7fd fea5 	bl	200001d8 <memset>
        memset(aRxBuffer_spiFlash, 0, MAX_DMA_BUF_SIZE);
2000248e:	4622      	mov	r2, r4
20002490:	2100      	movs	r1, #0
20002492:	481e      	ldr	r0, [pc, #120]	; (2000250c <chip_spi_exchange+0x9c>)
20002494:	f7fd fea0 	bl	200001d8 <memset>
        len = MIN(remaining_bytes, MAX_DMA_BUF_SIZE);
20002498:	42ac      	cmp	r4, r5
2000249a:	bfa8      	it	ge
2000249c:	462c      	movge	r4, r5
        memcpy(aTxBuffer_spiFlash, txbuffer + buf_offset, len);
2000249e:	eb08 0106 	add.w	r1, r8, r6
200024a2:	4622      	mov	r2, r4
200024a4:	4818      	ldr	r0, [pc, #96]	; (20002508 <chip_spi_exchange+0x98>)
200024a6:	f003 fbed 	bl	20005c84 <memcpy>
        mods_muc_set_spi1_cs(PIN_RESET);
200024aa:	2000      	movs	r0, #0
200024ac:	f7ff fa60 	bl	20001970 <mods_muc_set_spi1_cs>

        if(HAL_SPI_TransmitReceive_DMA(&hspi_flash, (uint8_t*)aTxBuffer_spiFlash,
200024b0:	4817      	ldr	r0, [pc, #92]	; (20002510 <chip_spi_exchange+0xa0>)
200024b2:	4915      	ldr	r1, [pc, #84]	; (20002508 <chip_spi_exchange+0x98>)
200024b4:	4a15      	ldr	r2, [pc, #84]	; (2000250c <chip_spi_exchange+0x9c>)
200024b6:	b2a3      	uxth	r3, r4
200024b8:	f001 fdef 	bl	2000409a <HAL_SPI_TransmitReceive_DMA>
200024bc:	b118      	cbz	r0, 200024c6 <chip_spi_exchange+0x56>
                (uint8_t *)aRxBuffer_spiFlash, len) != HAL_OK) {
            /* Transfer error in transmission process */
            dbgprint("chip_spi_exchange HAL_SPI_TransmitReceive_DMA error\r\n");
200024be:	4815      	ldr	r0, [pc, #84]	; (20002514 <chip_spi_exchange+0xa4>)
200024c0:	f002 fdee 	bl	200050a0 <dbgprint>
200024c4:	e012      	b.n	200024ec <chip_spi_exchange+0x7c>
            Error_Handler(&hspi_flash);
            return -EIO;
        }
        /* wait for TxRx to complete */
        while (wTransferState == TRANSFER_WAIT) {
200024c6:	4f14      	ldr	r7, [pc, #80]	; (20002518 <chip_spi_exchange+0xa8>)
200024c8:	683b      	ldr	r3, [r7, #0]
200024ca:	2b00      	cmp	r3, #0
200024cc:	d0fb      	beq.n	200024c6 <chip_spi_exchange+0x56>
    return 0;
}

void chip_delay(uint32_t msec)
{
    HAL_Delay(msec);
200024ce:	2005      	movs	r0, #5
200024d0:	f001 f9c4 	bl	2000385c <HAL_Delay>
        }
        /* wait for TxRx to complete */
        while (wTransferState == TRANSFER_WAIT) {
        }
        chip_delay(5);
        if (wTransferState == TRANSFER_COMPLETE) {
200024d4:	683b      	ldr	r3, [r7, #0]
200024d6:	2b01      	cmp	r3, #1
200024d8:	d108      	bne.n	200024ec <chip_spi_exchange+0x7c>
            memcpy(rxbuffer + buf_offset, aRxBuffer_spiFlash, len);
200024da:	eb09 0006 	add.w	r0, r9, r6
200024de:	490b      	ldr	r1, [pc, #44]	; (2000250c <chip_spi_exchange+0x9c>)
200024e0:	4622      	mov	r2, r4
200024e2:	f003 fbcf 	bl	20005c84 <memcpy>
        } else {
           Error_Handler(&hspi_flash);
           return -EIO;
        }
        remaining_bytes -= len;
200024e6:	1b2d      	subs	r5, r5, r4
        buf_offset += len;
200024e8:	4426      	add	r6, r4
200024ea:	e7c7      	b.n	2000247c <chip_spi_exchange+0xc>
        }
        chip_delay(5);
        if (wTransferState == TRANSFER_COMPLETE) {
            memcpy(rxbuffer + buf_offset, aRxBuffer_spiFlash, len);
        } else {
           Error_Handler(&hspi_flash);
200024ec:	4808      	ldr	r0, [pc, #32]	; (20002510 <chip_spi_exchange+0xa0>)
200024ee:	f7ff fe8b 	bl	20002208 <Error_Handler>
           return -EIO;
200024f2:	f06f 0004 	mvn.w	r0, #4
200024f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        }
        remaining_bytes -= len;
        buf_offset += len;
    }
    mods_muc_set_spi1_cs(PIN_SET);
200024fa:	2001      	movs	r0, #1
200024fc:	f7ff fa38 	bl	20001970 <mods_muc_set_spi1_cs>
    return 0;
20002500:	2000      	movs	r0, #0
}
20002502:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
20002506:	bf00      	nop
20002508:	200082e6 	.word	0x200082e6
2000250c:	20007ae4 	.word	0x20007ae4
20002510:	20006a00 	.word	0x20006a00
20002514:	2000661b 	.word	0x2000661b
20002518:	200069f8 	.word	0x200069f8

2000251c <chip_delay>:

void chip_delay(uint32_t msec)
{
    HAL_Delay(msec);
2000251c:	f001 b99e 	b.w	2000385c <HAL_Delay>

20002520 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange : MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
20002520:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
20002522:	4d1e      	ldr	r5, [pc, #120]	; (2000259c <RCC_SetFlashLatencyFromMSIRange+0x7c>)
20002524:	6dab      	ldr	r3, [r5, #88]	; 0x58
20002526:	00d9      	lsls	r1, r3, #3
            voltage range.
  * @param  msirange : MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
20002528:	4604      	mov	r4, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
2000252a:	d502      	bpl.n	20002532 <RCC_SetFlashLatencyFromMSIRange+0x12>
  {
    vos = HAL_PWREx_GetVoltageRange();
2000252c:	f002 fd9e 	bl	2000506c <HAL_PWREx_GetVoltageRange>
20002530:	e00e      	b.n	20002550 <RCC_SetFlashLatencyFromMSIRange+0x30>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
20002532:	6dab      	ldr	r3, [r5, #88]	; 0x58
20002534:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20002538:	65ab      	str	r3, [r5, #88]	; 0x58
2000253a:	6dab      	ldr	r3, [r5, #88]	; 0x58
2000253c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20002540:	9301      	str	r3, [sp, #4]
20002542:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
20002544:	f002 fd92 	bl	2000506c <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
20002548:	6dab      	ldr	r3, [r5, #88]	; 0x58
2000254a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2000254e:	65ab      	str	r3, [r5, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
20002550:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
20002554:	d106      	bne.n	20002564 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    if(msirange > RCC_MSIRANGE_8)
20002556:	2c80      	cmp	r4, #128	; 0x80
20002558:	d90c      	bls.n	20002574 <RCC_SetFlashLatencyFromMSIRange+0x54>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
2000255a:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
2000255c:	bf8c      	ite	hi
2000255e:	2302      	movhi	r3, #2
20002560:	2301      	movls	r3, #1
20002562:	e00c      	b.n	2000257e <RCC_SetFlashLatencyFromMSIRange+0x5e>
    }
    /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
  }
  else
  {
    if(msirange > RCC_MSIRANGE_8)
20002564:	2c80      	cmp	r4, #128	; 0x80
20002566:	d807      	bhi.n	20002578 <RCC_SetFlashLatencyFromMSIRange+0x58>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
20002568:	d008      	beq.n	2000257c <RCC_SetFlashLatencyFromMSIRange+0x5c>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if(msirange == RCC_MSIRANGE_7) 
2000256a:	f1a4 0270 	sub.w	r2, r4, #112	; 0x70
2000256e:	4253      	negs	r3, r2
20002570:	4153      	adcs	r3, r2
20002572:	e004      	b.n	2000257e <RCC_SetFlashLatencyFromMSIRange+0x5e>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
20002574:	2300      	movs	r3, #0
20002576:	e002      	b.n	2000257e <RCC_SetFlashLatencyFromMSIRange+0x5e>
  else
  {
    if(msirange > RCC_MSIRANGE_8)
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
20002578:	2303      	movs	r3, #3
2000257a:	e000      	b.n	2000257e <RCC_SetFlashLatencyFromMSIRange+0x5e>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
2000257c:	2302      	movs	r3, #2
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
  }
       
  __HAL_FLASH_SET_LATENCY(latency);
2000257e:	4908      	ldr	r1, [pc, #32]	; (200025a0 <RCC_SetFlashLatencyFromMSIRange+0x80>)
20002580:	680a      	ldr	r2, [r1, #0]
20002582:	f022 0207 	bic.w	r2, r2, #7
20002586:	431a      	orrs	r2, r3
20002588:	600a      	str	r2, [r1, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
2000258a:	6808      	ldr	r0, [r1, #0]
2000258c:	f000 0007 	and.w	r0, r0, #7
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
20002590:	1ac0      	subs	r0, r0, r3
20002592:	bf18      	it	ne
20002594:	2001      	movne	r0, #1
20002596:	b003      	add	sp, #12
20002598:	bd30      	pop	{r4, r5, pc}
2000259a:	bf00      	nop
2000259c:	40021000 	.word	0x40021000
200025a0:	40022000 	.word	0x40022000

200025a4 <HAL_RCC_DeInit>:
  * @retval None
  */
void HAL_RCC_DeInit(void)
{
  /* Set MSION bit */
  SET_BIT(RCC->CR, RCC_CR_MSION);
200025a4:	4b0f      	ldr	r3, [pc, #60]	; (200025e4 <HAL_RCC_DeInit+0x40>)

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
200025a6:	4910      	ldr	r1, [pc, #64]	; (200025e8 <HAL_RCC_DeInit+0x44>)
  * @retval None
  */
void HAL_RCC_DeInit(void)
{
  /* Set MSION bit */
  SET_BIT(RCC->CR, RCC_CR_MSION);
200025a8:	681a      	ldr	r2, [r3, #0]
200025aa:	f042 0201 	orr.w	r2, r2, #1
200025ae:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);
200025b0:	2200      	movs	r2, #0
200025b2:	609a      	str	r2, [r3, #8]

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
200025b4:	6818      	ldr	r0, [r3, #0]
200025b6:	4001      	ands	r1, r0
200025b8:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  CLEAR_REG(RCC->PLLCFGR);
200025ba:	60da      	str	r2, [r3, #12]
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );
200025bc:	68d9      	ldr	r1, [r3, #12]
200025be:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
200025c2:	60d9      	str	r1, [r3, #12]

  /* Reset PLLSAI1CFGR register */
  CLEAR_REG(RCC->PLLSAI1CFGR);
200025c4:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );
200025c6:	6919      	ldr	r1, [r3, #16]
200025c8:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
200025cc:	6119      	str	r1, [r3, #16]

    /* Reset PLLSAI2CFGR register */
  CLEAR_REG(RCC->PLLSAI2CFGR);
200025ce:	615a      	str	r2, [r3, #20]
  SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );
200025d0:	6959      	ldr	r1, [r3, #20]
200025d2:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
200025d6:	6159      	str	r1, [r3, #20]

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
200025d8:	6819      	ldr	r1, [r3, #0]
200025da:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
200025de:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
200025e0:	619a      	str	r2, [r3, #24]
200025e2:	4770      	bx	lr
200025e4:	40021000 	.word	0x40021000
200025e8:	eaf6f4ff 	.word	0xeaf6f4ff

200025ec <HAL_RCC_OscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
200025ec:	6803      	ldr	r3, [r0, #0]
200025ee:	06db      	lsls	r3, r3, #27
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
200025f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
200025f2:	4605      	mov	r5, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
200025f4:	f140 80a1 	bpl.w	2000273a <HAL_RCC_OscConfig+0x14e>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
200025f8:	4ca0      	ldr	r4, [pc, #640]	; (2000287c <HAL_RCC_OscConfig+0x290>)
200025fa:	68a3      	ldr	r3, [r4, #8]
200025fc:	f013 0f0c 	tst.w	r3, #12
20002600:	d14f      	bne.n	200026a2 <HAL_RCC_OscConfig+0xb6>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
20002602:	2302      	movs	r3, #2
20002604:	fa93 f2a3 	rbit	r2, r3
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
20002608:	6822      	ldr	r2, [r4, #0]
2000260a:	fa93 f3a3 	rbit	r3, r3
2000260e:	fab3 f383 	clz	r3, r3
20002612:	f003 031f 	and.w	r3, r3, #31
20002616:	fa22 f303 	lsr.w	r3, r2, r3
2000261a:	07df      	lsls	r7, r3, #31
2000261c:	d503      	bpl.n	20002626 <HAL_RCC_OscConfig+0x3a>
2000261e:	6983      	ldr	r3, [r0, #24]
20002620:	b90b      	cbnz	r3, 20002626 <HAL_RCC_OscConfig+0x3a>
      {
        return HAL_ERROR;
20002622:	2001      	movs	r0, #1
20002624:	e36c      	b.n	20002d00 <HAL_RCC_OscConfig+0x714>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
20002626:	6822      	ldr	r2, [r4, #0]
20002628:	4b94      	ldr	r3, [pc, #592]	; (2000287c <HAL_RCC_OscConfig+0x290>)
2000262a:	6a28      	ldr	r0, [r5, #32]
2000262c:	0716      	lsls	r6, r2, #28
2000262e:	bf55      	itete	pl
20002630:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
20002634:	681b      	ldrmi	r3, [r3, #0]
20002636:	f403 6370 	andpl.w	r3, r3, #3840	; 0xf00
2000263a:	f003 03f0 	andmi.w	r3, r3, #240	; 0xf0
2000263e:	bf58      	it	pl
20002640:	091b      	lsrpl	r3, r3, #4
20002642:	4298      	cmp	r0, r3
20002644:	d915      	bls.n	20002672 <HAL_RCC_OscConfig+0x86>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
20002646:	f7ff ff6b 	bl	20002520 <RCC_SetFlashLatencyFromMSIRange>
2000264a:	2800      	cmp	r0, #0
2000264c:	d1e9      	bne.n	20002622 <HAL_RCC_OscConfig+0x36>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
2000264e:	6823      	ldr	r3, [r4, #0]
20002650:	f043 0308 	orr.w	r3, r3, #8
20002654:	6023      	str	r3, [r4, #0]
20002656:	6823      	ldr	r3, [r4, #0]
20002658:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
2000265c:	6a2b      	ldr	r3, [r5, #32]
2000265e:	4313      	orrs	r3, r2
20002660:	6023      	str	r3, [r4, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
20002662:	6863      	ldr	r3, [r4, #4]
20002664:	69ea      	ldr	r2, [r5, #28]
20002666:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
2000266a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
2000266e:	6063      	str	r3, [r4, #4]
20002670:	e013      	b.n	2000269a <HAL_RCC_OscConfig+0xae>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
20002672:	6823      	ldr	r3, [r4, #0]
20002674:	f043 0308 	orr.w	r3, r3, #8
20002678:	6023      	str	r3, [r4, #0]
2000267a:	6823      	ldr	r3, [r4, #0]
2000267c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
20002680:	4303      	orrs	r3, r0
20002682:	6023      	str	r3, [r4, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
20002684:	6863      	ldr	r3, [r4, #4]
20002686:	69ea      	ldr	r2, [r5, #28]
20002688:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
2000268c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
20002690:	6063      	str	r3, [r4, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
20002692:	f7ff ff45 	bl	20002520 <RCC_SetFlashLatencyFromMSIRange>
20002696:	2800      	cmp	r0, #0
20002698:	d1c3      	bne.n	20002622 <HAL_RCC_OscConfig+0x36>
            return HAL_ERROR;
          }          
        }

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
2000269a:	2000      	movs	r0, #0
2000269c:	f001 f8ac 	bl	200037f8 <HAL_InitTick>
200026a0:	e04b      	b.n	2000273a <HAL_RCC_OscConfig+0x14e>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
200026a2:	6983      	ldr	r3, [r0, #24]
200026a4:	b373      	cbz	r3, 20002704 <HAL_RCC_OscConfig+0x118>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
200026a6:	6823      	ldr	r3, [r4, #0]
200026a8:	f043 0301 	orr.w	r3, r3, #1
200026ac:	6023      	str	r3, [r4, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
200026ae:	f001 f8cf 	bl	20003850 <HAL_GetTick>
200026b2:	4606      	mov	r6, r0
200026b4:	2302      	movs	r3, #2
200026b6:	fa93 f2a3 	rbit	r2, r3

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
200026ba:	4a70      	ldr	r2, [pc, #448]	; (2000287c <HAL_RCC_OscConfig+0x290>)
200026bc:	6821      	ldr	r1, [r4, #0]
200026be:	fa93 f3a3 	rbit	r3, r3
200026c2:	fab3 f383 	clz	r3, r3
200026c6:	f003 031f 	and.w	r3, r3, #31
200026ca:	fa21 f303 	lsr.w	r3, r1, r3
200026ce:	07d9      	lsls	r1, r3, #31
200026d0:	d406      	bmi.n	200026e0 <HAL_RCC_OscConfig+0xf4>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
200026d2:	f001 f8bd 	bl	20003850 <HAL_GetTick>
200026d6:	1b80      	subs	r0, r0, r6
200026d8:	2864      	cmp	r0, #100	; 0x64
200026da:	d9eb      	bls.n	200026b4 <HAL_RCC_OscConfig+0xc8>
          {
            return HAL_TIMEOUT;
200026dc:	2003      	movs	r0, #3
200026de:	e30f      	b.n	20002d00 <HAL_RCC_OscConfig+0x714>
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
200026e0:	6813      	ldr	r3, [r2, #0]
200026e2:	f043 0308 	orr.w	r3, r3, #8
200026e6:	6013      	str	r3, [r2, #0]
200026e8:	6813      	ldr	r3, [r2, #0]
200026ea:	f023 01f0 	bic.w	r1, r3, #240	; 0xf0
200026ee:	6a2b      	ldr	r3, [r5, #32]
200026f0:	430b      	orrs	r3, r1
200026f2:	6013      	str	r3, [r2, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
200026f4:	6853      	ldr	r3, [r2, #4]
200026f6:	69e9      	ldr	r1, [r5, #28]
200026f8:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
200026fc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
20002700:	6053      	str	r3, [r2, #4]
20002702:	e01a      	b.n	2000273a <HAL_RCC_OscConfig+0x14e>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
20002704:	6823      	ldr	r3, [r4, #0]
20002706:	f023 0301 	bic.w	r3, r3, #1
2000270a:	6023      	str	r3, [r4, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
2000270c:	f001 f8a0 	bl	20003850 <HAL_GetTick>
20002710:	4606      	mov	r6, r0
20002712:	2302      	movs	r3, #2
20002714:	fa93 f2a3 	rbit	r2, r3

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
20002718:	6822      	ldr	r2, [r4, #0]
2000271a:	fa93 f3a3 	rbit	r3, r3
2000271e:	fab3 f383 	clz	r3, r3
20002722:	f003 031f 	and.w	r3, r3, #31
20002726:	fa22 f303 	lsr.w	r3, r2, r3
2000272a:	07db      	lsls	r3, r3, #31
2000272c:	d505      	bpl.n	2000273a <HAL_RCC_OscConfig+0x14e>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
2000272e:	f001 f88f 	bl	20003850 <HAL_GetTick>
20002732:	1b80      	subs	r0, r0, r6
20002734:	2864      	cmp	r0, #100	; 0x64
20002736:	d9ec      	bls.n	20002712 <HAL_RCC_OscConfig+0x126>
20002738:	e7d0      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
2000273a:	682b      	ldr	r3, [r5, #0]
2000273c:	07df      	lsls	r7, r3, #31
2000273e:	d404      	bmi.n	2000274a <HAL_RCC_OscConfig+0x15e>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
20002740:	682b      	ldr	r3, [r5, #0]
20002742:	079e      	lsls	r6, r3, #30
20002744:	f100 809c 	bmi.w	20002880 <HAL_RCC_OscConfig+0x294>
20002748:	e114      	b.n	20002974 <HAL_RCC_OscConfig+0x388>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
2000274a:	4c4c      	ldr	r4, [pc, #304]	; (2000287c <HAL_RCC_OscConfig+0x290>)
2000274c:	68a3      	ldr	r3, [r4, #8]
2000274e:	f003 030c 	and.w	r3, r3, #12
20002752:	2b08      	cmp	r3, #8
20002754:	d009      	beq.n	2000276a <HAL_RCC_OscConfig+0x17e>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
20002756:	68a3      	ldr	r3, [r4, #8]
20002758:	f003 030c 	and.w	r3, r3, #12
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
2000275c:	2b0c      	cmp	r3, #12
2000275e:	d117      	bne.n	20002790 <HAL_RCC_OscConfig+0x1a4>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
20002760:	68e3      	ldr	r3, [r4, #12]
20002762:	f003 0303 	and.w	r3, r3, #3
20002766:	2b03      	cmp	r3, #3
20002768:	d112      	bne.n	20002790 <HAL_RCC_OscConfig+0x1a4>
2000276a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
2000276e:	fa93 f2a3 	rbit	r2, r3
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
20002772:	6822      	ldr	r2, [r4, #0]
20002774:	fa93 f3a3 	rbit	r3, r3
20002778:	fab3 f383 	clz	r3, r3
2000277c:	f003 031f 	and.w	r3, r3, #31
20002780:	fa22 f303 	lsr.w	r3, r2, r3
20002784:	07dc      	lsls	r4, r3, #31
20002786:	d5db      	bpl.n	20002740 <HAL_RCC_OscConfig+0x154>
20002788:	686b      	ldr	r3, [r5, #4]
2000278a:	2b00      	cmp	r3, #0
2000278c:	d1d8      	bne.n	20002740 <HAL_RCC_OscConfig+0x154>
2000278e:	e748      	b.n	20002622 <HAL_RCC_OscConfig+0x36>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
20002790:	6823      	ldr	r3, [r4, #0]
20002792:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20002796:	6023      	str	r3, [r4, #0]
20002798:	6823      	ldr	r3, [r4, #0]
2000279a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
2000279e:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
200027a0:	f001 f856 	bl	20003850 <HAL_GetTick>
200027a4:	4606      	mov	r6, r0
200027a6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
200027aa:	fa92 f3a2 	rbit	r3, r2

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
200027ae:	4b33      	ldr	r3, [pc, #204]	; (2000287c <HAL_RCC_OscConfig+0x290>)
200027b0:	6821      	ldr	r1, [r4, #0]
200027b2:	fa92 f2a2 	rbit	r2, r2
200027b6:	fab2 f282 	clz	r2, r2
200027ba:	f002 021f 	and.w	r2, r2, #31
200027be:	fa21 f202 	lsr.w	r2, r1, r2
200027c2:	07d0      	lsls	r0, r2, #31
200027c4:	d507      	bpl.n	200027d6 <HAL_RCC_OscConfig+0x1ea>
      {
        if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
200027c6:	f001 f843 	bl	20003850 <HAL_GetTick>
200027ca:	f241 3388 	movw	r3, #5000	; 0x1388
200027ce:	1b80      	subs	r0, r0, r6
200027d0:	4298      	cmp	r0, r3
200027d2:	d9e8      	bls.n	200027a6 <HAL_RCC_OscConfig+0x1ba>
200027d4:	e782      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
          return HAL_TIMEOUT;
        }
      }

      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
200027d6:	686a      	ldr	r2, [r5, #4]
200027d8:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
200027dc:	d00a      	beq.n	200027f4 <HAL_RCC_OscConfig+0x208>
200027de:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
200027e2:	d10c      	bne.n	200027fe <HAL_RCC_OscConfig+0x212>
200027e4:	681a      	ldr	r2, [r3, #0]
200027e6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
200027ea:	601a      	str	r2, [r3, #0]
200027ec:	681a      	ldr	r2, [r3, #0]
200027ee:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
200027f2:	601a      	str	r2, [r3, #0]
200027f4:	681a      	ldr	r2, [r3, #0]
200027f6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
200027fa:	601a      	str	r2, [r3, #0]
200027fc:	e008      	b.n	20002810 <HAL_RCC_OscConfig+0x224>
200027fe:	6819      	ldr	r1, [r3, #0]
20002800:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
20002804:	6019      	str	r1, [r3, #0]
20002806:	6819      	ldr	r1, [r3, #0]
20002808:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
2000280c:	6019      	str	r1, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
2000280e:	b1ca      	cbz	r2, 20002844 <HAL_RCC_OscConfig+0x258>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20002810:	f001 f81e 	bl	20003850 <HAL_GetTick>
20002814:	4606      	mov	r6, r0
20002816:	f44f 3300 	mov.w	r3, #131072	; 0x20000
2000281a:	fa93 f2a3 	rbit	r2, r3

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2000281e:	6822      	ldr	r2, [r4, #0]
20002820:	fa93 f3a3 	rbit	r3, r3
20002824:	fab3 f383 	clz	r3, r3
20002828:	f003 031f 	and.w	r3, r3, #31
2000282c:	fa22 f303 	lsr.w	r3, r2, r3
20002830:	07d9      	lsls	r1, r3, #31
20002832:	d485      	bmi.n	20002740 <HAL_RCC_OscConfig+0x154>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
20002834:	f001 f80c 	bl	20003850 <HAL_GetTick>
20002838:	f241 3388 	movw	r3, #5000	; 0x1388
2000283c:	1b80      	subs	r0, r0, r6
2000283e:	4298      	cmp	r0, r3
20002840:	d9e9      	bls.n	20002816 <HAL_RCC_OscConfig+0x22a>
20002842:	e74b      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20002844:	f001 f804 	bl	20003850 <HAL_GetTick>
20002848:	4606      	mov	r6, r0
2000284a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
2000284e:	fa93 f2a3 	rbit	r2, r3

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
20002852:	6822      	ldr	r2, [r4, #0]
20002854:	fa93 f3a3 	rbit	r3, r3
20002858:	fab3 f383 	clz	r3, r3
2000285c:	f003 031f 	and.w	r3, r3, #31
20002860:	fa22 f303 	lsr.w	r3, r2, r3
20002864:	07da      	lsls	r2, r3, #31
20002866:	f57f af6b 	bpl.w	20002740 <HAL_RCC_OscConfig+0x154>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
2000286a:	f000 fff1 	bl	20003850 <HAL_GetTick>
2000286e:	f241 3388 	movw	r3, #5000	; 0x1388
20002872:	1b80      	subs	r0, r0, r6
20002874:	4298      	cmp	r0, r3
20002876:	d9e8      	bls.n	2000284a <HAL_RCC_OscConfig+0x25e>
20002878:	e730      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
2000287a:	bf00      	nop
2000287c:	40021000 	.word	0x40021000
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
20002880:	4cc2      	ldr	r4, [pc, #776]	; (20002b8c <HAL_RCC_OscConfig+0x5a0>)
20002882:	68a3      	ldr	r3, [r4, #8]
20002884:	f003 030c 	and.w	r3, r3, #12
20002888:	2b04      	cmp	r3, #4
2000288a:	d009      	beq.n	200028a0 <HAL_RCC_OscConfig+0x2b4>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
2000288c:	68a3      	ldr	r3, [r4, #8]
2000288e:	f003 030c 	and.w	r3, r3, #12
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
20002892:	2b0c      	cmp	r3, #12
20002894:	d125      	bne.n	200028e2 <HAL_RCC_OscConfig+0x2f6>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
20002896:	68e3      	ldr	r3, [r4, #12]
20002898:	f003 0303 	and.w	r3, r3, #3
2000289c:	2b02      	cmp	r3, #2
2000289e:	d120      	bne.n	200028e2 <HAL_RCC_OscConfig+0x2f6>
200028a0:	f44f 6380 	mov.w	r3, #1024	; 0x400
200028a4:	fa93 f2a3 	rbit	r2, r3
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
200028a8:	6822      	ldr	r2, [r4, #0]
200028aa:	fa93 f3a3 	rbit	r3, r3
200028ae:	fab3 f383 	clz	r3, r3
200028b2:	f003 031f 	and.w	r3, r3, #31
200028b6:	fa22 f303 	lsr.w	r3, r2, r3
200028ba:	07db      	lsls	r3, r3, #31
200028bc:	d503      	bpl.n	200028c6 <HAL_RCC_OscConfig+0x2da>
200028be:	68eb      	ldr	r3, [r5, #12]
200028c0:	2b00      	cmp	r3, #0
200028c2:	f43f aeae 	beq.w	20002622 <HAL_RCC_OscConfig+0x36>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
200028c6:	6862      	ldr	r2, [r4, #4]
200028c8:	f04f 51f8 	mov.w	r1, #520093696	; 0x1f000000
200028cc:	fa91 f1a1 	rbit	r1, r1
200028d0:	692b      	ldr	r3, [r5, #16]
200028d2:	fab1 f181 	clz	r1, r1
200028d6:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
200028da:	408b      	lsls	r3, r1
200028dc:	4313      	orrs	r3, r2
200028de:	6063      	str	r3, [r4, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
200028e0:	e048      	b.n	20002974 <HAL_RCC_OscConfig+0x388>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
200028e2:	68eb      	ldr	r3, [r5, #12]
200028e4:	b353      	cbz	r3, 2000293c <HAL_RCC_OscConfig+0x350>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
200028e6:	6823      	ldr	r3, [r4, #0]
200028e8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200028ec:	6023      	str	r3, [r4, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
200028ee:	f000 ffaf 	bl	20003850 <HAL_GetTick>
200028f2:	4606      	mov	r6, r0
200028f4:	f44f 6380 	mov.w	r3, #1024	; 0x400
200028f8:	fa93 f2a3 	rbit	r2, r3

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
200028fc:	48a3      	ldr	r0, [pc, #652]	; (20002b8c <HAL_RCC_OscConfig+0x5a0>)
200028fe:	6822      	ldr	r2, [r4, #0]
20002900:	fa93 f3a3 	rbit	r3, r3
20002904:	fab3 f383 	clz	r3, r3
20002908:	f003 031f 	and.w	r3, r3, #31
2000290c:	fa22 f303 	lsr.w	r3, r2, r3
20002910:	07df      	lsls	r7, r3, #31
20002912:	d405      	bmi.n	20002920 <HAL_RCC_OscConfig+0x334>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
20002914:	f000 ff9c 	bl	20003850 <HAL_GetTick>
20002918:	1b80      	subs	r0, r0, r6
2000291a:	2864      	cmp	r0, #100	; 0x64
2000291c:	d9ea      	bls.n	200028f4 <HAL_RCC_OscConfig+0x308>
2000291e:	e6dd      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
20002920:	6842      	ldr	r2, [r0, #4]
20002922:	f04f 51f8 	mov.w	r1, #520093696	; 0x1f000000
20002926:	fa91 f1a1 	rbit	r1, r1
2000292a:	692b      	ldr	r3, [r5, #16]
2000292c:	fab1 f181 	clz	r1, r1
20002930:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
20002934:	408b      	lsls	r3, r1
20002936:	4313      	orrs	r3, r2
20002938:	6043      	str	r3, [r0, #4]
2000293a:	e01b      	b.n	20002974 <HAL_RCC_OscConfig+0x388>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
2000293c:	6823      	ldr	r3, [r4, #0]
2000293e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20002942:	6023      	str	r3, [r4, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20002944:	f000 ff84 	bl	20003850 <HAL_GetTick>
20002948:	4606      	mov	r6, r0
2000294a:	f44f 6380 	mov.w	r3, #1024	; 0x400
2000294e:	fa93 f2a3 	rbit	r2, r3

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
20002952:	6822      	ldr	r2, [r4, #0]
20002954:	fa93 f3a3 	rbit	r3, r3
20002958:	fab3 f383 	clz	r3, r3
2000295c:	f003 031f 	and.w	r3, r3, #31
20002960:	fa22 f303 	lsr.w	r3, r2, r3
20002964:	07d8      	lsls	r0, r3, #31
20002966:	d505      	bpl.n	20002974 <HAL_RCC_OscConfig+0x388>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
20002968:	f000 ff72 	bl	20003850 <HAL_GetTick>
2000296c:	1b80      	subs	r0, r0, r6
2000296e:	2864      	cmp	r0, #100	; 0x64
20002970:	d9eb      	bls.n	2000294a <HAL_RCC_OscConfig+0x35e>
20002972:	e6b3      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
20002974:	682b      	ldr	r3, [r5, #0]
20002976:	0719      	lsls	r1, r3, #28
20002978:	d403      	bmi.n	20002982 <HAL_RCC_OscConfig+0x396>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
2000297a:	682b      	ldr	r3, [r5, #0]
2000297c:	075a      	lsls	r2, r3, #29
2000297e:	d447      	bmi.n	20002a10 <HAL_RCC_OscConfig+0x424>
20002980:	e13b      	b.n	20002bfa <HAL_RCC_OscConfig+0x60e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
20002982:	696b      	ldr	r3, [r5, #20]
20002984:	4c81      	ldr	r4, [pc, #516]	; (20002b8c <HAL_RCC_OscConfig+0x5a0>)
20002986:	b30b      	cbz	r3, 200029cc <HAL_RCC_OscConfig+0x3e0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
20002988:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
2000298c:	f043 0301 	orr.w	r3, r3, #1
20002990:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20002994:	f000 ff5c 	bl	20003850 <HAL_GetTick>
20002998:	4606      	mov	r6, r0
2000299a:	2302      	movs	r3, #2
2000299c:	fa93 f2a3 	rbit	r2, r3
200029a0:	fa93 f2a3 	rbit	r2, r3
200029a4:	fa93 f2a3 	rbit	r2, r3

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
200029a8:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
200029ac:	fa93 f3a3 	rbit	r3, r3
200029b0:	fab3 f383 	clz	r3, r3
200029b4:	f003 031f 	and.w	r3, r3, #31
200029b8:	fa22 f303 	lsr.w	r3, r2, r3
200029bc:	07db      	lsls	r3, r3, #31
200029be:	d4dc      	bmi.n	2000297a <HAL_RCC_OscConfig+0x38e>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
200029c0:	f000 ff46 	bl	20003850 <HAL_GetTick>
200029c4:	1b80      	subs	r0, r0, r6
200029c6:	2864      	cmp	r0, #100	; 0x64
200029c8:	d9e7      	bls.n	2000299a <HAL_RCC_OscConfig+0x3ae>
200029ca:	e687      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
200029cc:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
200029d0:	f023 0301 	bic.w	r3, r3, #1
200029d4:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
200029d8:	f000 ff3a 	bl	20003850 <HAL_GetTick>
200029dc:	4606      	mov	r6, r0
200029de:	2302      	movs	r3, #2
200029e0:	fa93 f2a3 	rbit	r2, r3
200029e4:	fa93 f2a3 	rbit	r2, r3
200029e8:	fa93 f2a3 	rbit	r2, r3

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
200029ec:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
200029f0:	fa93 f3a3 	rbit	r3, r3
200029f4:	fab3 f383 	clz	r3, r3
200029f8:	f003 031f 	and.w	r3, r3, #31
200029fc:	fa22 f303 	lsr.w	r3, r2, r3
20002a00:	07df      	lsls	r7, r3, #31
20002a02:	d5ba      	bpl.n	2000297a <HAL_RCC_OscConfig+0x38e>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
20002a04:	f000 ff24 	bl	20003850 <HAL_GetTick>
20002a08:	1b80      	subs	r0, r0, r6
20002a0a:	2864      	cmp	r0, #100	; 0x64
20002a0c:	d9e7      	bls.n	200029de <HAL_RCC_OscConfig+0x3f2>
20002a0e:	e665      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
20002a10:	4c5e      	ldr	r4, [pc, #376]	; (20002b8c <HAL_RCC_OscConfig+0x5a0>)
20002a12:	6da3      	ldr	r3, [r4, #88]	; 0x58
20002a14:	00de      	lsls	r6, r3, #3
    {
      __HAL_RCC_PWR_CLK_ENABLE();
20002a16:	bf5f      	itttt	pl
20002a18:	6da3      	ldrpl	r3, [r4, #88]	; 0x58
20002a1a:	f043 5380 	orrpl.w	r3, r3, #268435456	; 0x10000000
20002a1e:	65a3      	strpl	r3, [r4, #88]	; 0x58
20002a20:	6da3      	ldrpl	r3, [r4, #88]	; 0x58
20002a22:	bf5e      	ittt	pl
20002a24:	f003 5380 	andpl.w	r3, r3, #268435456	; 0x10000000
20002a28:	9301      	strpl	r3, [sp, #4]
20002a2a:	9b01      	ldrpl	r3, [sp, #4]
      pwrclkchanged = SET;
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
20002a2c:	4b58      	ldr	r3, [pc, #352]	; (20002b90 <HAL_RCC_OscConfig+0x5a4>)
20002a2e:	681a      	ldr	r2, [r3, #0]
    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
20002a30:	bf54      	ite	pl
20002a32:	2601      	movpl	r6, #1
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
20002a34:	2600      	movmi	r6, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
20002a36:	05d0      	lsls	r0, r2, #23
20002a38:	d50f      	bpl.n	20002a5a <HAL_RCC_OscConfig+0x46e>
        }
      }
    }

    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
20002a3a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
20002a3e:	f023 0301 	bic.w	r3, r3, #1
20002a42:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
20002a46:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
20002a4a:	f023 0304 	bic.w	r3, r3, #4
20002a4e:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
20002a52:	f000 fefd 	bl	20003850 <HAL_GetTick>
20002a56:	4607      	mov	r7, r0

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
20002a58:	e02e      	b.n	20002ab8 <HAL_RCC_OscConfig+0x4cc>
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
20002a5a:	681a      	ldr	r2, [r3, #0]
20002a5c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20002a60:	601a      	str	r2, [r3, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
20002a62:	f000 fef5 	bl	20003850 <HAL_GetTick>
20002a66:	4607      	mov	r7, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
20002a68:	4b49      	ldr	r3, [pc, #292]	; (20002b90 <HAL_RCC_OscConfig+0x5a4>)
20002a6a:	681b      	ldr	r3, [r3, #0]
20002a6c:	05d9      	lsls	r1, r3, #23
20002a6e:	d4e4      	bmi.n	20002a3a <HAL_RCC_OscConfig+0x44e>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
20002a70:	f000 feee 	bl	20003850 <HAL_GetTick>
20002a74:	1bc0      	subs	r0, r0, r7
20002a76:	2864      	cmp	r0, #100	; 0x64
20002a78:	d9f6      	bls.n	20002a68 <HAL_RCC_OscConfig+0x47c>
20002a7a:	e62f      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
20002a7c:	fa93 f3a3 	rbit	r3, r3

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
20002a80:	fab3 f383 	clz	r3, r3
20002a84:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20002a88:	095b      	lsrs	r3, r3, #5
20002a8a:	2b03      	cmp	r3, #3
20002a8c:	bf0c      	ite	eq
20002a8e:	f8d4 2094 	ldreq.w	r2, [r4, #148]	; 0x94
20002a92:	69e2      	ldrne	r2, [r4, #28]
20002a94:	2302      	movs	r3, #2
20002a96:	fa93 f3a3 	rbit	r3, r3
20002a9a:	fab3 f383 	clz	r3, r3
20002a9e:	f003 031f 	and.w	r3, r3, #31
20002aa2:	40da      	lsrs	r2, r3
20002aa4:	07d2      	lsls	r2, r2, #31
20002aa6:	d516      	bpl.n	20002ad6 <HAL_RCC_OscConfig+0x4ea>
    {
      if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
20002aa8:	f000 fed2 	bl	20003850 <HAL_GetTick>
20002aac:	f241 3388 	movw	r3, #5000	; 0x1388
20002ab0:	1bc0      	subs	r0, r0, r7
20002ab2:	4298      	cmp	r0, r3
20002ab4:	f63f ae12 	bhi.w	200026dc <HAL_RCC_OscConfig+0xf0>
20002ab8:	2302      	movs	r3, #2
20002aba:	fa93 f2a3 	rbit	r2, r3
20002abe:	fa93 f2a3 	rbit	r2, r3

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
20002ac2:	fab2 f282 	clz	r2, r2
20002ac6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
20002aca:	0952      	lsrs	r2, r2, #5
20002acc:	429a      	cmp	r2, r3
20002ace:	d1d5      	bne.n	20002a7c <HAL_RCC_OscConfig+0x490>
20002ad0:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
20002ad4:	e7de      	b.n	20002a94 <HAL_RCC_OscConfig+0x4a8>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
20002ad6:	68ab      	ldr	r3, [r5, #8]
20002ad8:	2b01      	cmp	r3, #1
20002ada:	d01e      	beq.n	20002b1a <HAL_RCC_OscConfig+0x52e>
20002adc:	b97b      	cbnz	r3, 20002afe <HAL_RCC_OscConfig+0x512>
20002ade:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
20002ae2:	f023 0301 	bic.w	r3, r3, #1
20002ae6:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
20002aea:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
20002aee:	f023 0304 	bic.w	r3, r3, #4
20002af2:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20002af6:	f000 feab 	bl	20003850 <HAL_GetTick>
20002afa:	4607      	mov	r7, r0

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
20002afc:	e052      	b.n	20002ba4 <HAL_RCC_OscConfig+0x5b8>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
20002afe:	2b05      	cmp	r3, #5
20002b00:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
20002b04:	f023 0301 	bic.w	r3, r3, #1
20002b08:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
20002b0c:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
20002b10:	d108      	bne.n	20002b24 <HAL_RCC_OscConfig+0x538>
20002b12:	f043 0304 	orr.w	r3, r3, #4
20002b16:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
20002b1a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
20002b1e:	f043 0301 	orr.w	r3, r3, #1
20002b22:	e001      	b.n	20002b28 <HAL_RCC_OscConfig+0x53c>
20002b24:	f023 0304 	bic.w	r3, r3, #4
20002b28:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20002b2c:	f000 fe90 	bl	20003850 <HAL_GetTick>
20002b30:	4607      	mov	r7, r0
20002b32:	2302      	movs	r3, #2
20002b34:	fa93 f2a3 	rbit	r2, r3
20002b38:	fa93 f2a3 	rbit	r2, r3

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
20002b3c:	fab2 f282 	clz	r2, r2
20002b40:	f042 0240 	orr.w	r2, r2, #64	; 0x40
20002b44:	0952      	lsrs	r2, r2, #5
20002b46:	429a      	cmp	r2, r3
20002b48:	d102      	bne.n	20002b50 <HAL_RCC_OscConfig+0x564>
20002b4a:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
20002b4e:	e00b      	b.n	20002b68 <HAL_RCC_OscConfig+0x57c>
20002b50:	fa93 f3a3 	rbit	r3, r3
20002b54:	fab3 f383 	clz	r3, r3
20002b58:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20002b5c:	095b      	lsrs	r3, r3, #5
20002b5e:	2b03      	cmp	r3, #3
20002b60:	bf0c      	ite	eq
20002b62:	f8d4 2094 	ldreq.w	r2, [r4, #148]	; 0x94
20002b66:	69e2      	ldrne	r2, [r4, #28]
20002b68:	2302      	movs	r3, #2
20002b6a:	fa93 f3a3 	rbit	r3, r3
20002b6e:	fab3 f383 	clz	r3, r3
20002b72:	f003 031f 	and.w	r3, r3, #31
20002b76:	40da      	lsrs	r2, r3
20002b78:	07d3      	lsls	r3, r2, #31
20002b7a:	d42b      	bmi.n	20002bd4 <HAL_RCC_OscConfig+0x5e8>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
20002b7c:	f000 fe68 	bl	20003850 <HAL_GetTick>
20002b80:	f241 3388 	movw	r3, #5000	; 0x1388
20002b84:	1bc0      	subs	r0, r0, r7
20002b86:	4298      	cmp	r0, r3
20002b88:	d9d3      	bls.n	20002b32 <HAL_RCC_OscConfig+0x546>
20002b8a:	e5a7      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
20002b8c:	40021000 	.word	0x40021000
20002b90:	40007000 	.word	0x40007000
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
20002b94:	f000 fe5c 	bl	20003850 <HAL_GetTick>
20002b98:	f241 3388 	movw	r3, #5000	; 0x1388
20002b9c:	1bc0      	subs	r0, r0, r7
20002b9e:	4298      	cmp	r0, r3
20002ba0:	f63f ad9c 	bhi.w	200026dc <HAL_RCC_OscConfig+0xf0>
20002ba4:	2302      	movs	r3, #2
20002ba6:	fa93 f2a3 	rbit	r2, r3
20002baa:	fa93 f2a3 	rbit	r2, r3
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
20002bae:	fab2 f282 	clz	r2, r2
20002bb2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
20002bb6:	0952      	lsrs	r2, r2, #5
20002bb8:	429a      	cmp	r2, r3
20002bba:	d111      	bne.n	20002be0 <HAL_RCC_OscConfig+0x5f4>
20002bbc:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
20002bc0:	2302      	movs	r3, #2
20002bc2:	fa93 f3a3 	rbit	r3, r3
20002bc6:	fab3 f383 	clz	r3, r3
20002bca:	f003 031f 	and.w	r3, r3, #31
20002bce:	40da      	lsrs	r2, r3
20002bd0:	07d0      	lsls	r0, r2, #31
20002bd2:	d4df      	bmi.n	20002b94 <HAL_RCC_OscConfig+0x5a8>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
20002bd4:	b18e      	cbz	r6, 20002bfa <HAL_RCC_OscConfig+0x60e>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
20002bd6:	6da3      	ldr	r3, [r4, #88]	; 0x58
20002bd8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20002bdc:	65a3      	str	r3, [r4, #88]	; 0x58
20002bde:	e00c      	b.n	20002bfa <HAL_RCC_OscConfig+0x60e>
20002be0:	fa93 f3a3 	rbit	r3, r3
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
20002be4:	fab3 f383 	clz	r3, r3
20002be8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20002bec:	095b      	lsrs	r3, r3, #5
20002bee:	2b03      	cmp	r3, #3
20002bf0:	bf0c      	ite	eq
20002bf2:	f8d4 2094 	ldreq.w	r2, [r4, #148]	; 0x94
20002bf6:	69e2      	ldrne	r2, [r4, #28]
20002bf8:	e7e2      	b.n	20002bc0 <HAL_RCC_OscConfig+0x5d4>
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
20002bfa:	6a6a      	ldr	r2, [r5, #36]	; 0x24
20002bfc:	b90a      	cbnz	r2, 20002c02 <HAL_RCC_OscConfig+0x616>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
20002bfe:	2000      	movs	r0, #0
20002c00:	e07e      	b.n	20002d00 <HAL_RCC_OscConfig+0x714>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
20002c02:	4c40      	ldr	r4, [pc, #256]	; (20002d04 <HAL_RCC_OscConfig+0x718>)
20002c04:	68a3      	ldr	r3, [r4, #8]
20002c06:	f003 030c 	and.w	r3, r3, #12
20002c0a:	2b0c      	cmp	r3, #12
20002c0c:	f43f ad09 	beq.w	20002622 <HAL_RCC_OscConfig+0x36>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
20002c10:	6823      	ldr	r3, [r4, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
20002c12:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
20002c14:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
20002c18:	6023      	str	r3, [r4, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
20002c1a:	d14f      	bne.n	20002cbc <HAL_RCC_OscConfig+0x6d0>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20002c1c:	f000 fe18 	bl	20003850 <HAL_GetTick>
20002c20:	4606      	mov	r6, r0
20002c22:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20002c26:	fa93 f2a3 	rbit	r2, r3

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
20002c2a:	4836      	ldr	r0, [pc, #216]	; (20002d04 <HAL_RCC_OscConfig+0x718>)
20002c2c:	6822      	ldr	r2, [r4, #0]
20002c2e:	fa93 f3a3 	rbit	r3, r3
20002c32:	fab3 f383 	clz	r3, r3
20002c36:	f003 031f 	and.w	r3, r3, #31
20002c3a:	fa22 f303 	lsr.w	r3, r2, r3
20002c3e:	07d9      	lsls	r1, r3, #31
20002c40:	d505      	bpl.n	20002c4e <HAL_RCC_OscConfig+0x662>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
20002c42:	f000 fe05 	bl	20003850 <HAL_GetTick>
20002c46:	1b80      	subs	r0, r0, r6
20002c48:	2864      	cmp	r0, #100	; 0x64
20002c4a:	d9ea      	bls.n	20002c22 <HAL_RCC_OscConfig+0x636>
20002c4c:	e546      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
20002c4e:	6b29      	ldr	r1, [r5, #48]	; 0x30
20002c50:	6aab      	ldr	r3, [r5, #40]	; 0x28
20002c52:	6b6a      	ldr	r2, [r5, #52]	; 0x34
20002c54:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
20002c58:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
20002c5a:	3901      	subs	r1, #1
20002c5c:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
20002c60:	0912      	lsrs	r2, r2, #4
20002c62:	ea43 4142 	orr.w	r1, r3, r2, lsl #17
20002c66:	6bab      	ldr	r3, [r5, #56]	; 0x38
20002c68:	085b      	lsrs	r3, r3, #1
20002c6a:	3b01      	subs	r3, #1
20002c6c:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
20002c70:	6beb      	ldr	r3, [r5, #60]	; 0x3c
20002c72:	085b      	lsrs	r3, r3, #1
20002c74:	3b01      	subs	r3, #1
20002c76:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
20002c7a:	60c3      	str	r3, [r0, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
20002c7c:	6803      	ldr	r3, [r0, #0]
20002c7e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
20002c82:	6003      	str	r3, [r0, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
20002c84:	68c3      	ldr	r3, [r0, #12]
20002c86:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
20002c8a:	60c3      	str	r3, [r0, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20002c8c:	f000 fde0 	bl	20003850 <HAL_GetTick>
20002c90:	4605      	mov	r5, r0
20002c92:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20002c96:	fa93 f2a3 	rbit	r2, r3

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
20002c9a:	6822      	ldr	r2, [r4, #0]
20002c9c:	fa93 f3a3 	rbit	r3, r3
20002ca0:	fab3 f383 	clz	r3, r3
20002ca4:	f003 031f 	and.w	r3, r3, #31
20002ca8:	fa22 f303 	lsr.w	r3, r2, r3
20002cac:	07da      	lsls	r2, r3, #31
20002cae:	d4a6      	bmi.n	20002bfe <HAL_RCC_OscConfig+0x612>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
20002cb0:	f000 fdce 	bl	20003850 <HAL_GetTick>
20002cb4:	1b40      	subs	r0, r0, r5
20002cb6:	2864      	cmp	r0, #100	; 0x64
20002cb8:	d9eb      	bls.n	20002c92 <HAL_RCC_OscConfig+0x6a6>
20002cba:	e50f      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
20002cbc:	68e3      	ldr	r3, [r4, #12]
20002cbe:	f023 0303 	bic.w	r3, r3, #3
20002cc2:	60e3      	str	r3, [r4, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
20002cc4:	68e3      	ldr	r3, [r4, #12]
20002cc6:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
20002cca:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20002cce:	60e3      	str	r3, [r4, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20002cd0:	f000 fdbe 	bl	20003850 <HAL_GetTick>
20002cd4:	4605      	mov	r5, r0
20002cd6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20002cda:	fa93 f2a3 	rbit	r2, r3

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
20002cde:	6822      	ldr	r2, [r4, #0]
20002ce0:	fa93 f3a3 	rbit	r3, r3
20002ce4:	fab3 f383 	clz	r3, r3
20002ce8:	f003 031f 	and.w	r3, r3, #31
20002cec:	fa22 f303 	lsr.w	r3, r2, r3
20002cf0:	07db      	lsls	r3, r3, #31
20002cf2:	d584      	bpl.n	20002bfe <HAL_RCC_OscConfig+0x612>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
20002cf4:	f000 fdac 	bl	20003850 <HAL_GetTick>
20002cf8:	1b40      	subs	r0, r0, r5
20002cfa:	2864      	cmp	r0, #100	; 0x64
20002cfc:	d9eb      	bls.n	20002cd6 <HAL_RCC_OscConfig+0x6ea>
20002cfe:	e4ed      	b.n	200026dc <HAL_RCC_OscConfig+0xf0>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
20002d00:	b003      	add	sp, #12
20002d02:	bdf0      	pop	{r4, r5, r6, r7, pc}
20002d04:	40021000 	.word	0x40021000

20002d08 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
20002d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
20002d0a:	4b8f      	ldr	r3, [pc, #572]	; (20002f48 <HAL_RCC_ClockConfig+0x240>)
20002d0c:	681a      	ldr	r2, [r3, #0]
20002d0e:	f002 0207 	and.w	r2, r2, #7
20002d12:	4291      	cmp	r1, r2
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
20002d14:	4604      	mov	r4, r0
20002d16:	460e      	mov	r6, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
20002d18:	f240 8087 	bls.w	20002e2a <HAL_RCC_ClockConfig+0x122>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
20002d1c:	681a      	ldr	r2, [r3, #0]
20002d1e:	2904      	cmp	r1, #4
20002d20:	bf9c      	itt	ls
20002d22:	f022 0207 	bicls.w	r2, r2, #7
20002d26:	430a      	orrls	r2, r1
20002d28:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
20002d2a:	681b      	ldr	r3, [r3, #0]
20002d2c:	f003 0307 	and.w	r3, r3, #7
20002d30:	428b      	cmp	r3, r1
20002d32:	d001      	beq.n	20002d38 <HAL_RCC_ClockConfig+0x30>
    {
      return HAL_ERROR;
20002d34:	2001      	movs	r0, #1
20002d36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
20002d38:	6801      	ldr	r1, [r0, #0]
20002d3a:	078a      	lsls	r2, r1, #30
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
20002d3c:	bf41      	itttt	mi
20002d3e:	4883      	ldrmi	r0, [pc, #524]	; (20002f4c <HAL_RCC_ClockConfig+0x244>)
20002d40:	6883      	ldrmi	r3, [r0, #8]
20002d42:	f023 02f0 	bicmi.w	r2, r3, #240	; 0xf0
20002d46:	68a3      	ldrmi	r3, [r4, #8]
20002d48:	bf44      	itt	mi
20002d4a:	4313      	orrmi	r3, r2
20002d4c:	6083      	strmi	r3, [r0, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
20002d4e:	07cb      	lsls	r3, r1, #31
20002d50:	d40b      	bmi.n	20002d6a <HAL_RCC_ClockConfig+0x62>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
20002d52:	6821      	ldr	r1, [r4, #0]
20002d54:	074f      	lsls	r7, r1, #29
20002d56:	f140 80e6 	bpl.w	20002f26 <HAL_RCC_ClockConfig+0x21e>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
20002d5a:	487c      	ldr	r0, [pc, #496]	; (20002f4c <HAL_RCC_ClockConfig+0x244>)
20002d5c:	6883      	ldr	r3, [r0, #8]
20002d5e:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
20002d62:	68e3      	ldr	r3, [r4, #12]
20002d64:	4313      	orrs	r3, r2
20002d66:	6083      	str	r3, [r0, #8]
20002d68:	e0dd      	b.n	20002f26 <HAL_RCC_ClockConfig+0x21e>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
20002d6a:	6862      	ldr	r2, [r4, #4]
20002d6c:	4d77      	ldr	r5, [pc, #476]	; (20002f4c <HAL_RCC_ClockConfig+0x244>)
20002d6e:	2a02      	cmp	r2, #2
20002d70:	d102      	bne.n	20002d78 <HAL_RCC_ClockConfig+0x70>
20002d72:	f44f 3300 	mov.w	r3, #131072	; 0x20000
20002d76:	e009      	b.n	20002d8c <HAL_RCC_ClockConfig+0x84>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
20002d78:	2a03      	cmp	r2, #3
20002d7a:	d102      	bne.n	20002d82 <HAL_RCC_ClockConfig+0x7a>
20002d7c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20002d80:	e004      	b.n	20002d8c <HAL_RCC_ClockConfig+0x84>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
20002d82:	b90a      	cbnz	r2, 20002d88 <HAL_RCC_ClockConfig+0x80>
20002d84:	2302      	movs	r3, #2
20002d86:	e001      	b.n	20002d8c <HAL_RCC_ClockConfig+0x84>
20002d88:	f44f 6380 	mov.w	r3, #1024	; 0x400
20002d8c:	fa93 f1a3 	rbit	r1, r3
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
20002d90:	6829      	ldr	r1, [r5, #0]
20002d92:	fa93 f3a3 	rbit	r3, r3
20002d96:	fab3 f383 	clz	r3, r3
20002d9a:	f003 031f 	and.w	r3, r3, #31
20002d9e:	fa21 f303 	lsr.w	r3, r1, r3
20002da2:	07de      	lsls	r6, r3, #31
20002da4:	d5c6      	bpl.n	20002d34 <HAL_RCC_ClockConfig+0x2c>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
20002da6:	68ab      	ldr	r3, [r5, #8]
20002da8:	f023 0303 	bic.w	r3, r3, #3
20002dac:	431a      	orrs	r2, r3
20002dae:	60aa      	str	r2, [r5, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20002db0:	f000 fd4e 	bl	20003850 <HAL_GetTick>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
20002db4:	6863      	ldr	r3, [r4, #4]
20002db6:	2b02      	cmp	r3, #2
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20002db8:	4606      	mov	r6, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
20002dba:	d10d      	bne.n	20002dd8 <HAL_RCC_ClockConfig+0xd0>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
20002dbc:	68ab      	ldr	r3, [r5, #8]
20002dbe:	f003 030c 	and.w	r3, r3, #12
20002dc2:	2b08      	cmp	r3, #8
20002dc4:	d0c5      	beq.n	20002d52 <HAL_RCC_ClockConfig+0x4a>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
20002dc6:	f000 fd43 	bl	20003850 <HAL_GetTick>
20002dca:	f241 3388 	movw	r3, #5000	; 0x1388
20002dce:	1b80      	subs	r0, r0, r6
20002dd0:	4298      	cmp	r0, r3
20002dd2:	d9f3      	bls.n	20002dbc <HAL_RCC_ClockConfig+0xb4>
          {
            return HAL_TIMEOUT;
20002dd4:	2003      	movs	r0, #3
20002dd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
20002dd8:	2b03      	cmp	r3, #3
20002dda:	d10c      	bne.n	20002df6 <HAL_RCC_ClockConfig+0xee>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
20002ddc:	68ab      	ldr	r3, [r5, #8]
20002dde:	f003 030c 	and.w	r3, r3, #12
20002de2:	2b0c      	cmp	r3, #12
20002de4:	d0b5      	beq.n	20002d52 <HAL_RCC_ClockConfig+0x4a>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
20002de6:	f000 fd33 	bl	20003850 <HAL_GetTick>
20002dea:	f241 3388 	movw	r3, #5000	; 0x1388
20002dee:	1b80      	subs	r0, r0, r6
20002df0:	4298      	cmp	r0, r3
20002df2:	d9f3      	bls.n	20002ddc <HAL_RCC_ClockConfig+0xd4>
20002df4:	e7ee      	b.n	20002dd4 <HAL_RCC_ClockConfig+0xcc>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
20002df6:	b993      	cbnz	r3, 20002e1e <HAL_RCC_ClockConfig+0x116>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
20002df8:	68ab      	ldr	r3, [r5, #8]
20002dfa:	f013 0f0c 	tst.w	r3, #12
20002dfe:	d0a8      	beq.n	20002d52 <HAL_RCC_ClockConfig+0x4a>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
20002e00:	f000 fd26 	bl	20003850 <HAL_GetTick>
20002e04:	f241 3388 	movw	r3, #5000	; 0x1388
20002e08:	1b80      	subs	r0, r0, r6
20002e0a:	4298      	cmp	r0, r3
20002e0c:	d9f4      	bls.n	20002df8 <HAL_RCC_ClockConfig+0xf0>
20002e0e:	e7e1      	b.n	20002dd4 <HAL_RCC_ClockConfig+0xcc>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
20002e10:	f000 fd1e 	bl	20003850 <HAL_GetTick>
20002e14:	f241 3388 	movw	r3, #5000	; 0x1388
20002e18:	1b80      	subs	r0, r0, r6
20002e1a:	4298      	cmp	r0, r3
20002e1c:	d8da      	bhi.n	20002dd4 <HAL_RCC_ClockConfig+0xcc>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
20002e1e:	68ab      	ldr	r3, [r5, #8]
20002e20:	f003 030c 	and.w	r3, r3, #12
20002e24:	2b04      	cmp	r3, #4
20002e26:	d1f3      	bne.n	20002e10 <HAL_RCC_ClockConfig+0x108>
20002e28:	e793      	b.n	20002d52 <HAL_RCC_ClockConfig+0x4a>
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
20002e2a:	6801      	ldr	r1, [r0, #0]
20002e2c:	078d      	lsls	r5, r1, #30
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
20002e2e:	bf41      	itttt	mi
20002e30:	4846      	ldrmi	r0, [pc, #280]	; (20002f4c <HAL_RCC_ClockConfig+0x244>)
20002e32:	6883      	ldrmi	r3, [r0, #8]
20002e34:	f023 02f0 	bicmi.w	r2, r3, #240	; 0xf0
20002e38:	68a3      	ldrmi	r3, [r4, #8]
20002e3a:	bf44      	itt	mi
20002e3c:	4313      	orrmi	r3, r2
20002e3e:	6083      	strmi	r3, [r0, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
20002e40:	07c8      	lsls	r0, r1, #31
20002e42:	d407      	bmi.n	20002e54 <HAL_RCC_ClockConfig+0x14c>
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
20002e44:	2e04      	cmp	r6, #4
20002e46:	4a40      	ldr	r2, [pc, #256]	; (20002f48 <HAL_RCC_ClockConfig+0x240>)
20002e48:	d864      	bhi.n	20002f14 <HAL_RCC_ClockConfig+0x20c>
20002e4a:	6813      	ldr	r3, [r2, #0]
20002e4c:	f023 0307 	bic.w	r3, r3, #7
20002e50:	4333      	orrs	r3, r6
20002e52:	e060      	b.n	20002f16 <HAL_RCC_ClockConfig+0x20e>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
20002e54:	6862      	ldr	r2, [r4, #4]
20002e56:	4d3d      	ldr	r5, [pc, #244]	; (20002f4c <HAL_RCC_ClockConfig+0x244>)
20002e58:	2a02      	cmp	r2, #2
20002e5a:	d102      	bne.n	20002e62 <HAL_RCC_ClockConfig+0x15a>
20002e5c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
20002e60:	e008      	b.n	20002e74 <HAL_RCC_ClockConfig+0x16c>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
20002e62:	b90a      	cbnz	r2, 20002e68 <HAL_RCC_ClockConfig+0x160>
20002e64:	2302      	movs	r3, #2
20002e66:	e005      	b.n	20002e74 <HAL_RCC_ClockConfig+0x16c>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
20002e68:	2a03      	cmp	r2, #3
20002e6a:	bf0c      	ite	eq
20002e6c:	f04f 7300 	moveq.w	r3, #33554432	; 0x2000000
20002e70:	f44f 6380 	movne.w	r3, #1024	; 0x400
20002e74:	fa93 f1a3 	rbit	r1, r3
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
20002e78:	6829      	ldr	r1, [r5, #0]
20002e7a:	fa93 f3a3 	rbit	r3, r3
20002e7e:	fab3 f383 	clz	r3, r3
20002e82:	f003 031f 	and.w	r3, r3, #31
20002e86:	fa21 f303 	lsr.w	r3, r1, r3
20002e8a:	07d9      	lsls	r1, r3, #31
20002e8c:	f57f af52 	bpl.w	20002d34 <HAL_RCC_ClockConfig+0x2c>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
20002e90:	68ab      	ldr	r3, [r5, #8]
20002e92:	f023 0303 	bic.w	r3, r3, #3
20002e96:	431a      	orrs	r2, r3
20002e98:	60aa      	str	r2, [r5, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20002e9a:	f000 fcd9 	bl	20003850 <HAL_GetTick>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
20002e9e:	6863      	ldr	r3, [r4, #4]
20002ea0:	2b02      	cmp	r3, #2
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20002ea2:	4607      	mov	r7, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
20002ea4:	d10c      	bne.n	20002ec0 <HAL_RCC_ClockConfig+0x1b8>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
20002ea6:	68ab      	ldr	r3, [r5, #8]
20002ea8:	f003 030c 	and.w	r3, r3, #12
20002eac:	2b08      	cmp	r3, #8
20002eae:	d0c9      	beq.n	20002e44 <HAL_RCC_ClockConfig+0x13c>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
20002eb0:	f000 fcce 	bl	20003850 <HAL_GetTick>
20002eb4:	f241 3388 	movw	r3, #5000	; 0x1388
20002eb8:	1bc0      	subs	r0, r0, r7
20002eba:	4298      	cmp	r0, r3
20002ebc:	d9f3      	bls.n	20002ea6 <HAL_RCC_ClockConfig+0x19e>
20002ebe:	e789      	b.n	20002dd4 <HAL_RCC_ClockConfig+0xcc>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
20002ec0:	2b03      	cmp	r3, #3
20002ec2:	d10c      	bne.n	20002ede <HAL_RCC_ClockConfig+0x1d6>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
20002ec4:	68ab      	ldr	r3, [r5, #8]
20002ec6:	f003 030c 	and.w	r3, r3, #12
20002eca:	2b0c      	cmp	r3, #12
20002ecc:	d0ba      	beq.n	20002e44 <HAL_RCC_ClockConfig+0x13c>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
20002ece:	f000 fcbf 	bl	20003850 <HAL_GetTick>
20002ed2:	f241 3388 	movw	r3, #5000	; 0x1388
20002ed6:	1bc0      	subs	r0, r0, r7
20002ed8:	4298      	cmp	r0, r3
20002eda:	d9f3      	bls.n	20002ec4 <HAL_RCC_ClockConfig+0x1bc>
20002edc:	e77a      	b.n	20002dd4 <HAL_RCC_ClockConfig+0xcc>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
20002ede:	b99b      	cbnz	r3, 20002f08 <HAL_RCC_ClockConfig+0x200>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
20002ee0:	68ab      	ldr	r3, [r5, #8]
20002ee2:	f013 0f0c 	tst.w	r3, #12
20002ee6:	d0ad      	beq.n	20002e44 <HAL_RCC_ClockConfig+0x13c>
        {
          if((HAL_GetTick() - tickstart) >= CLOCKSWITCH_TIMEOUT_VALUE)
20002ee8:	f000 fcb2 	bl	20003850 <HAL_GetTick>
20002eec:	f241 3387 	movw	r3, #4999	; 0x1387
20002ef0:	1bc0      	subs	r0, r0, r7
20002ef2:	4298      	cmp	r0, r3
20002ef4:	d9f4      	bls.n	20002ee0 <HAL_RCC_ClockConfig+0x1d8>
20002ef6:	e76d      	b.n	20002dd4 <HAL_RCC_ClockConfig+0xcc>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
20002ef8:	f000 fcaa 	bl	20003850 <HAL_GetTick>
20002efc:	f241 3388 	movw	r3, #5000	; 0x1388
20002f00:	1bc0      	subs	r0, r0, r7
20002f02:	4298      	cmp	r0, r3
20002f04:	f63f af66 	bhi.w	20002dd4 <HAL_RCC_ClockConfig+0xcc>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
20002f08:	68ab      	ldr	r3, [r5, #8]
20002f0a:	f003 030c 	and.w	r3, r3, #12
20002f0e:	2b04      	cmp	r3, #4
20002f10:	d1f2      	bne.n	20002ef8 <HAL_RCC_ClockConfig+0x1f0>
20002f12:	e797      	b.n	20002e44 <HAL_RCC_ClockConfig+0x13c>
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
20002f14:	6813      	ldr	r3, [r2, #0]
20002f16:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
20002f18:	6813      	ldr	r3, [r2, #0]
20002f1a:	f003 0307 	and.w	r3, r3, #7
20002f1e:	42b3      	cmp	r3, r6
20002f20:	f47f af08 	bne.w	20002d34 <HAL_RCC_ClockConfig+0x2c>
20002f24:	e715      	b.n	20002d52 <HAL_RCC_ClockConfig+0x4a>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
20002f26:	070b      	lsls	r3, r1, #28
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
20002f28:	bf41      	itttt	mi
20002f2a:	4a08      	ldrmi	r2, [pc, #32]	; (20002f4c <HAL_RCC_ClockConfig+0x244>)
20002f2c:	6921      	ldrmi	r1, [r4, #16]
20002f2e:	6893      	ldrmi	r3, [r2, #8]
20002f30:	f423 5360 	bicmi.w	r3, r3, #14336	; 0x3800
20002f34:	bf44      	itt	mi
20002f36:	ea43 03c1 	orrmi.w	r3, r3, r1, lsl #3
20002f3a:	6093      	strmi	r3, [r2, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
20002f3c:	2000      	movs	r0, #0
20002f3e:	f000 fc5b 	bl	200037f8 <HAL_InitTick>

  return HAL_OK;
20002f42:	2000      	movs	r0, #0
}
20002f44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
20002f46:	bf00      	nop
20002f48:	40022000 	.word	0x40022000
20002f4c:	40021000 	.word	0x40021000

20002f50 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
20002f50:	492f      	ldr	r1, [pc, #188]	; (20003010 <HAL_RCC_GetSysClockFreq+0xc0>)
20002f52:	688b      	ldr	r3, [r1, #8]
20002f54:	f003 030c 	and.w	r3, r3, #12
20002f58:	2b04      	cmp	r3, #4
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
20002f5a:	b510      	push	{r4, lr}
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
20002f5c:	d028      	beq.n	20002fb0 <HAL_RCC_GetSysClockFreq+0x60>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
20002f5e:	688b      	ldr	r3, [r1, #8]
20002f60:	f003 030c 	and.w	r3, r3, #12
20002f64:	2b08      	cmp	r3, #8
20002f66:	d025      	beq.n	20002fb4 <HAL_RCC_GetSysClockFreq+0x64>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
20002f68:	688b      	ldr	r3, [r1, #8]
20002f6a:	f013 0f0c 	tst.w	r3, #12
20002f6e:	d009      	beq.n	20002f84 <HAL_RCC_GetSysClockFreq+0x34>
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
20002f70:	688b      	ldr	r3, [r1, #8]
20002f72:	f003 030c 	and.w	r3, r3, #12
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
20002f76:	2b0c      	cmp	r3, #12
20002f78:	d11f      	bne.n	20002fba <HAL_RCC_GetSysClockFreq+0x6a>
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
20002f7a:	68cb      	ldr	r3, [r1, #12]
20002f7c:	f003 0303 	and.w	r3, r3, #3
20002f80:	2b01      	cmp	r3, #1
20002f82:	d11a      	bne.n	20002fba <HAL_RCC_GetSysClockFreq+0x6a>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
20002f84:	680a      	ldr	r2, [r1, #0]
20002f86:	4b22      	ldr	r3, [pc, #136]	; (20003010 <HAL_RCC_GetSysClockFreq+0xc0>)
20002f88:	0712      	lsls	r2, r2, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
20002f8a:	bf54      	ite	pl
20002f8c:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
20002f90:	681b      	ldrmi	r3, [r3, #0]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
20002f92:	4a20      	ldr	r2, [pc, #128]	; (20003014 <HAL_RCC_GetSysClockFreq+0xc4>)
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
20002f94:	bf54      	ite	pl
20002f96:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
20002f9a:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
20002f9e:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
20002fa2:	688b      	ldr	r3, [r1, #8]
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
20002fa4:	f013 0f0c 	tst.w	r3, #12
20002fa8:	bf0c      	ite	eq
20002faa:	4620      	moveq	r0, r4
20002fac:	2000      	movne	r0, #0
20002fae:	e006      	b.n	20002fbe <HAL_RCC_GetSysClockFreq+0x6e>
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
20002fb0:	4819      	ldr	r0, [pc, #100]	; (20003018 <HAL_RCC_GetSysClockFreq+0xc8>)
20002fb2:	e000      	b.n	20002fb6 <HAL_RCC_GetSysClockFreq+0x66>
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
20002fb4:	4819      	ldr	r0, [pc, #100]	; (2000301c <HAL_RCC_GetSysClockFreq+0xcc>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
20002fb6:	2400      	movs	r4, #0
20002fb8:	e001      	b.n	20002fbe <HAL_RCC_GetSysClockFreq+0x6e>
  uint32_t sysclockfreq = 0;
20002fba:	2000      	movs	r0, #0
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
20002fbc:	4604      	mov	r4, r0
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
20002fbe:	688a      	ldr	r2, [r1, #8]
20002fc0:	4b13      	ldr	r3, [pc, #76]	; (20003010 <HAL_RCC_GetSysClockFreq+0xc0>)
20002fc2:	f002 020c 	and.w	r2, r2, #12
20002fc6:	2a0c      	cmp	r2, #12
20002fc8:	d121      	bne.n	2000300e <HAL_RCC_GetSysClockFreq+0xbe>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
20002fca:	68da      	ldr	r2, [r3, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
20002fcc:	68d8      	ldr	r0, [r3, #12]
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
20002fce:	f002 0203 	and.w	r2, r2, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
20002fd2:	f3c0 1002 	ubfx	r0, r0, #4, #3

    switch (pllsource)
20002fd6:	2a02      	cmp	r2, #2

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
20002fd8:	f100 0001 	add.w	r0, r0, #1

    switch (pllsource)
20002fdc:	d004      	beq.n	20002fe8 <HAL_RCC_GetSysClockFreq+0x98>
20002fde:	2a03      	cmp	r2, #3
20002fe0:	d107      	bne.n	20002ff2 <HAL_RCC_GetSysClockFreq+0xa2>
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
20002fe2:	68da      	ldr	r2, [r3, #12]
20002fe4:	4b0d      	ldr	r3, [pc, #52]	; (2000301c <HAL_RCC_GetSysClockFreq+0xcc>)
20002fe6:	e001      	b.n	20002fec <HAL_RCC_GetSysClockFreq+0x9c>
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
20002fe8:	68da      	ldr	r2, [r3, #12]
20002fea:	4b0b      	ldr	r3, [pc, #44]	; (20003018 <HAL_RCC_GetSysClockFreq+0xc8>)
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
20002fec:	fbb3 f0f0 	udiv	r0, r3, r0
20002ff0:	e002      	b.n	20002ff8 <HAL_RCC_GetSysClockFreq+0xa8>
      break;

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
20002ff2:	68da      	ldr	r2, [r3, #12]
20002ff4:	fbb4 f0f0 	udiv	r0, r4, r0
20002ff8:	f3c2 2206 	ubfx	r2, r2, #8, #7
20002ffc:	fb02 f300 	mul.w	r3, r2, r0
      break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>25) + 1 ) *2;
20003000:	68c8      	ldr	r0, [r1, #12]
20003002:	f3c0 6041 	ubfx	r0, r0, #25, #2
20003006:	3001      	adds	r0, #1
20003008:	0040      	lsls	r0, r0, #1
    sysclockfreq = pllvco/pllr;
2000300a:	fbb3 f0f0 	udiv	r0, r3, r0
  }

  return sysclockfreq;
}
2000300e:	bd10      	pop	{r4, pc}
20003010:	40021000 	.word	0x40021000
20003014:	20005eb4 	.word	0x20005eb4
20003018:	00f42400 	.word	0x00f42400
2000301c:	007a1200 	.word	0x007a1200

20003020 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
20003020:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
20003022:	f7ff ff95 	bl	20002f50 <HAL_RCC_GetSysClockFreq>
20003026:	4b08      	ldr	r3, [pc, #32]	; (20003048 <HAL_RCC_GetHCLKFreq+0x28>)
20003028:	22f0      	movs	r2, #240	; 0xf0
2000302a:	689b      	ldr	r3, [r3, #8]
2000302c:	fa92 f2a2 	rbit	r2, r2
20003030:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
20003034:	fab2 f282 	clz	r2, r2
20003038:	40d3      	lsrs	r3, r2
2000303a:	4a04      	ldr	r2, [pc, #16]	; (2000304c <HAL_RCC_GetHCLKFreq+0x2c>)
2000303c:	5cd3      	ldrb	r3, [r2, r3]
2000303e:	40d8      	lsrs	r0, r3
20003040:	4b03      	ldr	r3, [pc, #12]	; (20003050 <HAL_RCC_GetHCLKFreq+0x30>)
20003042:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
20003044:	bd08      	pop	{r3, pc}
20003046:	bf00      	nop
20003048:	40021000 	.word	0x40021000
2000304c:	20005ea4 	.word	0x20005ea4
20003050:	200066b8 	.word	0x200066b8

20003054 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
20003054:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
20003056:	f7ff ffe3 	bl	20003020 <HAL_RCC_GetHCLKFreq>
2000305a:	4b07      	ldr	r3, [pc, #28]	; (20003078 <HAL_RCC_GetPCLK1Freq+0x24>)
2000305c:	f44f 62e0 	mov.w	r2, #1792	; 0x700
20003060:	689b      	ldr	r3, [r3, #8]
20003062:	fa92 f2a2 	rbit	r2, r2
20003066:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
2000306a:	fab2 f282 	clz	r2, r2
2000306e:	40d3      	lsrs	r3, r2
20003070:	4a02      	ldr	r2, [pc, #8]	; (2000307c <HAL_RCC_GetPCLK1Freq+0x28>)
20003072:	5cd3      	ldrb	r3, [r2, r3]
}
20003074:	40d8      	lsrs	r0, r3
20003076:	bd08      	pop	{r3, pc}
20003078:	40021000 	.word	0x40021000
2000307c:	20006651 	.word	0x20006651

20003080 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
20003080:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
20003082:	f7ff ffcd 	bl	20003020 <HAL_RCC_GetHCLKFreq>
20003086:	4b07      	ldr	r3, [pc, #28]	; (200030a4 <HAL_RCC_GetPCLK2Freq+0x24>)
20003088:	f44f 5260 	mov.w	r2, #14336	; 0x3800
2000308c:	689b      	ldr	r3, [r3, #8]
2000308e:	fa92 f2a2 	rbit	r2, r2
20003092:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
20003096:	fab2 f282 	clz	r2, r2
2000309a:	40d3      	lsrs	r3, r2
2000309c:	4a02      	ldr	r2, [pc, #8]	; (200030a8 <HAL_RCC_GetPCLK2Freq+0x28>)
2000309e:	5cd3      	ldrb	r3, [r2, r3]
}
200030a0:	40d8      	lsrs	r0, r3
200030a2:	bd08      	pop	{r3, pc}
200030a4:	40021000 	.word	0x40021000
200030a8:	20006651 	.word	0x20006651

200030ac <RCCEx_PLLSAI1_ConfigNP>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PllSai1)
{
200030ac:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
200030ae:	4c29      	ldr	r4, [pc, #164]	; (20003154 <RCCEx_PLLSAI1_ConfigNP+0xa8>)
200030b0:	6823      	ldr	r3, [r4, #0]
200030b2:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
200030b6:	6023      	str	r3, [r4, #0]
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PllSai1)
{
200030b8:	4605      	mov	r5, r0

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
200030ba:	f000 fbc9 	bl	20003850 <HAL_GetTick>
200030be:	4606      	mov	r6, r0
200030c0:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
200030c4:	fa92 f3a2 	rbit	r3, r2

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
200030c8:	4b22      	ldr	r3, [pc, #136]	; (20003154 <RCCEx_PLLSAI1_ConfigNP+0xa8>)
200030ca:	6821      	ldr	r1, [r4, #0]
200030cc:	fa92 f2a2 	rbit	r2, r2
200030d0:	fab2 f282 	clz	r2, r2
200030d4:	f002 021f 	and.w	r2, r2, #31
200030d8:	fa21 f202 	lsr.w	r2, r1, r2
200030dc:	07d2      	lsls	r2, r2, #31
200030de:	d507      	bpl.n	200030f0 <RCCEx_PLLSAI1_ConfigNP+0x44>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
200030e0:	f000 fbb6 	bl	20003850 <HAL_GetTick>
200030e4:	1b80      	subs	r0, r0, r6
200030e6:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
200030ea:	d9e9      	bls.n	200030c0 <RCCEx_PLLSAI1_ConfigNP+0x14>
    {
      status = HAL_TIMEOUT;
200030ec:	2003      	movs	r0, #3
200030ee:	bd70      	pop	{r4, r5, r6, pc}
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PllSai1->PLLSAI1N);
200030f0:	691a      	ldr	r2, [r3, #16]
200030f2:	6829      	ldr	r1, [r5, #0]
200030f4:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
200030f8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
200030fc:	611a      	str	r2, [r3, #16]
    /* Configure the PLLSAI1 Division factor P */
    __HAL_RCC_PLLSAI1_DIVP_CONFIG(PllSai1->PLLSAI1P);
200030fe:	691a      	ldr	r2, [r3, #16]
20003100:	6869      	ldr	r1, [r5, #4]
20003102:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
20003106:	0909      	lsrs	r1, r1, #4
20003108:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
2000310c:	611a      	str	r2, [r3, #16]
    /* Configure the PLLSAI1 Clock output(s) */
    __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
2000310e:	6919      	ldr	r1, [r3, #16]
20003110:	692a      	ldr	r2, [r5, #16]
20003112:	430a      	orrs	r2, r1
20003114:	611a      	str	r2, [r3, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
20003116:	681a      	ldr	r2, [r3, #0]
20003118:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
2000311c:	601a      	str	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2000311e:	f000 fb97 	bl	20003850 <HAL_GetTick>
20003122:	4605      	mov	r5, r0
20003124:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
20003128:	fa93 f2a3 	rbit	r2, r3

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
2000312c:	6822      	ldr	r2, [r4, #0]
2000312e:	fa93 f3a3 	rbit	r3, r3
20003132:	fab3 f383 	clz	r3, r3
20003136:	f003 031f 	and.w	r3, r3, #31
2000313a:	fa22 f303 	lsr.w	r3, r2, r3
2000313e:	07db      	lsls	r3, r3, #31
20003140:	d406      	bmi.n	20003150 <RCCEx_PLLSAI1_ConfigNP+0xa4>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
20003142:	f000 fb85 	bl	20003850 <HAL_GetTick>
20003146:	1b40      	subs	r0, r0, r5
20003148:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
2000314c:	d9ea      	bls.n	20003124 <RCCEx_PLLSAI1_ConfigNP+0x78>
2000314e:	e7cd      	b.n	200030ec <RCCEx_PLLSAI1_ConfigNP+0x40>
20003150:	2000      	movs	r0, #0
20003152:	bd70      	pop	{r4, r5, r6, pc}
20003154:	40021000 	.word	0x40021000

20003158 <RCCEx_PLLSAI2_ConfigNP>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_ConfigNP(RCC_PLLSAI2InitTypeDef *PllSai2)
{
20003158:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2P_VALUE(PllSai2->PLLSAI2P));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
2000315a:	4c29      	ldr	r4, [pc, #164]	; (20003200 <RCCEx_PLLSAI2_ConfigNP+0xa8>)
2000315c:	6823      	ldr	r3, [r4, #0]
2000315e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20003162:	6023      	str	r3, [r4, #0]
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_ConfigNP(RCC_PLLSAI2InitTypeDef *PllSai2)
{
20003164:	4605      	mov	r5, r0

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
20003166:	f000 fb73 	bl	20003850 <HAL_GetTick>
2000316a:	4606      	mov	r6, r0
2000316c:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
20003170:	fa92 f3a2 	rbit	r3, r2

  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
20003174:	4b22      	ldr	r3, [pc, #136]	; (20003200 <RCCEx_PLLSAI2_ConfigNP+0xa8>)
20003176:	6821      	ldr	r1, [r4, #0]
20003178:	fa92 f2a2 	rbit	r2, r2
2000317c:	fab2 f282 	clz	r2, r2
20003180:	f002 021f 	and.w	r2, r2, #31
20003184:	fa21 f202 	lsr.w	r2, r1, r2
20003188:	07d2      	lsls	r2, r2, #31
2000318a:	d507      	bpl.n	2000319c <RCCEx_PLLSAI2_ConfigNP+0x44>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
2000318c:	f000 fb60 	bl	20003850 <HAL_GetTick>
20003190:	1b80      	subs	r0, r0, r6
20003192:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
20003196:	d9e9      	bls.n	2000316c <RCCEx_PLLSAI2_ConfigNP+0x14>
    {
      status = HAL_TIMEOUT;
20003198:	2003      	movs	r0, #3
2000319a:	bd70      	pop	{r4, r5, r6, pc}
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI2 Multiplication factor N */
    __HAL_RCC_PLLSAI2_MULN_CONFIG(PllSai2->PLLSAI2N);
2000319c:	695a      	ldr	r2, [r3, #20]
2000319e:	6829      	ldr	r1, [r5, #0]
200031a0:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
200031a4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
200031a8:	615a      	str	r2, [r3, #20]
    /* Configure the PLLSAI2 Division factor P */
    __HAL_RCC_PLLSAI2_DIVP_CONFIG(PllSai2->PLLSAI2P);
200031aa:	695a      	ldr	r2, [r3, #20]
200031ac:	6869      	ldr	r1, [r5, #4]
200031ae:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
200031b2:	0909      	lsrs	r1, r1, #4
200031b4:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
200031b8:	615a      	str	r2, [r3, #20]
    /* Configure the PLLSAI2 Clock output(s) */
    __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
200031ba:	6959      	ldr	r1, [r3, #20]
200031bc:	68ea      	ldr	r2, [r5, #12]
200031be:	430a      	orrs	r2, r1
200031c0:	615a      	str	r2, [r3, #20]

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();
200031c2:	681a      	ldr	r2, [r3, #0]
200031c4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
200031c8:	601a      	str	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
200031ca:	f000 fb41 	bl	20003850 <HAL_GetTick>
200031ce:	4605      	mov	r5, r0
200031d0:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
200031d4:	fa93 f2a3 	rbit	r2, r3

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
200031d8:	6822      	ldr	r2, [r4, #0]
200031da:	fa93 f3a3 	rbit	r3, r3
200031de:	fab3 f383 	clz	r3, r3
200031e2:	f003 031f 	and.w	r3, r3, #31
200031e6:	fa22 f303 	lsr.w	r3, r2, r3
200031ea:	07db      	lsls	r3, r3, #31
200031ec:	d406      	bmi.n	200031fc <RCCEx_PLLSAI2_ConfigNP+0xa4>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
200031ee:	f000 fb2f 	bl	20003850 <HAL_GetTick>
200031f2:	1b40      	subs	r0, r0, r5
200031f4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
200031f8:	d9ea      	bls.n	200031d0 <RCCEx_PLLSAI2_ConfigNP+0x78>
200031fa:	e7cd      	b.n	20003198 <RCCEx_PLLSAI2_ConfigNP+0x40>
200031fc:	2000      	movs	r0, #0
200031fe:	bd70      	pop	{r4, r5, r6, pc}
20003200:	40021000 	.word	0x40021000

20003204 <RCCEx_PLLSAI1_ConfigNQ>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PllSai1)
{
20003204:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
20003206:	4c2a      	ldr	r4, [pc, #168]	; (200032b0 <RCCEx_PLLSAI1_ConfigNQ+0xac>)
20003208:	6823      	ldr	r3, [r4, #0]
2000320a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
2000320e:	6023      	str	r3, [r4, #0]
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PllSai1)
{
20003210:	4605      	mov	r5, r0

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
20003212:	f000 fb1d 	bl	20003850 <HAL_GetTick>
20003216:	4606      	mov	r6, r0
20003218:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
2000321c:	fa92 f3a2 	rbit	r3, r2

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
20003220:	4b23      	ldr	r3, [pc, #140]	; (200032b0 <RCCEx_PLLSAI1_ConfigNQ+0xac>)
20003222:	6821      	ldr	r1, [r4, #0]
20003224:	fa92 f2a2 	rbit	r2, r2
20003228:	fab2 f282 	clz	r2, r2
2000322c:	f002 021f 	and.w	r2, r2, #31
20003230:	fa21 f202 	lsr.w	r2, r1, r2
20003234:	07d2      	lsls	r2, r2, #31
20003236:	d507      	bpl.n	20003248 <RCCEx_PLLSAI1_ConfigNQ+0x44>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
20003238:	f000 fb0a 	bl	20003850 <HAL_GetTick>
2000323c:	1b80      	subs	r0, r0, r6
2000323e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
20003242:	d9e9      	bls.n	20003218 <RCCEx_PLLSAI1_ConfigNQ+0x14>
    {
      status = HAL_TIMEOUT;
20003244:	2003      	movs	r0, #3
20003246:	bd70      	pop	{r4, r5, r6, pc}
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PllSai1->PLLSAI1N);
20003248:	691a      	ldr	r2, [r3, #16]
2000324a:	6829      	ldr	r1, [r5, #0]
2000324c:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
20003250:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
20003254:	611a      	str	r2, [r3, #16]
    /* Configure the PLLSAI1 Division factor Q */
    __HAL_RCC_PLLSAI1_DIVQ_CONFIG(PllSai1->PLLSAI1Q);
20003256:	68a9      	ldr	r1, [r5, #8]
20003258:	691a      	ldr	r2, [r3, #16]
2000325a:	0849      	lsrs	r1, r1, #1
2000325c:	3901      	subs	r1, #1
2000325e:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
20003262:	ea42 5241 	orr.w	r2, r2, r1, lsl #21
20003266:	611a      	str	r2, [r3, #16]
    /* Configure the PLLSAI1 Clock output(s) */
    __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
20003268:	6919      	ldr	r1, [r3, #16]
2000326a:	692a      	ldr	r2, [r5, #16]
2000326c:	430a      	orrs	r2, r1
2000326e:	611a      	str	r2, [r3, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
20003270:	681a      	ldr	r2, [r3, #0]
20003272:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
20003276:	601a      	str	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
20003278:	f000 faea 	bl	20003850 <HAL_GetTick>
2000327c:	4605      	mov	r5, r0
2000327e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
20003282:	fa93 f2a3 	rbit	r2, r3

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
20003286:	6822      	ldr	r2, [r4, #0]
20003288:	fa93 f3a3 	rbit	r3, r3
2000328c:	fab3 f383 	clz	r3, r3
20003290:	f003 031f 	and.w	r3, r3, #31
20003294:	fa22 f303 	lsr.w	r3, r2, r3
20003298:	07db      	lsls	r3, r3, #31
2000329a:	d406      	bmi.n	200032aa <RCCEx_PLLSAI1_ConfigNQ+0xa6>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
2000329c:	f000 fad8 	bl	20003850 <HAL_GetTick>
200032a0:	1b40      	subs	r0, r0, r5
200032a2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
200032a6:	d9ea      	bls.n	2000327e <RCCEx_PLLSAI1_ConfigNQ+0x7a>
200032a8:	e7cc      	b.n	20003244 <RCCEx_PLLSAI1_ConfigNQ+0x40>
200032aa:	2000      	movs	r0, #0
200032ac:	bd70      	pop	{r4, r5, r6, pc}
200032ae:	bf00      	nop
200032b0:	40021000 	.word	0x40021000

200032b4 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
200032b4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
200032b8:	6805      	ldr	r5, [r0, #0]
200032ba:	f415 6500 	ands.w	r5, r5, #2048	; 0x800
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
200032be:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
200032c0:	d027      	beq.n	20003312 <HAL_RCCEx_PeriphCLKConfig+0x5e>
  {
    switch(PeriphClkInit->Sai1ClockSelection)
200032c2:	6d43      	ldr	r3, [r0, #84]	; 0x54
200032c4:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
200032c8:	d012      	beq.n	200032f0 <HAL_RCCEx_PeriphCLKConfig+0x3c>
200032ca:	d804      	bhi.n	200032d6 <HAL_RCCEx_PeriphCLKConfig+0x22>
200032cc:	bb03      	cbnz	r3, 20003310 <HAL_RCCEx_PeriphCLKConfig+0x5c>
      /* SAI1 clock source config set later after clock selection check */
      break;

    case RCC_SAI1CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI1*/
      /* PLLSAI1 parameters N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
200032ce:	3004      	adds	r0, #4
200032d0:	f7ff feec 	bl	200030ac <RCCEx_PLLSAI1_ConfigNP>
200032d4:	e00f      	b.n	200032f6 <HAL_RCCEx_PeriphCLKConfig+0x42>
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
  {
    switch(PeriphClkInit->Sai1ClockSelection)
200032d6:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
200032da:	d003      	beq.n	200032e4 <HAL_RCCEx_PeriphCLKConfig+0x30>
200032dc:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
200032e0:	d00b      	beq.n	200032fa <HAL_RCCEx_PeriphCLKConfig+0x46>
200032e2:	e015      	b.n	20003310 <HAL_RCCEx_PeriphCLKConfig+0x5c>
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
200032e4:	4a6b      	ldr	r2, [pc, #428]	; (20003494 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
200032e6:	68d3      	ldr	r3, [r2, #12]
200032e8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200032ec:	60d3      	str	r3, [r2, #12]
      /* SAI1 clock source config set later after clock selection check */
      break;
200032ee:	e004      	b.n	200032fa <HAL_RCCEx_PeriphCLKConfig+0x46>
      /* SAI1 clock source config set later after clock selection check */
      break;

    case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
      /* PLLSAI2 parameters N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_ConfigNP(&(PeriphClkInit->PLLSAI2));
200032f0:	3018      	adds	r0, #24
200032f2:	f7ff ff31 	bl	20003158 <RCCEx_PLLSAI2_ConfigNP>
200032f6:	4605      	mov	r5, r0
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
200032f8:	b958      	cbnz	r0, 20003312 <HAL_RCCEx_PeriphCLKConfig+0x5e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
200032fa:	4966      	ldr	r1, [pc, #408]	; (20003494 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
200032fc:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
20003300:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
20003304:	6d63      	ldr	r3, [r4, #84]	; 0x54
20003306:	4313      	orrs	r3, r2
20003308:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
2000330c:	2500      	movs	r5, #0
2000330e:	e000      	b.n	20003312 <HAL_RCCEx_PeriphCLKConfig+0x5e>
    case RCC_SAI1CLKSOURCE_PIN:      /* External clock is used as source of SAI1 clock*/
      /* SAI1 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20003310:	2501      	movs	r5, #1
      status = ret;
    }
  }

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
20003312:	6823      	ldr	r3, [r4, #0]
20003314:	04d9      	lsls	r1, r3, #19
20003316:	d529      	bpl.n	2000336c <HAL_RCCEx_PeriphCLKConfig+0xb8>
  {
    switch(PeriphClkInit->Sai2ClockSelection)
20003318:	6da3      	ldr	r3, [r4, #88]	; 0x58
2000331a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000331e:	d012      	beq.n	20003346 <HAL_RCCEx_PeriphCLKConfig+0x92>
20003320:	d804      	bhi.n	2000332c <HAL_RCCEx_PeriphCLKConfig+0x78>
20003322:	bb13      	cbnz	r3, 2000336a <HAL_RCCEx_PeriphCLKConfig+0xb6>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
      /* PLLSAI1 parameters N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
20003324:	1d20      	adds	r0, r4, #4
20003326:	f7ff fec1 	bl	200030ac <RCCEx_PLLSAI1_ConfigNP>
2000332a:	e010      	b.n	2000334e <HAL_RCCEx_PeriphCLKConfig+0x9a>
  }

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
  {
    switch(PeriphClkInit->Sai2ClockSelection)
2000332c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20003330:	d003      	beq.n	2000333a <HAL_RCCEx_PeriphCLKConfig+0x86>
20003332:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
20003336:	d00c      	beq.n	20003352 <HAL_RCCEx_PeriphCLKConfig+0x9e>
20003338:	e017      	b.n	2000336a <HAL_RCCEx_PeriphCLKConfig+0xb6>
    {
    case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
2000333a:	4a56      	ldr	r2, [pc, #344]	; (20003494 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
2000333c:	68d3      	ldr	r3, [r2, #12]
2000333e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20003342:	60d3      	str	r3, [r2, #12]
20003344:	e005      	b.n	20003352 <HAL_RCCEx_PeriphCLKConfig+0x9e>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
      /* PLLSAI2 parameters N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_ConfigNP(&(PeriphClkInit->PLLSAI2));
20003346:	f104 0018 	add.w	r0, r4, #24
2000334a:	f7ff ff05 	bl	20003158 <RCCEx_PLLSAI2_ConfigNP>
2000334e:	4607      	mov	r7, r0
      /* SAI2 clock source config set later after clock selection check */
      break;
20003350:	e000      	b.n	20003354 <HAL_RCCEx_PeriphCLKConfig+0xa0>
  }

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
  {
    switch(PeriphClkInit->Sai2ClockSelection)
20003352:	462f      	mov	r7, r5
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
20003354:	b967      	cbnz	r7, 20003370 <HAL_RCCEx_PeriphCLKConfig+0xbc>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
20003356:	494f      	ldr	r1, [pc, #316]	; (20003494 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
20003358:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
2000335c:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
20003360:	6da3      	ldr	r3, [r4, #88]	; 0x58
20003362:	4313      	orrs	r3, r2
20003364:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
20003368:	e003      	b.n	20003372 <HAL_RCCEx_PeriphCLKConfig+0xbe>
    case RCC_SAI2CLKSOURCE_PIN:      /* External clock is used as source of SAI2 clock*/
      /* SAI2 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2000336a:	2501      	movs	r5, #1
2000336c:	462f      	mov	r7, r5
2000336e:	e000      	b.n	20003372 <HAL_RCCEx_PeriphCLKConfig+0xbe>
20003370:	463d      	mov	r5, r7
      status = ret;
    }
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
20003372:	6823      	ldr	r3, [r4, #0]
20003374:	039a      	lsls	r2, r3, #14
20003376:	f140 8092 	bpl.w	2000349e <HAL_RCCEx_PeriphCLKConfig+0x1ea>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    if(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL) != PeriphClkInit->RTCClockSelection)
2000337a:	4e46      	ldr	r6, [pc, #280]	; (20003494 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
2000337c:	6f62      	ldr	r2, [r4, #116]	; 0x74
2000337e:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
20003382:	f403 7340 	and.w	r3, r3, #768	; 0x300
20003386:	4293      	cmp	r3, r2
20003388:	f000 8088 	beq.w	2000349c <HAL_RCCEx_PeriphCLKConfig+0x1e8>
    {
      /* Enable Power Clock */
      if(__HAL_RCC_PWR_IS_CLK_DISABLED())
2000338c:	6db3      	ldr	r3, [r6, #88]	; 0x58
        __HAL_RCC_PWR_CLK_ENABLE();
        pwrclkchanged = SET;
      }
      
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
2000338e:	4a42      	ldr	r2, [pc, #264]	; (20003498 <HAL_RCCEx_PeriphCLKConfig+0x1e4>)
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    if(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL) != PeriphClkInit->RTCClockSelection)
    {
      /* Enable Power Clock */
      if(__HAL_RCC_PWR_IS_CLK_DISABLED())
20003390:	00db      	lsls	r3, r3, #3
      {
        __HAL_RCC_PWR_CLK_ENABLE();
20003392:	bf5f      	itttt	pl
20003394:	6db3      	ldrpl	r3, [r6, #88]	; 0x58
20003396:	f043 5380 	orrpl.w	r3, r3, #268435456	; 0x10000000
2000339a:	65b3      	strpl	r3, [r6, #88]	; 0x58
2000339c:	6db3      	ldrpl	r3, [r6, #88]	; 0x58
2000339e:	bf5e      	ittt	pl
200033a0:	f003 5380 	andpl.w	r3, r3, #268435456	; 0x10000000
200033a4:	9301      	strpl	r3, [sp, #4]
200033a6:	9b01      	ldrpl	r3, [sp, #4]
        pwrclkchanged = SET;
      }
      
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
200033a8:	6813      	ldr	r3, [r2, #0]
200033aa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200033ae:	6013      	str	r3, [r2, #0]
    {
      /* Enable Power Clock */
      if(__HAL_RCC_PWR_IS_CLK_DISABLED())
      {
        __HAL_RCC_PWR_CLK_ENABLE();
        pwrclkchanged = SET;
200033b0:	bf54      	ite	pl
200033b2:	f04f 0801 	movpl.w	r8, #1
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
  {
    FlagStatus       pwrclkchanged = RESET;
200033b6:	f04f 0800 	movmi.w	r8, #0
      
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
200033ba:	f000 fa49 	bl	20003850 <HAL_GetTick>
200033be:	4682      	mov	sl, r0

      while((PWR->CR1 & PWR_CR1_DBP) == RESET)
200033c0:	4b35      	ldr	r3, [pc, #212]	; (20003498 <HAL_RCCEx_PeriphCLKConfig+0x1e4>)
200033c2:	681b      	ldr	r3, [r3, #0]
200033c4:	f413 7980 	ands.w	r9, r3, #256	; 0x100
200033c8:	d108      	bne.n	200033dc <HAL_RCCEx_PeriphCLKConfig+0x128>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
200033ca:	f000 fa41 	bl	20003850 <HAL_GetTick>
200033ce:	ebca 0000 	rsb	r0, sl, r0
200033d2:	2864      	cmp	r0, #100	; 0x64
200033d4:	d9f4      	bls.n	200033c0 <HAL_RCCEx_PeriphCLKConfig+0x10c>
        {
          ret = HAL_TIMEOUT;
200033d6:	2703      	movs	r7, #3
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
  uint32_t tmpreg = 0;
200033d8:	464b      	mov	r3, r9
200033da:	e014      	b.n	20003406 <HAL_RCCEx_PeriphCLKConfig+0x152>
          ret = HAL_TIMEOUT;
          break;
        }
      }

      if(ret == HAL_OK)
200033dc:	b997      	cbnz	r7, 20003404 <HAL_RCCEx_PeriphCLKConfig+0x150>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
200033de:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
200033e2:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
200033e6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
200033ea:	f8c6 2090 	str.w	r2, [r6, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
200033ee:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
      }

      if(ret == HAL_OK)
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
200033f2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
        __HAL_RCC_BACKUPRESET_RELEASE();
200033f6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
200033fa:	f8c6 2090 	str.w	r2, [r6, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
200033fe:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
20003402:	e000      	b.n	20003406 <HAL_RCCEx_PeriphCLKConfig+0x152>
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
  uint32_t tmpreg = 0;
20003404:	2300      	movs	r3, #0
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpreg, RCC_BDCR_LSERDY))
20003406:	0798      	lsls	r0, r3, #30
20003408:	d401      	bmi.n	2000340e <HAL_RCCEx_PeriphCLKConfig+0x15a>
            break;
          }
        }
      }
      
      if(ret == HAL_OK)
2000340a:	b397      	cbz	r7, 20003472 <HAL_RCCEx_PeriphCLKConfig+0x1be>
2000340c:	e046      	b.n	2000349c <HAL_RCCEx_PeriphCLKConfig+0x1e8>

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpreg, RCC_BDCR_LSERDY))
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000340e:	f000 fa1f 	bl	20003850 <HAL_GetTick>
20003412:	4681      	mov	r9, r0
20003414:	2302      	movs	r3, #2
20003416:	fa93 f2a3 	rbit	r2, r3
2000341a:	fa93 f2a3 	rbit	r2, r3

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
2000341e:	fab2 f282 	clz	r2, r2
20003422:	f042 0240 	orr.w	r2, r2, #64	; 0x40
20003426:	0952      	lsrs	r2, r2, #5
20003428:	429a      	cmp	r2, r3
2000342a:	d102      	bne.n	20003432 <HAL_RCCEx_PeriphCLKConfig+0x17e>
2000342c:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
20003430:	e00b      	b.n	2000344a <HAL_RCCEx_PeriphCLKConfig+0x196>
20003432:	fa93 f3a3 	rbit	r3, r3
20003436:	fab3 f383 	clz	r3, r3
2000343a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2000343e:	095b      	lsrs	r3, r3, #5
20003440:	2b03      	cmp	r3, #3
20003442:	bf0c      	ite	eq
20003444:	f8d6 2094 	ldreq.w	r2, [r6, #148]	; 0x94
20003448:	69f2      	ldrne	r2, [r6, #28]
2000344a:	2302      	movs	r3, #2
2000344c:	fa93 f3a3 	rbit	r3, r3
20003450:	fab3 f383 	clz	r3, r3
20003454:	f003 031f 	and.w	r3, r3, #31
20003458:	40da      	lsrs	r2, r3
2000345a:	07d1      	lsls	r1, r2, #31
2000345c:	d4d5      	bmi.n	2000340a <HAL_RCCEx_PeriphCLKConfig+0x156>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
2000345e:	f000 f9f7 	bl	20003850 <HAL_GetTick>
20003462:	f241 3388 	movw	r3, #5000	; 0x1388
20003466:	ebc9 0000 	rsb	r0, r9, r0
2000346a:	4298      	cmp	r0, r3
2000346c:	d9d2      	bls.n	20003414 <HAL_RCCEx_PeriphCLKConfig+0x160>
          {
            ret = HAL_TIMEOUT;
2000346e:	2503      	movs	r5, #3
20003470:	e015      	b.n	2000349e <HAL_RCCEx_PeriphCLKConfig+0x1ea>
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
20003472:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
20003476:	4907      	ldr	r1, [pc, #28]	; (20003494 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
20003478:	f423 7240 	bic.w	r2, r3, #768	; 0x300
2000347c:	6f63      	ldr	r3, [r4, #116]	; 0x74
2000347e:	4313      	orrs	r3, r2
20003480:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
        
        /* Restore clock configuration if changed */
        if(pwrclkchanged == SET)
20003484:	f1b8 0f00 	cmp.w	r8, #0
20003488:	d009      	beq.n	2000349e <HAL_RCCEx_PeriphCLKConfig+0x1ea>
        {
          __HAL_RCC_PWR_CLK_DISABLE();
2000348a:	6d8b      	ldr	r3, [r1, #88]	; 0x58
2000348c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20003490:	658b      	str	r3, [r1, #88]	; 0x58
20003492:	e004      	b.n	2000349e <HAL_RCCEx_PeriphCLKConfig+0x1ea>
20003494:	40021000 	.word	0x40021000
20003498:	40007000 	.word	0x40007000
2000349c:	463d      	mov	r5, r7
      status = ret;
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
2000349e:	6823      	ldr	r3, [r4, #0]
200034a0:	07da      	lsls	r2, r3, #31
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
200034a2:	bf41      	itttt	mi
200034a4:	4892      	ldrmi	r0, [pc, #584]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
200034a6:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
200034aa:	f022 0103 	bicmi.w	r1, r2, #3
200034ae:	6aa2      	ldrmi	r2, [r4, #40]	; 0x28
200034b0:	bf44      	itt	mi
200034b2:	430a      	orrmi	r2, r1
200034b4:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
200034b8:	079f      	lsls	r7, r3, #30
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
200034ba:	bf41      	itttt	mi
200034bc:	488c      	ldrmi	r0, [pc, #560]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
200034be:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
200034c2:	f022 010c 	bicmi.w	r1, r2, #12
200034c6:	6ae2      	ldrmi	r2, [r4, #44]	; 0x2c
200034c8:	bf44      	itt	mi
200034ca:	430a      	orrmi	r2, r1
200034cc:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
200034d0:	075e      	lsls	r6, r3, #29
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
200034d2:	bf41      	itttt	mi
200034d4:	4886      	ldrmi	r0, [pc, #536]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
200034d6:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
200034da:	f022 0130 	bicmi.w	r1, r2, #48	; 0x30
200034de:	6b22      	ldrmi	r2, [r4, #48]	; 0x30
200034e0:	bf44      	itt	mi
200034e2:	430a      	orrmi	r2, r1
200034e4:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
200034e8:	0718      	lsls	r0, r3, #28
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
200034ea:	bf41      	itttt	mi
200034ec:	4880      	ldrmi	r0, [pc, #512]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
200034ee:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
200034f2:	f022 01c0 	bicmi.w	r1, r2, #192	; 0xc0
200034f6:	6b62      	ldrmi	r2, [r4, #52]	; 0x34
200034f8:	bf44      	itt	mi
200034fa:	430a      	orrmi	r2, r1
200034fc:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
20003500:	06d9      	lsls	r1, r3, #27
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
20003502:	bf41      	itttt	mi
20003504:	487a      	ldrmi	r0, [pc, #488]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
20003506:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
2000350a:	f422 7140 	bicmi.w	r1, r2, #768	; 0x300
2000350e:	6ba2      	ldrmi	r2, [r4, #56]	; 0x38
20003510:	bf44      	itt	mi
20003512:	430a      	orrmi	r2, r1
20003514:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
20003518:	069a      	lsls	r2, r3, #26
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
2000351a:	bf41      	itttt	mi
2000351c:	4874      	ldrmi	r0, [pc, #464]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
2000351e:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
20003522:	f422 6140 	bicmi.w	r1, r2, #3072	; 0xc00
20003526:	6be2      	ldrmi	r2, [r4, #60]	; 0x3c
20003528:	bf44      	itt	mi
2000352a:	430a      	orrmi	r2, r1
2000352c:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
20003530:	059f      	lsls	r7, r3, #22
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
20003532:	bf41      	itttt	mi
20003534:	486e      	ldrmi	r0, [pc, #440]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
20003536:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
2000353a:	f422 2140 	bicmi.w	r1, r2, #786432	; 0xc0000
2000353e:	6ce2      	ldrmi	r2, [r4, #76]	; 0x4c
20003540:	bf44      	itt	mi
20003542:	430a      	orrmi	r2, r1
20003544:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
20003548:	055e      	lsls	r6, r3, #21
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
2000354a:	bf41      	itttt	mi
2000354c:	4868      	ldrmi	r0, [pc, #416]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
2000354e:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
20003552:	f422 1140 	bicmi.w	r1, r2, #3145728	; 0x300000
20003556:	6d22      	ldrmi	r2, [r4, #80]	; 0x50
20003558:	bf44      	itt	mi
2000355a:	430a      	orrmi	r2, r1
2000355c:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
20003560:	0658      	lsls	r0, r3, #25
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
20003562:	bf41      	itttt	mi
20003564:	4862      	ldrmi	r0, [pc, #392]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
20003566:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
2000356a:	f422 5140 	bicmi.w	r1, r2, #12288	; 0x3000
2000356e:	6c22      	ldrmi	r2, [r4, #64]	; 0x40
20003570:	bf44      	itt	mi
20003572:	430a      	orrmi	r2, r1
20003574:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
20003578:	0619      	lsls	r1, r3, #24
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
2000357a:	bf41      	itttt	mi
2000357c:	485c      	ldrmi	r0, [pc, #368]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
2000357e:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
20003582:	f422 4140 	bicmi.w	r1, r2, #49152	; 0xc000
20003586:	6c62      	ldrmi	r2, [r4, #68]	; 0x44
20003588:	bf44      	itt	mi
2000358a:	430a      	orrmi	r2, r1
2000358c:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
20003590:	05da      	lsls	r2, r3, #23
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
20003592:	bf41      	itttt	mi
20003594:	4856      	ldrmi	r0, [pc, #344]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
20003596:	f8d0 2088 	ldrmi.w	r2, [r0, #136]	; 0x88
2000359a:	f422 3140 	bicmi.w	r1, r2, #196608	; 0x30000
2000359e:	6ca2      	ldrmi	r2, [r4, #72]	; 0x48
200035a0:	bf44      	itt	mi
200035a2:	430a      	orrmi	r2, r1
200035a4:	f8c0 2088 	strmi.w	r2, [r0, #136]	; 0x88
  }

#if defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
200035a8:	049f      	lsls	r7, r3, #18
200035aa:	d519      	bpl.n	200035e0 <HAL_RCCEx_PeriphCLKConfig+0x32c>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
200035ac:	4a50      	ldr	r2, [pc, #320]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
200035ae:	6de1      	ldr	r1, [r4, #92]	; 0x5c
200035b0:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
200035b4:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
200035b8:	430b      	orrs	r3, r1

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
200035ba:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
#if defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
200035be:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
200035c2:	d104      	bne.n	200035ce <HAL_RCCEx_PeriphCLKConfig+0x31a>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
200035c4:	68d3      	ldr	r3, [r2, #12]
200035c6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
200035ca:	60d3      	str	r3, [r2, #12]
200035cc:	e008      	b.n	200035e0 <HAL_RCCEx_PeriphCLKConfig+0x32c>
    }
    else if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
200035ce:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
200035d2:	d105      	bne.n	200035e0 <HAL_RCCEx_PeriphCLKConfig+0x32c>
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
200035d4:	1d20      	adds	r0, r4, #4
200035d6:	f7ff fe15 	bl	20003204 <RCCEx_PLLSAI1_ConfigNQ>
      
      if(ret != HAL_OK)
200035da:	2800      	cmp	r0, #0
200035dc:	bf18      	it	ne
200035de:	4605      	movne	r5, r0
    }
  }
#endif /* STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
200035e0:	6823      	ldr	r3, [r4, #0]
200035e2:	031e      	lsls	r6, r3, #12
200035e4:	d519      	bpl.n	2000361a <HAL_RCCEx_PeriphCLKConfig+0x366>
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
200035e6:	4a42      	ldr	r2, [pc, #264]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
200035e8:	6e21      	ldr	r1, [r4, #96]	; 0x60
200035ea:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
200035ee:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
200035f2:	430b      	orrs	r3, r1
    
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)
200035f4:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
200035f8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)
200035fc:	d104      	bne.n	20003608 <HAL_RCCEx_PeriphCLKConfig+0x354>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
200035fe:	68d3      	ldr	r3, [r2, #12]
20003600:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20003604:	60d3      	str	r3, [r2, #12]
20003606:	e008      	b.n	2000361a <HAL_RCCEx_PeriphCLKConfig+0x366>
    }
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
20003608:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
2000360c:	d105      	bne.n	2000361a <HAL_RCCEx_PeriphCLKConfig+0x366>
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
2000360e:	1d20      	adds	r0, r4, #4
20003610:	f7ff fdf8 	bl	20003204 <RCCEx_PLLSAI1_ConfigNQ>
      
      if(ret != HAL_OK)
20003614:	2800      	cmp	r0, #0
20003616:	bf18      	it	ne
20003618:	4605      	movne	r5, r0
      }
    }
  }

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
2000361a:	6823      	ldr	r3, [r4, #0]
2000361c:	0358      	lsls	r0, r3, #13
2000361e:	d519      	bpl.n	20003654 <HAL_RCCEx_PeriphCLKConfig+0x3a0>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
20003620:	4a33      	ldr	r2, [pc, #204]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
20003622:	6e61      	ldr	r1, [r4, #100]	; 0x64
20003624:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
20003628:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
2000362c:	430b      	orrs	r3, r1

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
2000362e:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
20003632:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
20003636:	d104      	bne.n	20003642 <HAL_RCCEx_PeriphCLKConfig+0x38e>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
20003638:	68d3      	ldr	r3, [r2, #12]
2000363a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
2000363e:	60d3      	str	r3, [r2, #12]
20003640:	e008      	b.n	20003654 <HAL_RCCEx_PeriphCLKConfig+0x3a0>
    }
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
20003642:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
20003646:	d105      	bne.n	20003654 <HAL_RCCEx_PeriphCLKConfig+0x3a0>
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
20003648:	1d20      	adds	r0, r4, #4
2000364a:	f7ff fddb 	bl	20003204 <RCCEx_PLLSAI1_ConfigNQ>
      
      if(ret != HAL_OK)
2000364e:	2800      	cmp	r0, #0
20003650:	bf18      	it	ne
20003652:	4605      	movne	r5, r0
      }
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
20003654:	6823      	ldr	r3, [r4, #0]
20003656:	0459      	lsls	r1, r3, #17
20003658:	d57c      	bpl.n	20003754 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
2000365a:	4e25      	ldr	r6, [pc, #148]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
2000365c:	6ea2      	ldr	r2, [r4, #104]	; 0x68
2000365e:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
20003662:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
20003666:	4313      	orrs	r3, r2
    
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
20003668:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
2000366c:	f8c6 3088 	str.w	r3, [r6, #136]	; 0x88
    
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
20003670:	d11d      	bne.n	200036ae <HAL_RCCEx_PeriphCLKConfig+0x3fa>
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
20003672:	6833      	ldr	r3, [r6, #0]
20003674:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
20003678:	6033      	str	r3, [r6, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
2000367a:	f000 f8e9 	bl	20003850 <HAL_GetTick>
2000367e:	4607      	mov	r7, r0
20003680:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
20003684:	fa92 f3a2 	rbit	r3, r2

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
20003688:	4b19      	ldr	r3, [pc, #100]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
2000368a:	6831      	ldr	r1, [r6, #0]
2000368c:	fa92 f2a2 	rbit	r2, r2
20003690:	fab2 f282 	clz	r2, r2
20003694:	f002 021f 	and.w	r2, r2, #31
20003698:	fa21 f202 	lsr.w	r2, r1, r2
2000369c:	07d2      	lsls	r2, r2, #31
2000369e:	d529      	bpl.n	200036f4 <HAL_RCCEx_PeriphCLKConfig+0x440>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
200036a0:	f000 f8d6 	bl	20003850 <HAL_GetTick>
200036a4:	1bc0      	subs	r0, r0, r7
200036a6:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
200036aa:	d9e9      	bls.n	20003680 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
200036ac:	e052      	b.n	20003754 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
    {
      /* PLLSAI1 parameters N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNR(&(PeriphClkInit->PLLSAI1));
    }
    else if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI2)
200036ae:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
200036b2:	d14f      	bne.n	20003754 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2R_VALUE(PllSai2->PLLSAI2R));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
200036b4:	6833      	ldr	r3, [r6, #0]
200036b6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
200036ba:	6033      	str	r3, [r6, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
200036bc:	f000 f8c8 	bl	20003850 <HAL_GetTick>
200036c0:	4607      	mov	r7, r0
200036c2:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
200036c6:	fa92 f3a2 	rbit	r3, r2

  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
200036ca:	4b09      	ldr	r3, [pc, #36]	; (200036f0 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
200036cc:	6831      	ldr	r1, [r6, #0]
200036ce:	fa92 f2a2 	rbit	r2, r2
200036d2:	fab2 f282 	clz	r2, r2
200036d6:	f002 021f 	and.w	r2, r2, #31
200036da:	fa21 f202 	lsr.w	r2, r1, r2
200036de:	07d0      	lsls	r0, r2, #31
200036e0:	d551      	bpl.n	20003786 <HAL_RCCEx_PeriphCLKConfig+0x4d2>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
200036e2:	f000 f8b5 	bl	20003850 <HAL_GetTick>
200036e6:	1bc0      	subs	r0, r0, r7
200036e8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
200036ec:	d9e9      	bls.n	200036c2 <HAL_RCCEx_PeriphCLKConfig+0x40e>
200036ee:	e07a      	b.n	200037e6 <HAL_RCCEx_PeriphCLKConfig+0x532>
200036f0:	40021000 	.word	0x40021000
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PllSai1->PLLSAI1N);
200036f4:	691a      	ldr	r2, [r3, #16]
200036f6:	6861      	ldr	r1, [r4, #4]
200036f8:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
200036fc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
20003700:	611a      	str	r2, [r3, #16]
    /* Configure the PLLSAI1 Division factor R */
    __HAL_RCC_PLLSAI1_DIVR_CONFIG(PllSai1->PLLSAI1R);
20003702:	6921      	ldr	r1, [r4, #16]
20003704:	691a      	ldr	r2, [r3, #16]
20003706:	0849      	lsrs	r1, r1, #1
20003708:	3901      	subs	r1, #1
2000370a:	f022 62c0 	bic.w	r2, r2, #100663296	; 0x6000000
2000370e:	ea42 6241 	orr.w	r2, r2, r1, lsl #25
20003712:	611a      	str	r2, [r3, #16]
    /* Configure the PLLSAI1 Clock output(s) */
    __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
20003714:	6919      	ldr	r1, [r3, #16]
20003716:	6962      	ldr	r2, [r4, #20]
20003718:	430a      	orrs	r2, r1
2000371a:	611a      	str	r2, [r3, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
2000371c:	681a      	ldr	r2, [r3, #0]
2000371e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
20003722:	601a      	str	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
20003724:	f000 f894 	bl	20003850 <HAL_GetTick>
20003728:	4607      	mov	r7, r0
2000372a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
2000372e:	fa93 f2a3 	rbit	r2, r3

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
20003732:	6832      	ldr	r2, [r6, #0]
20003734:	fa93 f3a3 	rbit	r3, r3
20003738:	fab3 f383 	clz	r3, r3
2000373c:	f003 031f 	and.w	r3, r3, #31
20003740:	fa22 f303 	lsr.w	r3, r2, r3
20003744:	07db      	lsls	r3, r3, #31
20003746:	d405      	bmi.n	20003754 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
20003748:	f000 f882 	bl	20003850 <HAL_GetTick>
2000374c:	1bc0      	subs	r0, r0, r7
2000374e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
20003752:	d9ea      	bls.n	2000372a <HAL_RCCEx_PeriphCLKConfig+0x476>
      }
    }
  }

  /*-------------------------- SWPMI1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
20003754:	6821      	ldr	r1, [r4, #0]
20003756:	040a      	lsls	r2, r1, #16
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
20003758:	bf41      	itttt	mi
2000375a:	4826      	ldrmi	r0, [pc, #152]	; (200037f4 <HAL_RCCEx_PeriphCLKConfig+0x540>)
2000375c:	f8d0 3088 	ldrmi.w	r3, [r0, #136]	; 0x88
20003760:	f023 4280 	bicmi.w	r2, r3, #1073741824	; 0x40000000
20003764:	6ee3      	ldrmi	r3, [r4, #108]	; 0x6c
20003766:	bf44      	itt	mi
20003768:	4313      	orrmi	r3, r2
2000376a:	f8c0 3088 	strmi.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------------- DFSDM clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM) == RCC_PERIPHCLK_DFSDM)
2000376e:	03cb      	lsls	r3, r1, #15
20003770:	d53b      	bpl.n	200037ea <HAL_RCCEx_PeriphCLKConfig+0x536>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDMCLKSOURCE(PeriphClkInit->DfsdmClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM_CONFIG(PeriphClkInit->DfsdmClockSelection);
20003772:	4920      	ldr	r1, [pc, #128]	; (200037f4 <HAL_RCCEx_PeriphCLKConfig+0x540>)
20003774:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
20003778:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
2000377c:	6f23      	ldr	r3, [r4, #112]	; 0x70
2000377e:	4313      	orrs	r3, r2
20003780:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
20003784:	e031      	b.n	200037ea <HAL_RCCEx_PeriphCLKConfig+0x536>
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI2 Multiplication factor N */
    __HAL_RCC_PLLSAI2_MULN_CONFIG(PllSai2->PLLSAI2N);
20003786:	695a      	ldr	r2, [r3, #20]
20003788:	69a1      	ldr	r1, [r4, #24]
2000378a:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
2000378e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
20003792:	615a      	str	r2, [r3, #20]
    /* Configure the PLLSAI2 Division factor R */
    __HAL_RCC_PLLSAI2_DIVR_CONFIG(PllSai2->PLLSAI2R);
20003794:	6a21      	ldr	r1, [r4, #32]
20003796:	695a      	ldr	r2, [r3, #20]
20003798:	0849      	lsrs	r1, r1, #1
2000379a:	3901      	subs	r1, #1
2000379c:	f022 62c0 	bic.w	r2, r2, #100663296	; 0x6000000
200037a0:	ea42 6241 	orr.w	r2, r2, r1, lsl #25
200037a4:	615a      	str	r2, [r3, #20]
    /* Configure the PLLSAI2 Clock output(s) */
    __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
200037a6:	6959      	ldr	r1, [r3, #20]
200037a8:	6a62      	ldr	r2, [r4, #36]	; 0x24
200037aa:	430a      	orrs	r2, r1
200037ac:	615a      	str	r2, [r3, #20]

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();
200037ae:	681a      	ldr	r2, [r3, #0]
200037b0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
200037b4:	601a      	str	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
200037b6:	f000 f84b 	bl	20003850 <HAL_GetTick>
200037ba:	4607      	mov	r7, r0
200037bc:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
200037c0:	fa93 f2a3 	rbit	r2, r3

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
200037c4:	6832      	ldr	r2, [r6, #0]
200037c6:	fa93 f3a3 	rbit	r3, r3
200037ca:	fab3 f383 	clz	r3, r3
200037ce:	f003 031f 	and.w	r3, r3, #31
200037d2:	fa22 f303 	lsr.w	r3, r2, r3
200037d6:	07d9      	lsls	r1, r3, #31
200037d8:	d4bc      	bmi.n	20003754 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
200037da:	f000 f839 	bl	20003850 <HAL_GetTick>
200037de:	1bc0      	subs	r0, r0, r7
200037e0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
200037e4:	d9ea      	bls.n	200037bc <HAL_RCCEx_PeriphCLKConfig+0x508>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
      
      if(ret != HAL_OK)
200037e6:	2503      	movs	r5, #3
200037e8:	e7b4      	b.n	20003754 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM_CONFIG(PeriphClkInit->DfsdmClockSelection);
  }

  return status;
}
200037ea:	4628      	mov	r0, r5
200037ec:	b002      	add	sp, #8
200037ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
200037f2:	bf00      	nop
200037f4:	40021000 	.word	0x40021000

200037f8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
200037f8:	b510      	push	{r4, lr}
200037fa:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
200037fc:	f7ff fc10 	bl	20003020 <HAL_RCC_GetHCLKFreq>
20003800:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
20003804:	fbb0 f0f3 	udiv	r0, r0, r3
20003808:	f000 f894 	bl	20003934 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
2000380c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20003810:	4621      	mov	r1, r4
20003812:	2200      	movs	r2, #0
20003814:	f000 f840 	bl	20003898 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
20003818:	2000      	movs	r0, #0
2000381a:	bd10      	pop	{r4, pc}

2000381c <HAL_Init>:
#if (DATA_CACHE_ENABLE == 0)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
2000381c:	4a07      	ldr	r2, [pc, #28]	; (2000383c <HAL_Init+0x20>)
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
2000381e:	b508      	push	{r3, lr}
#if (DATA_CACHE_ENABLE == 0)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
20003820:	6813      	ldr	r3, [r2, #0]
20003822:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20003826:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
20003828:	2003      	movs	r0, #3
2000382a:	f000 f823 	bl	20003874 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
2000382e:	2000      	movs	r0, #0
20003830:	f7ff ffe2 	bl	200037f8 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
20003834:	f7fc fede 	bl	200005f4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
20003838:	2000      	movs	r0, #0
2000383a:	bd08      	pop	{r3, pc}
2000383c:	40022000 	.word	0x40022000

20003840 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
20003840:	4a02      	ldr	r2, [pc, #8]	; (2000384c <HAL_IncTick+0xc>)
20003842:	6813      	ldr	r3, [r2, #0]
20003844:	3301      	adds	r3, #1
20003846:	6013      	str	r3, [r2, #0]
20003848:	4770      	bx	lr
2000384a:	bf00      	nop
2000384c:	20006a64 	.word	0x20006a64

20003850 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
20003850:	4b01      	ldr	r3, [pc, #4]	; (20003858 <HAL_GetTick+0x8>)
20003852:	6818      	ldr	r0, [r3, #0]
}
20003854:	4770      	bx	lr
20003856:	bf00      	nop
20003858:	20006a64 	.word	0x20006a64

2000385c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
2000385c:	b538      	push	{r3, r4, r5, lr}
2000385e:	4604      	mov	r4, r0
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
20003860:	f7ff fff6 	bl	20003850 <HAL_GetTick>
20003864:	4605      	mov	r5, r0
  while((HAL_GetTick() - tickstart) < Delay)
20003866:	f7ff fff3 	bl	20003850 <HAL_GetTick>
2000386a:	1b40      	subs	r0, r0, r5
2000386c:	42a0      	cmp	r0, r4
2000386e:	d3fa      	bcc.n	20003866 <HAL_Delay+0xa>
  {
  }
}
20003870:	bd38      	pop	{r3, r4, r5, pc}
	...

20003874 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
20003874:	4a07      	ldr	r2, [pc, #28]	; (20003894 <HAL_NVIC_SetPriorityGrouping+0x20>)
20003876:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
20003878:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
2000387c:	041b      	lsls	r3, r3, #16
2000387e:	0c1b      	lsrs	r3, r3, #16
20003880:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
20003884:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
20003888:	f000 0007 	and.w	r0, r0, #7

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
2000388c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
20003890:	60d3      	str	r3, [r2, #12]
20003892:	4770      	bx	lr
20003894:	e000ed00 	.word	0xe000ed00

20003898 <HAL_NVIC_SetPriority>:

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
20003898:	4b15      	ldr	r3, [pc, #84]	; (200038f0 <HAL_NVIC_SetPriority+0x58>)
2000389a:	68db      	ldr	r3, [r3, #12]
2000389c:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
200038a0:	b570      	push	{r4, r5, r6, lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
200038a2:	f1c3 0507 	rsb	r5, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
200038a6:	1d1c      	adds	r4, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
200038a8:	2d04      	cmp	r5, #4
200038aa:	bf28      	it	cs
200038ac:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
200038ae:	2c06      	cmp	r4, #6
200038b0:	bf8c      	ite	hi
200038b2:	3b03      	subhi	r3, #3
200038b4:	2300      	movls	r3, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
200038b6:	2401      	movs	r4, #1
200038b8:	fa04 f603 	lsl.w	r6, r4, r3

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
200038bc:	40ac      	lsls	r4, r5
200038be:	3c01      	subs	r4, #1
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
200038c0:	3e01      	subs	r6, #1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
200038c2:	4021      	ands	r1, r4
200038c4:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
200038c6:	4032      	ands	r2, r6
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
200038c8:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
200038ca:	ea42 0201 	orr.w	r2, r2, r1
200038ce:	ea4f 1202 	mov.w	r2, r2, lsl #4
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
200038d2:	bfaf      	iteee	ge
200038d4:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
200038d8:	f000 000f 	andlt.w	r0, r0, #15
200038dc:	4b05      	ldrlt	r3, [pc, #20]	; (200038f4 <HAL_NVIC_SetPriority+0x5c>)
200038de:	b2d2      	uxtblt	r2, r2
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
200038e0:	bfa5      	ittet	ge
200038e2:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
200038e6:	b2d2      	uxtbge	r2, r2
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
200038e8:	541a      	strblt	r2, [r3, r0]
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
200038ea:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
200038ee:	bd70      	pop	{r4, r5, r6, pc}
200038f0:	e000ed00 	.word	0xe000ed00
200038f4:	e000ed14 	.word	0xe000ed14

200038f8 <HAL_NVIC_EnableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
200038f8:	0941      	lsrs	r1, r0, #5
200038fa:	2301      	movs	r3, #1
200038fc:	f000 001f 	and.w	r0, r0, #31
20003900:	4a02      	ldr	r2, [pc, #8]	; (2000390c <HAL_NVIC_EnableIRQ+0x14>)
20003902:	4083      	lsls	r3, r0
20003904:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
20003908:	4770      	bx	lr
2000390a:	bf00      	nop
2000390c:	e000e100 	.word	0xe000e100

20003910 <HAL_NVIC_SystemReset>:
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
20003910:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
20003914:	4905      	ldr	r1, [pc, #20]	; (2000392c <HAL_NVIC_SystemReset+0x1c>)
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
20003916:	4b06      	ldr	r3, [pc, #24]	; (20003930 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
20003918:	68ca      	ldr	r2, [r1, #12]
2000391a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
2000391e:	4313      	orrs	r3, r2
20003920:	60cb      	str	r3, [r1, #12]
20003922:	f3bf 8f4f 	dsb	sy

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
20003926:	bf00      	nop
20003928:	e7fd      	b.n	20003926 <HAL_NVIC_SystemReset+0x16>
2000392a:	bf00      	nop
2000392c:	e000ed00 	.word	0xe000ed00
20003930:	05fa0004 	.word	0x05fa0004

20003934 <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
20003934:	3801      	subs	r0, #1
20003936:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
2000393a:	bf3f      	itttt	cc
2000393c:	4b06      	ldrcc	r3, [pc, #24]	; (20003958 <HAL_SYSTICK_Config+0x24>)
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
2000393e:	4a07      	ldrcc	r2, [pc, #28]	; (2000395c <HAL_SYSTICK_Config+0x28>)
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
20003940:	6058      	strcc	r0, [r3, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
20003942:	21f0      	movcc	r1, #240	; 0xf0
20003944:	bf3f      	itttt	cc
20003946:	f882 1023 	strbcc.w	r1, [r2, #35]	; 0x23
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
2000394a:	2000      	movcc	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
2000394c:	2207      	movcc	r2, #7
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
2000394e:	6098      	strcc	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
20003950:	bf34      	ite	cc
20003952:	601a      	strcc	r2, [r3, #0]
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
20003954:	2001      	movcs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
20003956:	4770      	bx	lr
20003958:	e000e010 	.word	0xe000e010
2000395c:	e000ed00 	.word	0xe000ed00

20003960 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
20003960:	4770      	bx	lr

20003962 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  Handle SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
20003962:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
20003964:	f7ff fffc 	bl	20003960 <HAL_SYSTICK_Callback>
20003968:	bd08      	pop	{r3, pc}
	...

2000396c <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
2000396c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
20003970:	680f      	ldr	r7, [r1, #0]
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00;
20003972:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
20003974:	fa37 f203 	lsrs.w	r2, r7, r3
20003978:	f000 80cc 	beq.w	20003b14 <HAL_GPIO_Init+0x1a8>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
2000397c:	2501      	movs	r5, #1
2000397e:	409d      	lsls	r5, r3

    if(iocurrent)
20003980:	ea15 0e07 	ands.w	lr, r5, r7
20003984:	f000 80c4 	beq.w	20003b10 <HAL_GPIO_Init+0x1a4>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
20003988:	684c      	ldr	r4, [r1, #4]
2000398a:	f024 0610 	bic.w	r6, r4, #16
2000398e:	2e02      	cmp	r6, #2
20003990:	d116      	bne.n	200039c0 <HAL_GPIO_Init+0x54>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
20003992:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
20003996:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2000399a:	f003 0807 	and.w	r8, r3, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
2000399e:	f8dc 2020 	ldr.w	r2, [ip, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
200039a2:	ea4f 0888 	mov.w	r8, r8, lsl #2
200039a6:	f04f 090f 	mov.w	r9, #15
200039aa:	fa09 f908 	lsl.w	r9, r9, r8
200039ae:	ea22 0909 	bic.w	r9, r2, r9
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
200039b2:	690a      	ldr	r2, [r1, #16]
200039b4:	fa02 f208 	lsl.w	r2, r2, r8
200039b8:	ea49 0202 	orr.w	r2, r9, r2
        GPIOx->AFR[position >> 3] = temp;
200039bc:	f8cc 2020 	str.w	r2, [ip, #32]
200039c0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
200039c4:	2203      	movs	r2, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
200039c6:	f8d0 9000 	ldr.w	r9, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
200039ca:	fa02 f20c 	lsl.w	r2, r2, ip
200039ce:	43d2      	mvns	r2, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
200039d0:	f004 0803 	and.w	r8, r4, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
200039d4:	ea02 0a09 	and.w	sl, r2, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
200039d8:	3e01      	subs	r6, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
200039da:	fa08 f90c 	lsl.w	r9, r8, ip
200039de:	ea4a 0909 	orr.w	r9, sl, r9
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
200039e2:	2e01      	cmp	r6, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
200039e4:	f8c0 9000 	str.w	r9, [r0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
200039e8:	d811      	bhi.n	20003a0e <HAL_GPIO_Init+0xa2>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
200039ea:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
200039ec:	ea02 0906 	and.w	r9, r2, r6
        temp |= (GPIO_Init->Speed << (position * 2));
200039f0:	68ce      	ldr	r6, [r1, #12]
200039f2:	fa06 f60c 	lsl.w	r6, r6, ip
200039f6:	ea49 0606 	orr.w	r6, r9, r6
        GPIOx->OSPEEDR = temp;
200039fa:	6086      	str	r6, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
200039fc:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
200039fe:	ea26 0905 	bic.w	r9, r6, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
20003a02:	f3c4 1600 	ubfx	r6, r4, #4, #1
20003a06:	409e      	lsls	r6, r3
20003a08:	ea49 0606 	orr.w	r6, r9, r6
        GPIOx->OTYPER = temp;
20003a0c:	6046      	str	r6, [r0, #4]
      }

      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
20003a0e:	f1b8 0f03 	cmp.w	r8, #3
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
20003a12:	bf01      	itttt	eq
20003a14:	6ac6      	ldreq	r6, [r0, #44]	; 0x2c
        temp &= ~(GPIO_ASCR_EN_0 << position) ;
20003a16:	ea26 0805 	biceq.w	r8, r6, r5
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
20003a1a:	f3c4 05c0 	ubfxeq	r5, r4, #3, #1
20003a1e:	fa05 f603 	lsleq.w	r6, r5, r3
20003a22:	bf04      	itt	eq
20003a24:	ea48 0506 	orreq.w	r5, r8, r6
        GPIOx->ASCR = temp;
20003a28:	62c5      	streq	r5, [r0, #44]	; 0x2c
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
20003a2a:	68c6      	ldr	r6, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
20003a2c:	4016      	ands	r6, r2
      temp |= ((GPIO_Init->Pull) << (position * 2));
20003a2e:	688a      	ldr	r2, [r1, #8]
20003a30:	fa02 f50c 	lsl.w	r5, r2, ip
20003a34:	ea46 0205 	orr.w	r2, r6, r5
      GPIOx->PUPDR = temp;
20003a38:	60c2      	str	r2, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
20003a3a:	00e2      	lsls	r2, r4, #3
20003a3c:	d568      	bpl.n	20003b10 <HAL_GPIO_Init+0x1a4>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
20003a3e:	4a37      	ldr	r2, [pc, #220]	; (20003b1c <HAL_GPIO_Init+0x1b0>)
20003a40:	6e15      	ldr	r5, [r2, #96]	; 0x60
20003a42:	f045 0501 	orr.w	r5, r5, #1
20003a46:	6615      	str	r5, [r2, #96]	; 0x60
20003a48:	6e12      	ldr	r2, [r2, #96]	; 0x60
20003a4a:	f023 0503 	bic.w	r5, r3, #3
20003a4e:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
20003a52:	f002 0201 	and.w	r2, r2, #1
20003a56:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
20003a5a:	9201      	str	r2, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
20003a5c:	f003 0c03 	and.w	ip, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
20003a60:	9a01      	ldr	r2, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2];
20003a62:	68ae      	ldr	r6, [r5, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
20003a64:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
20003a68:	220f      	movs	r2, #15
20003a6a:	fa02 f20c 	lsl.w	r2, r2, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
20003a6e:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
20003a72:	ea26 0602 	bic.w	r6, r6, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
20003a76:	d019      	beq.n	20003aac <HAL_GPIO_Init+0x140>
20003a78:	4a29      	ldr	r2, [pc, #164]	; (20003b20 <HAL_GPIO_Init+0x1b4>)
20003a7a:	4290      	cmp	r0, r2
20003a7c:	d018      	beq.n	20003ab0 <HAL_GPIO_Init+0x144>
20003a7e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
20003a82:	4290      	cmp	r0, r2
20003a84:	d016      	beq.n	20003ab4 <HAL_GPIO_Init+0x148>
20003a86:	f502 6280 	add.w	r2, r2, #1024	; 0x400
20003a8a:	4290      	cmp	r0, r2
20003a8c:	d014      	beq.n	20003ab8 <HAL_GPIO_Init+0x14c>
20003a8e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
20003a92:	4290      	cmp	r0, r2
20003a94:	d012      	beq.n	20003abc <HAL_GPIO_Init+0x150>
20003a96:	f502 6280 	add.w	r2, r2, #1024	; 0x400
20003a9a:	4290      	cmp	r0, r2
20003a9c:	d010      	beq.n	20003ac0 <HAL_GPIO_Init+0x154>
20003a9e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
20003aa2:	4290      	cmp	r0, r2
20003aa4:	bf0c      	ite	eq
20003aa6:	2206      	moveq	r2, #6
20003aa8:	2207      	movne	r2, #7
20003aaa:	e00a      	b.n	20003ac2 <HAL_GPIO_Init+0x156>
20003aac:	2200      	movs	r2, #0
20003aae:	e008      	b.n	20003ac2 <HAL_GPIO_Init+0x156>
20003ab0:	2201      	movs	r2, #1
20003ab2:	e006      	b.n	20003ac2 <HAL_GPIO_Init+0x156>
20003ab4:	2202      	movs	r2, #2
20003ab6:	e004      	b.n	20003ac2 <HAL_GPIO_Init+0x156>
20003ab8:	2203      	movs	r2, #3
20003aba:	e002      	b.n	20003ac2 <HAL_GPIO_Init+0x156>
20003abc:	2204      	movs	r2, #4
20003abe:	e000      	b.n	20003ac2 <HAL_GPIO_Init+0x156>
20003ac0:	2205      	movs	r2, #5
20003ac2:	fa02 f20c 	lsl.w	r2, r2, ip
20003ac6:	4332      	orrs	r2, r6
        SYSCFG->EXTICR[position >> 2] = temp;
20003ac8:	60aa      	str	r2, [r5, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
20003aca:	4a16      	ldr	r2, [pc, #88]	; (20003b24 <HAL_GPIO_Init+0x1b8>)
20003acc:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
20003ace:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
20003ad2:	ea6f 060e 	mvn.w	r6, lr
20003ad6:	bf0c      	ite	eq
20003ad8:	4035      	andeq	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
20003ada:	ea4e 0505 	orrne.w	r5, lr, r5
        }
        EXTI->IMR1 = temp;
20003ade:	6015      	str	r5, [r2, #0]

        temp = EXTI->EMR1;
20003ae0:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
20003ae2:	f414 3f00 	tst.w	r4, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
20003ae6:	bf0c      	ite	eq
20003ae8:	4035      	andeq	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
20003aea:	ea4e 0505 	orrne.w	r5, lr, r5
        }
        EXTI->EMR1 = temp;
20003aee:	6055      	str	r5, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
20003af0:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
20003af2:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
20003af6:	bf0c      	ite	eq
20003af8:	4035      	andeq	r5, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
20003afa:	ea4e 0505 	orrne.w	r5, lr, r5
        }
        EXTI->RTSR1 = temp;
20003afe:	6095      	str	r5, [r2, #8]

        temp = EXTI->FTSR1;
20003b00:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
20003b02:	02a4      	lsls	r4, r4, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
20003b04:	bf54      	ite	pl
20003b06:	ea06 0405 	andpl.w	r4, r6, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
20003b0a:	ea4e 0405 	orrmi.w	r4, lr, r5
        }
        EXTI->FTSR1 = temp;
20003b0e:	60d4      	str	r4, [r2, #12]
      }
    }
    
    position++;
20003b10:	3301      	adds	r3, #1
20003b12:	e72f      	b.n	20003974 <HAL_GPIO_Init+0x8>
  }
}
20003b14:	b002      	add	sp, #8
20003b16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
20003b1a:	bf00      	nop
20003b1c:	40021000 	.word	0x40021000
20003b20:	48000400 	.word	0x48000400
20003b24:	40010400 	.word	0x40010400

20003b28 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
20003b28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t position = 0x00;
20003b2c:	2200      	movs	r2, #0
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
20003b2e:	fa31 f302 	lsrs.w	r3, r1, r2
20003b32:	f000 8084 	beq.w	20003c3e <HAL_GPIO_DeInit+0x116>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
20003b36:	f04f 0c01 	mov.w	ip, #1
20003b3a:	fa0c f402 	lsl.w	r4, ip, r2

    if (iocurrent)
20003b3e:	ea14 0501 	ands.w	r5, r4, r1
20003b42:	d07a      	beq.n	20003c3a <HAL_GPIO_DeInit+0x112>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
20003b44:	6806      	ldr	r6, [r0, #0]
20003b46:	2303      	movs	r3, #3
20003b48:	fa02 f70c 	lsl.w	r7, r2, ip
20003b4c:	fa03 f907 	lsl.w	r9, r3, r7

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
20003b50:	fa22 fe03 	lsr.w	lr, r2, r3
20003b54:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2

    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
20003b58:	ea49 0606 	orr.w	r6, r9, r6
20003b5c:	6006      	str	r6, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
20003b5e:	f002 0807 	and.w	r8, r2, #7
20003b62:	f8de 7020 	ldr.w	r7, [lr, #32]
20003b66:	260f      	movs	r6, #15
20003b68:	ea4f 0888 	mov.w	r8, r8, lsl #2
20003b6c:	fa06 f808 	lsl.w	r8, r6, r8
20003b70:	ea27 0708 	bic.w	r7, r7, r8
20003b74:	f8ce 7020 	str.w	r7, [lr, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
20003b78:	f8d0 e008 	ldr.w	lr, [r0, #8]
20003b7c:	ea6f 0709 	mvn.w	r7, r9
20003b80:	ea07 0e0e 	and.w	lr, r7, lr
20003b84:	f8c0 e008 	str.w	lr, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
20003b88:	f8d0 e004 	ldr.w	lr, [r0, #4]
20003b8c:	43e4      	mvns	r4, r4
20003b8e:	ea04 0e0e 	and.w	lr, r4, lr
20003b92:	f8c0 e004 	str.w	lr, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
20003b96:	f8d0 e00c 	ldr.w	lr, [r0, #12]
20003b9a:	ea07 070e 	and.w	r7, r7, lr
20003b9e:	60c7      	str	r7, [r0, #12]

      /* Deactivate the Control bit of Analog mode for the current IO */
      GPIOx->ASCR &= ~(GPIO_ASCR_EN_0<< position);
20003ba0:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
20003ba2:	403c      	ands	r4, r7
20003ba4:	62c4      	str	r4, [r0, #44]	; 0x2c
20003ba6:	f022 0403 	bic.w	r4, r2, #3
20003baa:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
20003bae:	f504 3480 	add.w	r4, r4, #65536	; 0x10000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
20003bb2:	ea02 0703 	and.w	r7, r2, r3
      GPIOx->ASCR &= ~(GPIO_ASCR_EN_0<< position);

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
20003bb6:	f8d4 e008 	ldr.w	lr, [r4, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
20003bba:	00bf      	lsls	r7, r7, #2
20003bbc:	40be      	lsls	r6, r7
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
20003bbe:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
20003bc2:	ea06 0e0e 	and.w	lr, r6, lr
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
20003bc6:	d019      	beq.n	20003bfc <HAL_GPIO_DeInit+0xd4>
20003bc8:	f8df 8080 	ldr.w	r8, [pc, #128]	; 20003c4c <HAL_GPIO_DeInit+0x124>
20003bcc:	4540      	cmp	r0, r8
20003bce:	d017      	beq.n	20003c00 <HAL_GPIO_DeInit+0xd8>
20003bd0:	f8df c07c 	ldr.w	ip, [pc, #124]	; 20003c50 <HAL_GPIO_DeInit+0x128>
20003bd4:	4560      	cmp	r0, ip
20003bd6:	d015      	beq.n	20003c04 <HAL_GPIO_DeInit+0xdc>
20003bd8:	f50c 6c80 	add.w	ip, ip, #1024	; 0x400
20003bdc:	4560      	cmp	r0, ip
20003bde:	d016      	beq.n	20003c0e <HAL_GPIO_DeInit+0xe6>
20003be0:	4b18      	ldr	r3, [pc, #96]	; (20003c44 <HAL_GPIO_DeInit+0x11c>)
20003be2:	4298      	cmp	r0, r3
20003be4:	d010      	beq.n	20003c08 <HAL_GPIO_DeInit+0xe0>
20003be6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
20003bea:	4298      	cmp	r0, r3
20003bec:	d00e      	beq.n	20003c0c <HAL_GPIO_DeInit+0xe4>
20003bee:	f503 6380 	add.w	r3, r3, #1024	; 0x400
20003bf2:	4298      	cmp	r0, r3
20003bf4:	bf0c      	ite	eq
20003bf6:	2306      	moveq	r3, #6
20003bf8:	2307      	movne	r3, #7
20003bfa:	e008      	b.n	20003c0e <HAL_GPIO_DeInit+0xe6>
20003bfc:	2300      	movs	r3, #0
20003bfe:	e006      	b.n	20003c0e <HAL_GPIO_DeInit+0xe6>
20003c00:	4663      	mov	r3, ip
20003c02:	e004      	b.n	20003c0e <HAL_GPIO_DeInit+0xe6>
20003c04:	2302      	movs	r3, #2
20003c06:	e002      	b.n	20003c0e <HAL_GPIO_DeInit+0xe6>
20003c08:	2304      	movs	r3, #4
20003c0a:	e000      	b.n	20003c0e <HAL_GPIO_DeInit+0xe6>
20003c0c:	2305      	movs	r3, #5
20003c0e:	40bb      	lsls	r3, r7
20003c10:	459e      	cmp	lr, r3
20003c12:	d112      	bne.n	20003c3a <HAL_GPIO_DeInit+0x112>
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
20003c14:	68a3      	ldr	r3, [r4, #8]
20003c16:	ea23 0606 	bic.w	r6, r3, r6

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
20003c1a:	4b0b      	ldr	r3, [pc, #44]	; (20003c48 <HAL_GPIO_DeInit+0x120>)
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
20003c1c:	60a6      	str	r6, [r4, #8]

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
20003c1e:	681e      	ldr	r6, [r3, #0]
20003c20:	43ec      	mvns	r4, r5
20003c22:	ea04 0506 	and.w	r5, r4, r6
20003c26:	601d      	str	r5, [r3, #0]
        EXTI->EMR1 &= ~((uint32_t)iocurrent);
20003c28:	685d      	ldr	r5, [r3, #4]
20003c2a:	4025      	ands	r5, r4
20003c2c:	605d      	str	r5, [r3, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
20003c2e:	689d      	ldr	r5, [r3, #8]
20003c30:	4025      	ands	r5, r4
20003c32:	609d      	str	r5, [r3, #8]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
20003c34:	68dd      	ldr	r5, [r3, #12]
20003c36:	402c      	ands	r4, r5
20003c38:	60dc      	str	r4, [r3, #12]
      }
    }
    
    position++;
20003c3a:	3201      	adds	r2, #1
20003c3c:	e777      	b.n	20003b2e <HAL_GPIO_DeInit+0x6>
  }
}
20003c3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
20003c42:	bf00      	nop
20003c44:	48001000 	.word	0x48001000
20003c48:	40010400 	.word	0x40010400
20003c4c:	48000400 	.word	0x48000400
20003c50:	48000800 	.word	0x48000800

20003c54 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
20003c54:	6903      	ldr	r3, [r0, #16]
20003c56:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
20003c58:	bf14      	ite	ne
20003c5a:	2001      	movne	r0, #1
20003c5c:	2000      	moveq	r0, #0
20003c5e:	4770      	bx	lr

20003c60 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
20003c60:	b10a      	cbz	r2, 20003c66 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
20003c62:	6181      	str	r1, [r0, #24]
20003c64:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
20003c66:	6281      	str	r1, [r0, #40]	; 0x28
20003c68:	4770      	bx	lr
	...

20003c6c <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
20003c6c:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
20003c6e:	4b04      	ldr	r3, [pc, #16]	; (20003c80 <HAL_GPIO_EXTI_IRQHandler+0x14>)
20003c70:	6959      	ldr	r1, [r3, #20]
20003c72:	4208      	tst	r0, r1
20003c74:	d002      	beq.n	20003c7c <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
20003c76:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
20003c78:	f7fc fc56 	bl	20000528 <HAL_GPIO_EXTI_Callback>
20003c7c:	bd08      	pop	{r3, pc}
20003c7e:	bf00      	nop
20003c80:	40010400 	.word	0x40010400

20003c84 <SPI_WaitFifoStateUntilTimeout>:
  * @param State : Fifo state to check
  * @param Timeout : Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout)
{
20003c84:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
20003c88:	4604      	mov	r4, r0
20003c8a:	460f      	mov	r7, r1
20003c8c:	4616      	mov	r6, r2
20003c8e:	461d      	mov	r5, r3
  __IO uint8_t tmpreg;
  uint32_t tickstart = HAL_GetTick();
20003c90:	f7ff fdde 	bl	20003850 <HAL_GetTick>
20003c94:	4680      	mov	r8, r0

  while((hspi->Instance->SR & Fifo) != State)
20003c96:	6821      	ldr	r1, [r4, #0]
20003c98:	688a      	ldr	r2, [r1, #8]
20003c9a:	403a      	ands	r2, r7
20003c9c:	42b2      	cmp	r2, r6
20003c9e:	d03d      	beq.n	20003d1c <SPI_WaitFifoStateUntilTimeout+0x98>
  {
    if((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
20003ca0:	f5b7 6fc0 	cmp.w	r7, #1536	; 0x600
20003ca4:	d106      	bne.n	20003cb4 <SPI_WaitFifoStateUntilTimeout+0x30>
20003ca6:	b92e      	cbnz	r6, 20003cb4 <SPI_WaitFifoStateUntilTimeout+0x30>
    {
      tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
20003ca8:	7b0b      	ldrb	r3, [r1, #12]
20003caa:	b2db      	uxtb	r3, r3
20003cac:	f88d 3007 	strb.w	r3, [sp, #7]
      UNUSED(tmpreg); /* To avoid GCC warning */
20003cb0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    }

    if(Timeout != HAL_MAX_DELAY)
20003cb4:	1c6b      	adds	r3, r5, #1
20003cb6:	d0ef      	beq.n	20003c98 <SPI_WaitFifoStateUntilTimeout+0x14>
    {
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
20003cb8:	b94d      	cbnz	r5, 20003cce <SPI_WaitFifoStateUntilTimeout+0x4a>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
                  on both master and slave sides in order to resynchronize the master
                 and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
20003cba:	6823      	ldr	r3, [r4, #0]
20003cbc:	685a      	ldr	r2, [r3, #4]
20003cbe:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
20003cc2:	605a      	str	r2, [r3, #4]

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
20003cc4:	6862      	ldr	r2, [r4, #4]
20003cc6:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
20003cca:	d112      	bne.n	20003cf2 <SPI_WaitFifoStateUntilTimeout+0x6e>
20003ccc:	e006      	b.n	20003cdc <SPI_WaitFifoStateUntilTimeout+0x58>
      UNUSED(tmpreg); /* To avoid GCC warning */
    }

    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
20003cce:	f7ff fdbf 	bl	20003850 <HAL_GetTick>
20003cd2:	ebc8 0000 	rsb	r0, r8, r0
20003cd6:	42a8      	cmp	r0, r5
20003cd8:	d3dd      	bcc.n	20003c96 <SPI_WaitFifoStateUntilTimeout+0x12>
20003cda:	e7ee      	b.n	20003cba <SPI_WaitFifoStateUntilTimeout+0x36>
                 and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
20003cdc:	68a2      	ldr	r2, [r4, #8]
20003cde:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
20003ce2:	d002      	beq.n	20003cea <SPI_WaitFifoStateUntilTimeout+0x66>
20003ce4:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
20003ce8:	d103      	bne.n	20003cf2 <SPI_WaitFifoStateUntilTimeout+0x6e>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
20003cea:	681a      	ldr	r2, [r3, #0]
20003cec:	f022 0240 	bic.w	r2, r2, #64	; 0x40
20003cf0:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
20003cf2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
20003cf4:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
20003cf8:	d108      	bne.n	20003d0c <SPI_WaitFifoStateUntilTimeout+0x88>
        {
          SPI_RESET_CRC(hspi);
20003cfa:	6819      	ldr	r1, [r3, #0]
20003cfc:	f64d 72ff 	movw	r2, #57343	; 0xdfff
20003d00:	400a      	ands	r2, r1
20003d02:	601a      	str	r2, [r3, #0]
20003d04:	681a      	ldr	r2, [r3, #0]
20003d06:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
20003d0a:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
20003d0c:	2301      	movs	r3, #1
20003d0e:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
20003d12:	2300      	movs	r3, #0
20003d14:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
20003d18:	2003      	movs	r0, #3
20003d1a:	e000      	b.n	20003d1e <SPI_WaitFifoStateUntilTimeout+0x9a>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
20003d1c:	2000      	movs	r0, #0
}
20003d1e:	b002      	add	sp, #8
20003d20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

20003d24 <SPI_WaitFlagStateUntilTimeout>:
  * @param State : flag state to check
  * @param Timeout : Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout)
{
20003d24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
20003d28:	4604      	mov	r4, r0
20003d2a:	460f      	mov	r7, r1
20003d2c:	4616      	mov	r6, r2
20003d2e:	461d      	mov	r5, r3
  uint32_t tickstart = HAL_GetTick();
20003d30:	f7ff fd8e 	bl	20003850 <HAL_GetTick>
20003d34:	4680      	mov	r8, r0

  while((hspi->Instance->SR & Flag) != State)
20003d36:	6823      	ldr	r3, [r4, #0]
20003d38:	689a      	ldr	r2, [r3, #8]
20003d3a:	403a      	ands	r2, r7
20003d3c:	42b2      	cmp	r2, r6
20003d3e:	d034      	beq.n	20003daa <SPI_WaitFlagStateUntilTimeout+0x86>
  {
    if(Timeout != HAL_MAX_DELAY)
20003d40:	1c6a      	adds	r2, r5, #1
20003d42:	d0f9      	beq.n	20003d38 <SPI_WaitFlagStateUntilTimeout+0x14>
    {
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
20003d44:	b94d      	cbnz	r5, 20003d5a <SPI_WaitFlagStateUntilTimeout+0x36>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
20003d46:	6823      	ldr	r3, [r4, #0]
20003d48:	685a      	ldr	r2, [r3, #4]
20003d4a:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
20003d4e:	605a      	str	r2, [r3, #4]

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
20003d50:	6862      	ldr	r2, [r4, #4]
20003d52:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
20003d56:	d112      	bne.n	20003d7e <SPI_WaitFlagStateUntilTimeout+0x5a>
20003d58:	e006      	b.n	20003d68 <SPI_WaitFlagStateUntilTimeout+0x44>

  while((hspi->Instance->SR & Flag) != State)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
20003d5a:	f7ff fd79 	bl	20003850 <HAL_GetTick>
20003d5e:	ebc8 0000 	rsb	r0, r8, r0
20003d62:	42a8      	cmp	r0, r5
20003d64:	d3e7      	bcc.n	20003d36 <SPI_WaitFlagStateUntilTimeout+0x12>
20003d66:	e7ee      	b.n	20003d46 <SPI_WaitFlagStateUntilTimeout+0x22>
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
20003d68:	68a2      	ldr	r2, [r4, #8]
20003d6a:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
20003d6e:	d002      	beq.n	20003d76 <SPI_WaitFlagStateUntilTimeout+0x52>
20003d70:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
20003d74:	d103      	bne.n	20003d7e <SPI_WaitFlagStateUntilTimeout+0x5a>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
20003d76:	681a      	ldr	r2, [r3, #0]
20003d78:	f022 0240 	bic.w	r2, r2, #64	; 0x40
20003d7c:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
20003d7e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
20003d80:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
20003d84:	d108      	bne.n	20003d98 <SPI_WaitFlagStateUntilTimeout+0x74>
        {
          SPI_RESET_CRC(hspi);
20003d86:	6819      	ldr	r1, [r3, #0]
20003d88:	f64d 72ff 	movw	r2, #57343	; 0xdfff
20003d8c:	400a      	ands	r2, r1
20003d8e:	601a      	str	r2, [r3, #0]
20003d90:	681a      	ldr	r2, [r3, #0]
20003d92:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
20003d96:	601a      	str	r2, [r3, #0]
        }

        hspi->State= HAL_SPI_STATE_READY;
20003d98:	2301      	movs	r3, #1
20003d9a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
20003d9e:	2300      	movs	r3, #0
20003da0:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
20003da4:	2003      	movs	r0, #3
20003da6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
20003daa:	2000      	movs	r0, #0
}
20003dac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

20003db0 <SPI_EndRxTxTransaction>:
  * @brief Handle the check of the RXTX or TX transaction complete.
  * @param hspi: SPI handle
  * @param Timeout : Timeout duration
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
{
20003db0:	b538      	push	{r3, r4, r5, lr}
20003db2:	460d      	mov	r5, r1
  /* Control if the TX fifo is empty */
  if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
20003db4:	2200      	movs	r2, #0
20003db6:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
20003dba:	462b      	mov	r3, r5
  * @brief Handle the check of the RXTX or TX transaction complete.
  * @param hspi: SPI handle
  * @param Timeout : Timeout duration
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
{
20003dbc:	4604      	mov	r4, r0
  /* Control if the TX fifo is empty */
  if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
20003dbe:	f7ff ff61 	bl	20003c84 <SPI_WaitFifoStateUntilTimeout>
20003dc2:	4602      	mov	r2, r0
20003dc4:	b928      	cbnz	r0, 20003dd2 <SPI_EndRxTxTransaction+0x22>
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
20003dc6:	4620      	mov	r0, r4
20003dc8:	2180      	movs	r1, #128	; 0x80
20003dca:	462b      	mov	r3, r5
20003dcc:	f7ff ffaa 	bl	20003d24 <SPI_WaitFlagStateUntilTimeout>
20003dd0:	b120      	cbz	r0, 20003ddc <SPI_EndRxTxTransaction+0x2c>
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
20003dd2:	6e23      	ldr	r3, [r4, #96]	; 0x60
20003dd4:	f043 0320 	orr.w	r3, r3, #32
20003dd8:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
20003dda:	2003      	movs	r0, #3
  }
  return HAL_OK;
}
20003ddc:	bd38      	pop	{r3, r4, r5, pc}

20003dde <SPI_EndRxTransaction>:
  * @param Timeout : Timeout duration
  * @retval None
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
{
  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
20003dde:	6843      	ldr	r3, [r0, #4]
20003de0:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  *               the configuration information for SPI module.
  * @param Timeout : Timeout duration
  * @retval None
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
{
20003de4:	b570      	push	{r4, r5, r6, lr}
20003de6:	4604      	mov	r4, r0
20003de8:	460e      	mov	r6, r1
  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
20003dea:	d10b      	bne.n	20003e04 <SPI_EndRxTransaction+0x26>
20003dec:	6883      	ldr	r3, [r0, #8]
20003dee:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20003df2:	d002      	beq.n	20003dfa <SPI_EndRxTransaction+0x1c>
20003df4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20003df8:	d104      	bne.n	20003e04 <SPI_EndRxTransaction+0x26>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
20003dfa:	6822      	ldr	r2, [r4, #0]
20003dfc:	6813      	ldr	r3, [r2, #0]
20003dfe:	f023 0340 	bic.w	r3, r3, #64	; 0x40
20003e02:	6013      	str	r3, [r2, #0]
  }
  
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
20003e04:	4620      	mov	r0, r4
20003e06:	2180      	movs	r1, #128	; 0x80
20003e08:	2200      	movs	r2, #0
20003e0a:	4633      	mov	r3, r6
20003e0c:	f7ff ff8a 	bl	20003d24 <SPI_WaitFlagStateUntilTimeout>
20003e10:	4605      	mov	r5, r0
20003e12:	b990      	cbnz	r0, 20003e3a <SPI_EndRxTransaction+0x5c>
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
    return HAL_TIMEOUT;
  }

  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
20003e14:	6863      	ldr	r3, [r4, #4]
20003e16:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
20003e1a:	d113      	bne.n	20003e44 <SPI_EndRxTransaction+0x66>
20003e1c:	68a3      	ldr	r3, [r4, #8]
20003e1e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20003e22:	d002      	beq.n	20003e2a <SPI_EndRxTransaction+0x4c>
20003e24:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20003e28:	d10c      	bne.n	20003e44 <SPI_EndRxTransaction+0x66>
  {
    /* Empty the FRLVL fifo */
    if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK)
20003e2a:	4620      	mov	r0, r4
20003e2c:	f44f 61c0 	mov.w	r1, #1536	; 0x600
20003e30:	2200      	movs	r2, #0
20003e32:	4633      	mov	r3, r6
20003e34:	f7ff ff26 	bl	20003c84 <SPI_WaitFifoStateUntilTimeout>
20003e38:	b120      	cbz	r0, 20003e44 <SPI_EndRxTransaction+0x66>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
20003e3a:	6e23      	ldr	r3, [r4, #96]	; 0x60
20003e3c:	f043 0320 	orr.w	r3, r3, #32
20003e40:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
20003e42:	2503      	movs	r5, #3
    }
  }
  return HAL_OK;
}
20003e44:	4628      	mov	r0, r5
20003e46:	bd70      	pop	{r4, r5, r6, pc}

20003e48 <HAL_SPI_TransmitReceive_DMA.part.5>:
  * @param  pRxData: pointer to reception data buffer
  * @note  When the CRC feature is enabled the pRxData Length must be Size + 1
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
20003e48:	b538      	push	{r3, r4, r5, lr}
20003e4a:	4604      	mov	r4, r0
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
20003e4c:	2001      	movs	r0, #1
20003e4e:	f884 005c 	strb.w	r0, [r4, #92]	; 0x5c

  if(!((hspi->State == HAL_SPI_STATE_READY) ||
20003e52:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
20003e56:	2801      	cmp	r0, #1
20003e58:	d00b      	beq.n	20003e72 <HAL_SPI_TransmitReceive_DMA.part.5+0x2a>
20003e5a:	6865      	ldr	r5, [r4, #4]
20003e5c:	f5b5 7f82 	cmp.w	r5, #260	; 0x104
20003e60:	f040 809c 	bne.w	20003f9c <HAL_SPI_TransmitReceive_DMA.part.5+0x154>
      ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX))))
20003e64:	68a5      	ldr	r5, [r4, #8]
20003e66:	2d00      	cmp	r5, #0
20003e68:	f040 8098 	bne.w	20003f9c <HAL_SPI_TransmitReceive_DMA.part.5+0x154>
20003e6c:	2804      	cmp	r0, #4
20003e6e:	f040 8095 	bne.w	20003f9c <HAL_SPI_TransmitReceive_DMA.part.5+0x154>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
20003e72:	2900      	cmp	r1, #0
20003e74:	f000 8094 	beq.w	20003fa0 <HAL_SPI_TransmitReceive_DMA.part.5+0x158>
20003e78:	2a00      	cmp	r2, #0
20003e7a:	f000 8091 	beq.w	20003fa0 <HAL_SPI_TransmitReceive_DMA.part.5+0x158>
20003e7e:	2b00      	cmp	r3, #0
20003e80:	f000 808e 	beq.w	20003fa0 <HAL_SPI_TransmitReceive_DMA.part.5+0x158>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* check if the transmit Receive function is not called by a receive master */
  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
20003e84:	2804      	cmp	r0, #4

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
20003e86:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;

  /* Reset CRC Calculation + increase the rxsize */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
20003e88:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
20003e8a:	63a1      	str	r1, [r4, #56]	; 0x38
  }

  /* check if the transmit Receive function is not called by a receive master */
  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
20003e8c:	bf1c      	itt	ne
20003e8e:	2005      	movne	r0, #5
20003e90:	f884 005d 	strbne.w	r0, [r4, #93]	; 0x5d
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
20003e94:	2000      	movs	r0, #0
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;

  /* Reset CRC Calculation + increase the rxsize */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
20003e96:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
20003e9a:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferSize  = Size;
20003e9c:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
20003e9e:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferSize  = Size;
20003ea0:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
20003ea4:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
20003ea8:	6821      	ldr	r1, [r4, #0]

  /* Reset CRC Calculation + increase the rxsize */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
20003eaa:	d108      	bne.n	20003ebe <HAL_SPI_TransmitReceive_DMA.part.5+0x76>
  {
    SPI_RESET_CRC(hspi);
20003eac:	6808      	ldr	r0, [r1, #0]
20003eae:	f64d 72ff 	movw	r2, #57343	; 0xdfff
20003eb2:	4002      	ands	r2, r0
20003eb4:	600a      	str	r2, [r1, #0]
20003eb6:	680a      	ldr	r2, [r1, #0]
20003eb8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
20003ebc:	600a      	str	r2, [r1, #0]
  }

  /* Reset the threshold bit */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
20003ebe:	684a      	ldr	r2, [r1, #4]
20003ec0:	6da0      	ldr	r0, [r4, #88]	; 0x58
20003ec2:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
20003ec6:	604a      	str	r2, [r1, #4]

  /* the packing mode management is enabled by the DMA settings according the spi data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
20003ec8:	68e2      	ldr	r2, [r4, #12]
20003eca:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
20003ece:	d904      	bls.n	20003eda <HAL_SPI_TransmitReceive_DMA.part.5+0x92>
  {
    /* set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
20003ed0:	684b      	ldr	r3, [r1, #4]
20003ed2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
20003ed6:	604b      	str	r3, [r1, #4]
20003ed8:	e02f      	b.n	20003f3a <HAL_SPI_TransmitReceive_DMA.part.5+0xf2>
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
20003eda:	684a      	ldr	r2, [r1, #4]
20003edc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
20003ee0:	604a      	str	r2, [r1, #4]

    if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
20003ee2:	6d62      	ldr	r2, [r4, #84]	; 0x54
20003ee4:	6992      	ldr	r2, [r2, #24]
20003ee6:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
20003eea:	d10e      	bne.n	20003f0a <HAL_SPI_TransmitReceive_DMA.part.5+0xc2>
    {
      if((hspi->TxXferSize & 0x1) == 0x0)
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
20003eec:	684d      	ldr	r5, [r1, #4]
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);

    if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      if((hspi->TxXferSize & 0x1) == 0x0)
20003eee:	f013 0f01 	tst.w	r3, #1
20003ef2:	ea4f 0253 	mov.w	r2, r3, lsr #1
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
20003ef6:	bf0d      	iteet	eq
20003ef8:	f425 4580 	biceq.w	r5, r5, #16384	; 0x4000
        hspi->TxXferCount = hspi->TxXferCount >> 1;
      }
      else
      {
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
20003efc:	f445 4580 	orrne.w	r5, r5, #16384	; 0x4000
        hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
20003f00:	3201      	addne	r2, #1

    if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      if((hspi->TxXferSize & 0x1) == 0x0)
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
20003f02:	604d      	streq	r5, [r1, #4]
        hspi->TxXferCount = hspi->TxXferCount >> 1;
      }
      else
      {
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
20003f04:	bf18      	it	ne
20003f06:	604d      	strne	r5, [r1, #4]
        hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
20003f08:	87e2      	strh	r2, [r4, #62]	; 0x3e
      }
    }

    if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
20003f0a:	6982      	ldr	r2, [r0, #24]
20003f0c:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
20003f10:	d113      	bne.n	20003f3a <HAL_SPI_TransmitReceive_DMA.part.5+0xf2>
    {
      /* set fiforxthresold according the reception data length: 16bit */
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
20003f12:	684a      	ldr	r2, [r1, #4]
20003f14:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
20003f18:	604a      	str	r2, [r1, #4]

      if((hspi->RxXferCount & 0x1) == 0x0 )
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
20003f1a:	684a      	ldr	r2, [r1, #4]
    if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      /* set fiforxthresold according the reception data length: 16bit */
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);

      if((hspi->RxXferCount & 0x1) == 0x0 )
20003f1c:	f013 0f01 	tst.w	r3, #1
20003f20:	ea4f 0353 	mov.w	r3, r3, lsr #1
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
20003f24:	bf0d      	iteet	eq
20003f26:	f422 5200 	biceq.w	r2, r2, #8192	; 0x2000
        hspi->RxXferCount = hspi->RxXferCount >> 1;
      }
      else
      {
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
20003f2a:	f442 5200 	orrne.w	r2, r2, #8192	; 0x2000
        hspi->RxXferCount = (hspi->RxXferCount >> 1) + 1;
20003f2e:	3301      	addne	r3, #1
      /* set fiforxthresold according the reception data length: 16bit */
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);

      if((hspi->RxXferCount & 0x1) == 0x0 )
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
20003f30:	604a      	streq	r2, [r1, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1;
      }
      else
      {
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
20003f32:	bf18      	it	ne
20003f34:	604a      	strne	r2, [r1, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1) + 1;
20003f36:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    }
  }

  /* Set the SPI Rx DMA transfer complete callback if the transfer request is a
     reception request (RXNE) */
  if(hspi->State == HAL_SPI_STATE_BUSY_RX)
20003f3a:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
    hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
  }

  /* Set the DMA error callback */
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
20003f3e:	4d1b      	ldr	r5, [pc, #108]	; (20003fac <HAL_SPI_TransmitReceive_DMA.part.5+0x164>)
20003f40:	6345      	str	r5, [r0, #52]	; 0x34
    }
  }

  /* Set the SPI Rx DMA transfer complete callback if the transfer request is a
     reception request (RXNE) */
  if(hspi->State == HAL_SPI_STATE_BUSY_RX)
20003f42:	2b04      	cmp	r3, #4
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
20003f44:	bf0b      	itete	eq
20003f46:	4b1a      	ldreq	r3, [pc, #104]	; (20003fb0 <HAL_SPI_TransmitReceive_DMA.part.5+0x168>)
    hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
  }
  else
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
20003f48:	4b1a      	ldrne	r3, [pc, #104]	; (20003fb4 <HAL_SPI_TransmitReceive_DMA.part.5+0x16c>)
  /* Set the SPI Rx DMA transfer complete callback if the transfer request is a
     reception request (RXNE) */
  if(hspi->State == HAL_SPI_STATE_BUSY_RX)
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
20003f4a:	6303      	streq	r3, [r0, #48]	; 0x30
    hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
  }
  else
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
20003f4c:	6303      	strne	r3, [r0, #48]	; 0x30
     reception request (RXNE) */
  if(hspi->State == HAL_SPI_STATE_BUSY_RX)
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
    hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
20003f4e:	bf0c      	ite	eq
20003f50:	4b19      	ldreq	r3, [pc, #100]	; (20003fb8 <HAL_SPI_TransmitReceive_DMA.part.5+0x170>)
  }
  else
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
    hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
20003f52:	4b1a      	ldrne	r3, [pc, #104]	; (20003fbc <HAL_SPI_TransmitReceive_DMA.part.5+0x174>)
20003f54:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the DMA error callback */
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;

  /* Enable Rx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
20003f56:	684b      	ldr	r3, [r1, #4]

  /* Enable the Rx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t) hspi->pRxBuffPtr, hspi->RxXferCount);
20003f58:	6c22      	ldr	r2, [r4, #64]	; 0x40

  /* Set the DMA error callback */
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;

  /* Enable Rx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
20003f5a:	f043 0301 	orr.w	r3, r3, #1
20003f5e:	604b      	str	r3, [r1, #4]

  /* Enable the Rx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t) hspi->pRxBuffPtr, hspi->RxXferCount);
20003f60:	310c      	adds	r1, #12
20003f62:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
20003f66:	f000 fc3b 	bl	200047e0 <HAL_DMA_Start_IT>

  /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
  is performed in DMA reception complete callback  */
  hspi->hdmatx->XferHalfCpltCallback = NULL;
20003f6a:	6d60      	ldr	r0, [r4, #84]	; 0x54

  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;

  /* Enable the Tx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
20003f6c:	6822      	ldr	r2, [r4, #0]
  is performed in DMA reception complete callback  */
  hspi->hdmatx->XferHalfCpltCallback = NULL;
  hspi->hdmatx->XferCpltCallback = NULL;

  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
20003f6e:	6345      	str	r5, [r0, #52]	; 0x34
  /* Enable the Rx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t) hspi->pRxBuffPtr, hspi->RxXferCount);

  /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
  is performed in DMA reception complete callback  */
  hspi->hdmatx->XferHalfCpltCallback = NULL;
20003f70:	2300      	movs	r3, #0
20003f72:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmatx->XferCpltCallback = NULL;
20003f74:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;

  /* Enable the Tx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
20003f76:	320c      	adds	r2, #12
20003f78:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
20003f7a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
20003f7c:	f000 fc30 	bl	200047e0 <HAL_DMA_Start_IT>

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
20003f80:	6823      	ldr	r3, [r4, #0]
20003f82:	681a      	ldr	r2, [r3, #0]
20003f84:	0652      	lsls	r2, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
20003f86:	bf5e      	ittt	pl
20003f88:	681a      	ldrpl	r2, [r3, #0]
20003f8a:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
20003f8e:	601a      	strpl	r2, [r3, #0]
  }

  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
20003f90:	685a      	ldr	r2, [r3, #4]
20003f92:	f042 0202 	orr.w	r2, r2, #2
20003f96:	605a      	str	r2, [r3, #4]
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;
20003f98:	2000      	movs	r0, #0
20003f9a:	e002      	b.n	20003fa2 <HAL_SPI_TransmitReceive_DMA.part.5+0x15a>
  __HAL_LOCK(hspi);

  if(!((hspi->State == HAL_SPI_STATE_READY) ||
      ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX))))
  {
    errorcode = HAL_BUSY;
20003f9c:	2002      	movs	r0, #2
20003f9e:	e000      	b.n	20003fa2 <HAL_SPI_TransmitReceive_DMA.part.5+0x15a>
    goto error;
  }

  if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
  {
    errorcode = HAL_ERROR;
20003fa0:	2001      	movs	r0, #1
  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
20003fa2:	2300      	movs	r3, #0
20003fa4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
}
20003fa8:	bd38      	pop	{r3, r4, r5, pc}
20003faa:	bf00      	nop
20003fac:	200040f3 	.word	0x200040f3
20003fb0:	200040dd 	.word	0x200040dd
20003fb4:	200040e9 	.word	0x200040e9
20003fb8:	20004115 	.word	0x20004115
20003fbc:	200041d7 	.word	0x200041d7

20003fc0 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
20003fc0:	b570      	push	{r4, r5, r6, lr}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if(hspi == NULL)
20003fc2:	4604      	mov	r4, r0
20003fc4:	2800      	cmp	r0, #0
20003fc6:	d050      	beq.n	2000406a <HAL_SPI_Init+0xaa>
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
  assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));

  if(hspi->State == HAL_SPI_STATE_RESET)
20003fc8:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
20003fcc:	b91b      	cbnz	r3, 20003fd6 <HAL_SPI_Init+0x16>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
20003fce:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
20003fd2:	f7fc fb29 	bl	20000628 <HAL_SPI_MspInit>
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
20003fd6:	6821      	ldr	r1, [r4, #0]

  /* Align by default the rs fifo threshold on the data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
20003fd8:	68e2      	ldr	r2, [r4, #12]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
20003fda:	2302      	movs	r3, #2
20003fdc:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
20003fe0:	680b      	ldr	r3, [r1, #0]

  /* Align by default the rs fifo threshold on the data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
20003fe2:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
20003fe6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
20003fea:	600b      	str	r3, [r1, #0]
20003fec:	f04f 0300 	mov.w	r3, #0

  /* Align by default the rs fifo threshold on the data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
20003ff0:	d903      	bls.n	20003ffa <HAL_SPI_Init+0x3a>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
20003ff2:	4618      	mov	r0, r3
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
20003ff4:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
20003ff8:	e001      	b.n	20003ffe <HAL_SPI_Init+0x3e>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
20003ffa:	f44f 5080 	mov.w	r0, #4096	; 0x1000

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
20003ffe:	bf18      	it	ne
20004000:	62a3      	strne	r3, [r4, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
20004002:	6b23      	ldr	r3, [r4, #48]	; 0x30
20004004:	b92b      	cbnz	r3, 20004012 <HAL_SPI_Init+0x52>
  {
    /* CRC Length aligned on the data size : value set by default */
    if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
20004006:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
2000400a:	bf8c      	ite	hi
2000400c:	2302      	movhi	r3, #2
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
2000400e:	2301      	movls	r3, #1
20004010:	6323      	str	r3, [r4, #48]	; 0x30
20004012:	6865      	ldr	r5, [r4, #4]
20004014:	68a6      	ldr	r6, [r4, #8]

  /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
20004016:	69a3      	ldr	r3, [r4, #24]
20004018:	432e      	orrs	r6, r5
2000401a:	6925      	ldr	r5, [r4, #16]
2000401c:	432e      	orrs	r6, r5
2000401e:	6965      	ldr	r5, [r4, #20]
20004020:	432e      	orrs	r6, r5
20004022:	69e5      	ldr	r5, [r4, #28]
20004024:	432e      	orrs	r6, r5
20004026:	6a25      	ldr	r5, [r4, #32]
20004028:	432e      	orrs	r6, r5
2000402a:	6aa5      	ldr	r5, [r4, #40]	; 0x28
2000402c:	432e      	orrs	r6, r5
2000402e:	f403 7500 	and.w	r5, r3, #512	; 0x200
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
20004032:	4335      	orrs	r5, r6
  }

  /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
20004034:	600d      	str	r5, [r1, #0]
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);

  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
20004036:	6b25      	ldr	r5, [r4, #48]	; 0x30
20004038:	2d02      	cmp	r5, #2
  {
    hspi->Instance->CR1|= SPI_CR1_CRCL;
2000403a:	bf02      	ittt	eq
2000403c:	680d      	ldreq	r5, [r1, #0]
2000403e:	f445 6500 	orreq.w	r5, r5, #2048	; 0x800
20004042:	600d      	streq	r5, [r1, #0]
20004044:	6a65      	ldr	r5, [r4, #36]	; 0x24
20004046:	432a      	orrs	r2, r5
20004048:	6b65      	ldr	r5, [r4, #52]	; 0x34
  }

  /* Configure : NSS management */
  /* Configure : Rx Fifo Threshold */
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
2000404a:	0c1b      	lsrs	r3, r3, #16
2000404c:	4315      	orrs	r5, r2
2000404e:	f003 0204 	and.w	r2, r3, #4
20004052:	ea45 0302 	orr.w	r3, r5, r2
                         hspi->Init.DataSize ) | frxth;
20004056:	4303      	orrs	r3, r0
    hspi->Instance->CR1|= SPI_CR1_CRCL;
  }

  /* Configure : NSS management */
  /* Configure : Rx Fifo Threshold */
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
20004058:	604b      	str	r3, [r1, #4]
                         hspi->Init.DataSize ) | frxth;

  /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Configure : CRC Polynomial */
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
2000405a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
2000405c:	610b      	str	r3, [r1, #16]

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
2000405e:	2000      	movs	r0, #0
  hspi->State= HAL_SPI_STATE_READY;
20004060:	2301      	movs	r3, #1

  /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Configure : CRC Polynomial */
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
20004062:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State= HAL_SPI_STATE_READY;
20004064:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  return HAL_OK;
20004068:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
2000406a:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State= HAL_SPI_STATE_READY;

  return HAL_OK;
}
2000406c:	bd70      	pop	{r4, r5, r6, pc}

2000406e <HAL_SPI_DeInit>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
2000406e:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
20004070:	4604      	mov	r4, r0
20004072:	b180      	cbz	r0, 20004096 <HAL_SPI_DeInit+0x28>
  /* Check the parameters */
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the SPI Peripheral Clock */
  __HAL_SPI_DISABLE(hspi);
20004074:	6802      	ldr	r2, [r0, #0]
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
  hspi->State = HAL_SPI_STATE_BUSY;
20004076:	2302      	movs	r3, #2
20004078:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d

  /* Disable the SPI Peripheral Clock */
  __HAL_SPI_DISABLE(hspi);
2000407c:	6813      	ldr	r3, [r2, #0]
2000407e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
20004082:	6013      	str	r3, [r2, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_SPI_MspDeInit(hspi);
20004084:	f7fc fb8e 	bl	200007a4 <HAL_SPI_MspDeInit>

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
20004088:	2000      	movs	r0, #0
2000408a:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_RESET;
2000408c:	f884 005d 	strb.w	r0, [r4, #93]	; 0x5d

  __HAL_UNLOCK(hspi);
20004090:	f884 005c 	strb.w	r0, [r4, #92]	; 0x5c

  return HAL_OK;
20004094:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
20004096:	2001      	movs	r0, #1
  hspi->State = HAL_SPI_STATE_RESET;

  __HAL_UNLOCK(hspi);

  return HAL_OK;
}
20004098:	bd10      	pop	{r4, pc}

2000409a <HAL_SPI_TransmitReceive_DMA>:
  * @note  When the CRC feature is enabled the pRxData Length must be Size + 1
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
2000409a:	b510      	push	{r4, lr}
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
2000409c:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
200040a0:	2c01      	cmp	r4, #1
200040a2:	d003      	beq.n	200040ac <HAL_SPI_TransmitReceive_DMA+0x12>

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
200040a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
200040a8:	f7ff bece 	b.w	20003e48 <HAL_SPI_TransmitReceive_DMA.part.5>
200040ac:	2002      	movs	r0, #2
200040ae:	bd10      	pop	{r4, pc}

200040b0 <HAL_SPI_DMAStop>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
{
200040b0:	b510      	push	{r4, lr}
200040b2:	4604      	mov	r4, r0
     when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
     and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
     */

  /* Abort the SPI DMA tx channel */
  if(hspi->hdmatx != NULL)
200040b4:	6d40      	ldr	r0, [r0, #84]	; 0x54
200040b6:	b108      	cbz	r0, 200040bc <HAL_SPI_DMAStop+0xc>
  {
    HAL_DMA_Abort(hspi->hdmatx);
200040b8:	f000 fbb7 	bl	2000482a <HAL_DMA_Abort>
  }
  /* Abort the SPI DMA rx channel */
  if(hspi->hdmarx != NULL)
200040bc:	6da0      	ldr	r0, [r4, #88]	; 0x58
200040be:	b108      	cbz	r0, 200040c4 <HAL_SPI_DMAStop+0x14>
  {
    HAL_DMA_Abort(hspi->hdmarx);
200040c0:	f000 fbb3 	bl	2000482a <HAL_DMA_Abort>
  }

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
200040c4:	6822      	ldr	r2, [r4, #0]
200040c6:	6853      	ldr	r3, [r2, #4]
200040c8:	f023 0303 	bic.w	r3, r3, #3
200040cc:	6053      	str	r3, [r2, #4]
  hspi->State = HAL_SPI_STATE_READY;
200040ce:	2301      	movs	r3, #1
200040d0:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  return HAL_OK;
}
200040d4:	2000      	movs	r0, #0
200040d6:	bd10      	pop	{r4, pc}

200040d8 <HAL_SPI_RxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
200040d8:	4770      	bx	lr

200040da <HAL_SPI_RxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
200040da:	4770      	bx	lr

200040dc <SPI_DMAHalfReceiveCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
{
200040dc:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  HAL_SPI_RxHalfCpltCallback(hspi);
200040de:	6a80      	ldr	r0, [r0, #40]	; 0x28
200040e0:	f7ff fffb 	bl	200040da <HAL_SPI_RxHalfCpltCallback>
200040e4:	bd08      	pop	{r3, pc}

200040e6 <HAL_SPI_TxRxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
200040e6:	4770      	bx	lr

200040e8 <SPI_DMAHalfTransmitReceiveCplt>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
200040e8:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  HAL_SPI_TxRxHalfCpltCallback(hspi);
200040ea:	6a80      	ldr	r0, [r0, #40]	; 0x28
200040ec:	f7ff fffb 	bl	200040e6 <HAL_SPI_TxRxHalfCpltCallback>
200040f0:	bd08      	pop	{r3, pc}

200040f2 <SPI_DMAError>:
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAError(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
200040f2:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* Stop the disable DMA transfer on SPI side */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
200040f4:	6802      	ldr	r2, [r0, #0]
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAError(DMA_HandleTypeDef *hdma)
{
200040f6:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  /* Stop the disable DMA transfer on SPI side */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
200040f8:	6853      	ldr	r3, [r2, #4]
200040fa:	f023 0303 	bic.w	r3, r3, #3
200040fe:	6053      	str	r3, [r2, #4]

  hspi->ErrorCode|= HAL_SPI_ERROR_DMA;
20004100:	6e03      	ldr	r3, [r0, #96]	; 0x60
20004102:	f043 0310 	orr.w	r3, r3, #16
20004106:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
20004108:	2301      	movs	r3, #1
2000410a:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
  HAL_SPI_ErrorCallback(hspi);
2000410e:	f7fc fa1d 	bl	2000054c <HAL_SPI_ErrorCallback>
20004112:	bd08      	pop	{r3, pc}

20004114 <SPI_DMAReceiveCplt>:
  */
static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
20004114:	6803      	ldr	r3, [r0, #0]
20004116:	681b      	ldr	r3, [r3, #0]
20004118:	069a      	lsls	r2, r3, #26
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
2000411a:	b513      	push	{r0, r1, r4, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
2000411c:	6a84      	ldr	r4, [r0, #40]	; 0x28

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
2000411e:	d455      	bmi.n	200041cc <SPI_DMAReceiveCplt+0xb8>
  {
    __IO uint16_t tmpreg;

    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
20004120:	6aa3      	ldr	r3, [r4, #40]	; 0x28
20004122:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20004126:	d12b      	bne.n	20004180 <SPI_DMAReceiveCplt+0x6c>
    {
      /* Wait until TXE flag */
      if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
20004128:	2101      	movs	r1, #1
2000412a:	4620      	mov	r0, r4
2000412c:	460a      	mov	r2, r1
2000412e:	2332      	movs	r3, #50	; 0x32
20004130:	f7ff fdf8 	bl	20003d24 <SPI_WaitFlagStateUntilTimeout>
20004134:	b118      	cbz	r0, 2000413e <SPI_DMAReceiveCplt+0x2a>
      {
        /* Error on the CRC reception */
        hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
20004136:	6e23      	ldr	r3, [r4, #96]	; 0x60
20004138:	f043 0302 	orr.w	r3, r3, #2
2000413c:	6623      	str	r3, [r4, #96]	; 0x60
      }
      if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
2000413e:	68e3      	ldr	r3, [r4, #12]
20004140:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
20004144:	6823      	ldr	r3, [r4, #0]
20004146:	d902      	bls.n	2000414e <SPI_DMAReceiveCplt+0x3a>
      {
        tmpreg = hspi->Instance->DR;
20004148:	68db      	ldr	r3, [r3, #12]
2000414a:	b29b      	uxth	r3, r3
2000414c:	e014      	b.n	20004178 <SPI_DMAReceiveCplt+0x64>
        UNUSED(tmpreg); /* To avoid GCC warning */
      }
      else
      {
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
2000414e:	7b1b      	ldrb	r3, [r3, #12]
20004150:	f8ad 3006 	strh.w	r3, [sp, #6]
        UNUSED(tmpreg); /* To avoid GCC warning */
20004154:	f8bd 3006 	ldrh.w	r3, [sp, #6]

        if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
20004158:	6b23      	ldr	r3, [r4, #48]	; 0x30
2000415a:	2b02      	cmp	r3, #2
2000415c:	d110      	bne.n	20004180 <SPI_DMAReceiveCplt+0x6c>
        {
          if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
2000415e:	2101      	movs	r1, #1
20004160:	4620      	mov	r0, r4
20004162:	460a      	mov	r2, r1
20004164:	2332      	movs	r3, #50	; 0x32
20004166:	f7ff fddd 	bl	20003d24 <SPI_WaitFlagStateUntilTimeout>
2000416a:	b118      	cbz	r0, 20004174 <SPI_DMAReceiveCplt+0x60>
          {
            /* Error on the CRC reception */
            hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
2000416c:	6e23      	ldr	r3, [r4, #96]	; 0x60
2000416e:	f043 0302 	orr.w	r3, r3, #2
20004172:	6623      	str	r3, [r4, #96]	; 0x60
          }
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
20004174:	6823      	ldr	r3, [r4, #0]
20004176:	7b1b      	ldrb	r3, [r3, #12]
20004178:	f8ad 3006 	strh.w	r3, [sp, #6]
          UNUSED(tmpreg); /* To avoid GCC warning */
2000417c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        }
      }
    }

    /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
20004180:	6822      	ldr	r2, [r4, #0]
20004182:	6853      	ldr	r3, [r2, #4]
20004184:	f023 0303 	bic.w	r3, r3, #3
20004188:	6053      	str	r3, [r2, #4]

    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
2000418a:	4620      	mov	r0, r4
2000418c:	2132      	movs	r1, #50	; 0x32
2000418e:	f7ff fe26 	bl	20003dde <SPI_EndRxTransaction>
20004192:	b118      	cbz	r0, 2000419c <SPI_DMAReceiveCplt+0x88>
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
20004194:	6e23      	ldr	r3, [r4, #96]	; 0x60
20004196:	f043 0320 	orr.w	r3, r3, #32
2000419a:	6623      	str	r3, [r4, #96]	; 0x60
    }

    hspi->RxXferCount = 0;
2000419c:	2300      	movs	r3, #0
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
2000419e:	6822      	ldr	r2, [r4, #0]
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    }

    hspi->RxXferCount = 0;
200041a0:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    hspi->State = HAL_SPI_STATE_READY;
200041a4:	2301      	movs	r3, #1
200041a6:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
200041aa:	6893      	ldr	r3, [r2, #8]
200041ac:	06db      	lsls	r3, r3, #27
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
200041ae:	bf41      	itttt	mi
200041b0:	6e23      	ldrmi	r3, [r4, #96]	; 0x60
200041b2:	f043 0302 	orrmi.w	r3, r3, #2
200041b6:	6623      	strmi	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
200041b8:	f64f 73ef 	movwmi	r3, #65519	; 0xffef
200041bc:	bf48      	it	mi
200041be:	6093      	strmi	r3, [r2, #8]
    }

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
200041c0:	6e23      	ldr	r3, [r4, #96]	; 0x60
200041c2:	b11b      	cbz	r3, 200041cc <SPI_DMAReceiveCplt+0xb8>
    {
      HAL_SPI_ErrorCallback(hspi);
200041c4:	4620      	mov	r0, r4
200041c6:	f7fc f9c1 	bl	2000054c <HAL_SPI_ErrorCallback>
      return;
200041ca:	e002      	b.n	200041d2 <SPI_DMAReceiveCplt+0xbe>
    }
  }
  HAL_SPI_RxCpltCallback(hspi);
200041cc:	4620      	mov	r0, r4
200041ce:	f7ff ff83 	bl	200040d8 <HAL_SPI_RxCpltCallback>
}
200041d2:	b002      	add	sp, #8
200041d4:	bd10      	pop	{r4, pc}

200041d6 <SPI_DMATransmitReceiveCplt>:
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
200041d6:	6803      	ldr	r3, [r0, #0]
200041d8:	681b      	ldr	r3, [r3, #0]
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
200041da:	b513      	push	{r0, r1, r4, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
200041dc:	0699      	lsls	r1, r3, #26
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
200041de:	6a84      	ldr	r4, [r0, #40]	; 0x28

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
200041e0:	d456      	bmi.n	20004290 <SPI_DMATransmitReceiveCplt+0xba>
  {
    __IO int16_t tmpreg;
    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
200041e2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
200041e4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200041e8:	d127      	bne.n	2000423a <SPI_DMATransmitReceiveCplt+0x64>
    {
      if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
200041ea:	68e3      	ldr	r3, [r4, #12]
200041ec:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
      { 
        if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
200041f0:	4620      	mov	r0, r4
200041f2:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  {
    __IO int16_t tmpreg;
    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
200041f6:	d10f      	bne.n	20004218 <SPI_DMATransmitReceiveCplt+0x42>
200041f8:	6b23      	ldr	r3, [r4, #48]	; 0x30
200041fa:	2b01      	cmp	r3, #1
200041fc:	d10c      	bne.n	20004218 <SPI_DMATransmitReceiveCplt+0x42>
      { 
        if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
200041fe:	f44f 7200 	mov.w	r2, #512	; 0x200
20004202:	2332      	movs	r3, #50	; 0x32
20004204:	f7ff fd3e 	bl	20003c84 <SPI_WaitFifoStateUntilTimeout>
20004208:	b118      	cbz	r0, 20004212 <SPI_DMATransmitReceiveCplt+0x3c>
        {
          /* Error on the CRC reception */
          hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
2000420a:	6e23      	ldr	r3, [r4, #96]	; 0x60
2000420c:	f043 0302 	orr.w	r3, r3, #2
20004210:	6623      	str	r3, [r4, #96]	; 0x60
        }
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
20004212:	6823      	ldr	r3, [r4, #0]
20004214:	7b1b      	ldrb	r3, [r3, #12]
20004216:	e00c      	b.n	20004232 <SPI_DMATransmitReceiveCplt+0x5c>
        UNUSED(tmpreg); /* To avoid GCC warning */  
      }
      else
      {
        if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
20004218:	f44f 6280 	mov.w	r2, #1024	; 0x400
2000421c:	2332      	movs	r3, #50	; 0x32
2000421e:	f7ff fd31 	bl	20003c84 <SPI_WaitFifoStateUntilTimeout>
20004222:	b118      	cbz	r0, 2000422c <SPI_DMATransmitReceiveCplt+0x56>
        {
          /* Error on the CRC reception */
          hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
20004224:	6e23      	ldr	r3, [r4, #96]	; 0x60
20004226:	f043 0302 	orr.w	r3, r3, #2
2000422a:	6623      	str	r3, [r4, #96]	; 0x60
        }
        tmpreg = hspi->Instance->DR;
2000422c:	6823      	ldr	r3, [r4, #0]
2000422e:	68db      	ldr	r3, [r3, #12]
20004230:	b29b      	uxth	r3, r3
20004232:	f8ad 3006 	strh.w	r3, [sp, #6]
        UNUSED(tmpreg); /* To avoid GCC warning */  
20004236:	f8bd 3006 	ldrh.w	r3, [sp, #6]
      }
    }

    /* Check the end of the transaction */
    if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT) != HAL_OK)
2000423a:	4620      	mov	r0, r4
2000423c:	2132      	movs	r1, #50	; 0x32
2000423e:	f7ff fdb7 	bl	20003db0 <SPI_EndRxTxTransaction>
20004242:	b108      	cbz	r0, 20004248 <SPI_DMATransmitReceiveCplt+0x72>
    {
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
20004244:	2320      	movs	r3, #32
20004246:	6623      	str	r3, [r4, #96]	; 0x60
    }

    /* Disable Rx/Tx DMA Request */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
20004248:	6823      	ldr	r3, [r4, #0]
2000424a:	685a      	ldr	r2, [r3, #4]
2000424c:	f022 0203 	bic.w	r2, r2, #3
20004250:	605a      	str	r2, [r3, #4]

    hspi->TxXferCount = 0;
20004252:	2200      	movs	r2, #0
20004254:	87e2      	strh	r2, [r4, #62]	; 0x3e
    hspi->RxXferCount = 0;
20004256:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
    hspi->State = HAL_SPI_STATE_READY;
2000425a:	2201      	movs	r2, #1
2000425c:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
20004260:	689a      	ldr	r2, [r3, #8]
20004262:	06d2      	lsls	r2, r2, #27
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
20004264:	bf41      	itttt	mi
20004266:	6e22      	ldrmi	r2, [r4, #96]	; 0x60
20004268:	f042 0202 	orrmi.w	r2, r2, #2
2000426c:	6622      	strmi	r2, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
2000426e:	f64f 72ef 	movwmi	r2, #65519	; 0xffef
20004272:	bf48      	it	mi
20004274:	609a      	strmi	r2, [r3, #8]
    }

    /* For MODS this is an error */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE) != RESET)
20004276:	689b      	ldr	r3, [r3, #8]
20004278:	07db      	lsls	r3, r3, #31
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_RXNE;
2000427a:	bf42      	ittt	mi
2000427c:	6e23      	ldrmi	r3, [r4, #96]	; 0x60
2000427e:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
20004282:	6623      	strmi	r3, [r4, #96]	; 0x60
    }

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
20004284:	6e23      	ldr	r3, [r4, #96]	; 0x60
20004286:	b11b      	cbz	r3, 20004290 <SPI_DMATransmitReceiveCplt+0xba>
    {
      HAL_SPI_ErrorCallback(hspi);
20004288:	4620      	mov	r0, r4
2000428a:	f7fc f95f 	bl	2000054c <HAL_SPI_ErrorCallback>
      return;
2000428e:	e002      	b.n	20004296 <SPI_DMATransmitReceiveCplt+0xc0>
    }
  }
  HAL_SPI_TxRxCpltCallback(hspi);
20004290:	4620      	mov	r0, r4
20004292:	f7fc f973 	bl	2000057c <HAL_SPI_TxRxCpltCallback>
}
20004296:	b002      	add	sp, #8
20004298:	bd10      	pop	{r4, pc}
	...

2000429c <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
2000429c:	b530      	push	{r4, r5, lr}
  uint32_t tmp = 0;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
2000429e:	2800      	cmp	r0, #0
200042a0:	f000 80a7 	beq.w	200043f2 <HAL_DMA_Init+0x156>
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
  {
    assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));
  }
  
  if(hdma->State == HAL_DMA_STATE_RESET)
200042a4:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
200042a8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
200042ac:	b90b      	cbnz	r3, 200042b2 <HAL_DMA_Init+0x16>
  {  
    /* Allocate lock resource and initialize it */
    hdma->Lock = HAL_UNLOCKED;
200042ae:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
200042b2:	6885      	ldr	r5, [r0, #8]
200042b4:	68c1      	ldr	r1, [r0, #12]
200042b6:	ea45 0401 	orr.w	r4, r5, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
200042ba:	6901      	ldr	r1, [r0, #16]
200042bc:	430c      	orrs	r4, r1
200042be:	6941      	ldr	r1, [r0, #20]
    /* Allocate lock resource and initialize it */
    hdma->Lock = HAL_UNLOCKED;
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
200042c0:	2302      	movs	r3, #2
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
200042c2:	430c      	orrs	r4, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
200042c4:	6981      	ldr	r1, [r0, #24]
    /* Allocate lock resource and initialize it */
    hdma->Lock = HAL_UNLOCKED;
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
200042c6:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
200042ca:	6803      	ldr	r3, [r0, #0]
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
200042cc:	430c      	orrs	r4, r1
200042ce:	69c1      	ldr	r1, [r0, #28]

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
200042d0:	681a      	ldr	r2, [r3, #0]
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
200042d2:	430c      	orrs	r4, r1
          hdma->Init.Mode                | hdma->Init.Priority;
200042d4:	6a01      	ldr	r1, [r0, #32]

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
200042d6:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
200042da:	f022 0230 	bic.w	r2, r2, #48	; 0x30

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;
200042de:	4321      	orrs	r1, r4
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
200042e0:	430a      	orrs	r2, r1

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;

  /* Set request selection */
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
200042e2:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;
200042e6:	601a      	str	r2, [r3, #0]

  /* Set request selection */
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
200042e8:	d07c      	beq.n	200043e4 <HAL_DMA_Init+0x148>
  {
    /* Write to DMA channel selection register */
    if (hdma->Instance == DMA1_Channel1)
200042ea:	4a43      	ldr	r2, [pc, #268]	; (200043f8 <HAL_DMA_Init+0x15c>)
200042ec:	4293      	cmp	r3, r2
200042ee:	d101      	bne.n	200042f4 <HAL_DMA_Init+0x58>
    {
      /*Reset request selection for DMA1 Channel1*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C1S;
200042f0:	4b42      	ldr	r3, [pc, #264]	; (200043fc <HAL_DMA_Init+0x160>)
200042f2:	e021      	b.n	20004338 <HAL_DMA_Init+0x9c>

      /* Configure request selection for DMA1 Channel1 */
      DMA1_CSELR->CSELR |= hdma->Init.Request;
    }
    else if (hdma->Instance == DMA1_Channel2)
200042f4:	4a42      	ldr	r2, [pc, #264]	; (20004400 <HAL_DMA_Init+0x164>)
200042f6:	4293      	cmp	r3, r2
200042f8:	d101      	bne.n	200042fe <HAL_DMA_Init+0x62>
    {
      /*Reset request selection for DMA1 Channel2*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C2S;
200042fa:	4b40      	ldr	r3, [pc, #256]	; (200043fc <HAL_DMA_Init+0x160>)
200042fc:	e028      	b.n	20004350 <HAL_DMA_Init+0xb4>

      /* Configure request selection for DMA1 Channel2 */
      DMA1_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
    }
    else if (hdma->Instance == DMA1_Channel3)
200042fe:	4a41      	ldr	r2, [pc, #260]	; (20004404 <HAL_DMA_Init+0x168>)
20004300:	4293      	cmp	r3, r2
20004302:	d101      	bne.n	20004308 <HAL_DMA_Init+0x6c>
    {
      /*Reset request selection for DMA1 Channel3*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C3S;
20004304:	4b3d      	ldr	r3, [pc, #244]	; (200043fc <HAL_DMA_Init+0x160>)
20004306:	e030      	b.n	2000436a <HAL_DMA_Init+0xce>

      /* Configure request selection for DMA1 Channel3 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
    }
    else if (hdma->Instance == DMA1_Channel4)
20004308:	4a3f      	ldr	r2, [pc, #252]	; (20004408 <HAL_DMA_Init+0x16c>)
2000430a:	4293      	cmp	r3, r2
2000430c:	d101      	bne.n	20004312 <HAL_DMA_Init+0x76>
    {
      /*Reset request selection for DMA1 Channel4*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C4S;
2000430e:	4b3b      	ldr	r3, [pc, #236]	; (200043fc <HAL_DMA_Init+0x160>)
20004310:	e038      	b.n	20004384 <HAL_DMA_Init+0xe8>

      /* Configure request selection for DMA1 Channel4 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
    }
    else if (hdma->Instance == DMA1_Channel5)
20004312:	4a3e      	ldr	r2, [pc, #248]	; (2000440c <HAL_DMA_Init+0x170>)
20004314:	4293      	cmp	r3, r2
20004316:	d101      	bne.n	2000431c <HAL_DMA_Init+0x80>
    {
      /*Reset request selection for DMA1 Channel5*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C5S;
20004318:	4b38      	ldr	r3, [pc, #224]	; (200043fc <HAL_DMA_Init+0x160>)
2000431a:	e040      	b.n	2000439e <HAL_DMA_Init+0x102>

      /* Configure request selection for DMA1 Channel5 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
    }
    else if (hdma->Instance == DMA1_Channel6)
2000431c:	4a3c      	ldr	r2, [pc, #240]	; (20004410 <HAL_DMA_Init+0x174>)
2000431e:	4293      	cmp	r3, r2
20004320:	d101      	bne.n	20004326 <HAL_DMA_Init+0x8a>
    {
      /*Reset request selection for DMA1 Channel6*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C6S;
20004322:	4b36      	ldr	r3, [pc, #216]	; (200043fc <HAL_DMA_Init+0x160>)
20004324:	e048      	b.n	200043b8 <HAL_DMA_Init+0x11c>

      /* Configure request selection for DMA1 Channel6 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 20);
    }
    else if (hdma->Instance == DMA1_Channel7)
20004326:	4a3b      	ldr	r2, [pc, #236]	; (20004414 <HAL_DMA_Init+0x178>)
20004328:	4293      	cmp	r3, r2
2000432a:	d101      	bne.n	20004330 <HAL_DMA_Init+0x94>
    {
      /*Reset request selection for DMA1 Channel7*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C7S;
2000432c:	4b33      	ldr	r3, [pc, #204]	; (200043fc <HAL_DMA_Init+0x160>)
2000432e:	e050      	b.n	200043d2 <HAL_DMA_Init+0x136>

      /* Configure request selection for DMA1 Channel7 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
    }
    else if (hdma->Instance == DMA2_Channel1)
20004330:	4a39      	ldr	r2, [pc, #228]	; (20004418 <HAL_DMA_Init+0x17c>)
20004332:	4293      	cmp	r3, r2
20004334:	d108      	bne.n	20004348 <HAL_DMA_Init+0xac>
    {
      /*Reset request selection for DMA2 Channel1*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C1S;
20004336:	4b39      	ldr	r3, [pc, #228]	; (2000441c <HAL_DMA_Init+0x180>)
20004338:	681a      	ldr	r2, [r3, #0]
2000433a:	f022 020f 	bic.w	r2, r2, #15
2000433e:	601a      	str	r2, [r3, #0]

      /* Configure request selection for DMA2 Channel1 */
      DMA2_CSELR->CSELR |= hdma->Init.Request;
20004340:	6819      	ldr	r1, [r3, #0]
20004342:	6842      	ldr	r2, [r0, #4]
20004344:	430a      	orrs	r2, r1
20004346:	e04c      	b.n	200043e2 <HAL_DMA_Init+0x146>
    }
    else if (hdma->Instance == DMA2_Channel2)
20004348:	4a35      	ldr	r2, [pc, #212]	; (20004420 <HAL_DMA_Init+0x184>)
2000434a:	4293      	cmp	r3, r2
2000434c:	d109      	bne.n	20004362 <HAL_DMA_Init+0xc6>
    {
      /*Reset request selection for DMA2 Channel2*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C2S;
2000434e:	4b33      	ldr	r3, [pc, #204]	; (2000441c <HAL_DMA_Init+0x180>)
20004350:	681a      	ldr	r2, [r3, #0]
20004352:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
20004356:	601a      	str	r2, [r3, #0]

      /* Configure request selection for DMA2 Channel2 */
      DMA2_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
20004358:	681a      	ldr	r2, [r3, #0]
2000435a:	6841      	ldr	r1, [r0, #4]
2000435c:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
20004360:	e03f      	b.n	200043e2 <HAL_DMA_Init+0x146>
    }
    else if (hdma->Instance == DMA2_Channel3)
20004362:	4a30      	ldr	r2, [pc, #192]	; (20004424 <HAL_DMA_Init+0x188>)
20004364:	4293      	cmp	r3, r2
20004366:	d109      	bne.n	2000437c <HAL_DMA_Init+0xe0>
    {
      /*Reset request selection for DMA2 Channel3*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C3S;
20004368:	4b2c      	ldr	r3, [pc, #176]	; (2000441c <HAL_DMA_Init+0x180>)
2000436a:	681a      	ldr	r2, [r3, #0]
2000436c:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
20004370:	601a      	str	r2, [r3, #0]

      /* Configure request selection for DMA2 Channel3 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
20004372:	681a      	ldr	r2, [r3, #0]
20004374:	6841      	ldr	r1, [r0, #4]
20004376:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
2000437a:	e032      	b.n	200043e2 <HAL_DMA_Init+0x146>
    }
    else if (hdma->Instance == DMA2_Channel4)
2000437c:	4a2a      	ldr	r2, [pc, #168]	; (20004428 <HAL_DMA_Init+0x18c>)
2000437e:	4293      	cmp	r3, r2
20004380:	d109      	bne.n	20004396 <HAL_DMA_Init+0xfa>
    {
      /*Reset request selection for DMA2 Channel4*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C4S;
20004382:	4b26      	ldr	r3, [pc, #152]	; (2000441c <HAL_DMA_Init+0x180>)
20004384:	681a      	ldr	r2, [r3, #0]
20004386:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
2000438a:	601a      	str	r2, [r3, #0]

      /* Configure request selection for DMA2 Channel4 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
2000438c:	681a      	ldr	r2, [r3, #0]
2000438e:	6841      	ldr	r1, [r0, #4]
20004390:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
20004394:	e025      	b.n	200043e2 <HAL_DMA_Init+0x146>
    }
    else if (hdma->Instance == DMA2_Channel5)
20004396:	4a25      	ldr	r2, [pc, #148]	; (2000442c <HAL_DMA_Init+0x190>)
20004398:	4293      	cmp	r3, r2
2000439a:	d109      	bne.n	200043b0 <HAL_DMA_Init+0x114>
    {
      /*Reset request selection for DMA2 Channel5*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C5S;
2000439c:	4b1f      	ldr	r3, [pc, #124]	; (2000441c <HAL_DMA_Init+0x180>)
2000439e:	681a      	ldr	r2, [r3, #0]
200043a0:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
200043a4:	601a      	str	r2, [r3, #0]

      /* Configure request selection for DMA2 Channel5 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
200043a6:	681a      	ldr	r2, [r3, #0]
200043a8:	6841      	ldr	r1, [r0, #4]
200043aa:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
200043ae:	e018      	b.n	200043e2 <HAL_DMA_Init+0x146>
    }
    else if (hdma->Instance == DMA2_Channel6)
200043b0:	4a1f      	ldr	r2, [pc, #124]	; (20004430 <HAL_DMA_Init+0x194>)
200043b2:	4293      	cmp	r3, r2
200043b4:	d109      	bne.n	200043ca <HAL_DMA_Init+0x12e>
    {
      /*Reset request selection for DMA2 Channel6*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C6S;
200043b6:	4b19      	ldr	r3, [pc, #100]	; (2000441c <HAL_DMA_Init+0x180>)
200043b8:	681a      	ldr	r2, [r3, #0]
200043ba:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
200043be:	601a      	str	r2, [r3, #0]

      /* Configure request selection for DMA2 Channel6 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 20);
200043c0:	681a      	ldr	r2, [r3, #0]
200043c2:	6841      	ldr	r1, [r0, #4]
200043c4:	ea42 5201 	orr.w	r2, r2, r1, lsl #20
200043c8:	e00b      	b.n	200043e2 <HAL_DMA_Init+0x146>
    }
    else if (hdma->Instance == DMA2_Channel7)
200043ca:	4a1a      	ldr	r2, [pc, #104]	; (20004434 <HAL_DMA_Init+0x198>)
200043cc:	4293      	cmp	r3, r2
200043ce:	d109      	bne.n	200043e4 <HAL_DMA_Init+0x148>
    {
      /*Reset request selection for DMA2 Channel7*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C7S;
200043d0:	4b12      	ldr	r3, [pc, #72]	; (2000441c <HAL_DMA_Init+0x180>)
200043d2:	681a      	ldr	r2, [r3, #0]
200043d4:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
200043d8:	601a      	str	r2, [r3, #0]

      /* Configure request selection for DMA2 Channel7 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
200043da:	681a      	ldr	r2, [r3, #0]
200043dc:	6841      	ldr	r1, [r0, #4]
200043de:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
200043e2:	601a      	str	r2, [r3, #0]
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
200043e4:	2300      	movs	r3, #0

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
200043e6:	2201      	movs	r2, #1
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
200043e8:	6383      	str	r3, [r0, #56]	; 0x38

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
200043ea:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25

  return HAL_OK;
200043ee:	4618      	mov	r0, r3
200043f0:	bd30      	pop	{r4, r5, pc}
  uint32_t tmp = 0;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
  {
    return HAL_ERROR;
200043f2:	2001      	movs	r0, #1

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;

  return HAL_OK;
}
200043f4:	bd30      	pop	{r4, r5, pc}
200043f6:	bf00      	nop
200043f8:	40020008 	.word	0x40020008
200043fc:	400200a8 	.word	0x400200a8
20004400:	4002001c 	.word	0x4002001c
20004404:	40020030 	.word	0x40020030
20004408:	40020044 	.word	0x40020044
2000440c:	40020058 	.word	0x40020058
20004410:	4002006c 	.word	0x4002006c
20004414:	40020080 	.word	0x40020080
20004418:	40020408 	.word	0x40020408
2000441c:	400204a8 	.word	0x400204a8
20004420:	4002041c 	.word	0x4002041c
20004424:	40020430 	.word	0x40020430
20004428:	40020444 	.word	0x40020444
2000442c:	40020458 	.word	0x40020458
20004430:	4002046c 	.word	0x4002046c
20004434:	40020480 	.word	0x40020480

20004438 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
20004438:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the DMA handle allocation */
  if(hdma == NULL)
2000443a:	2800      	cmp	r0, #0
2000443c:	f000 81bf 	beq.w	200047be <HAL_DMA_DeInit+0x386>
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
20004440:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
20004444:	2b02      	cmp	r3, #2
20004446:	f000 81ba 	beq.w	200047be <HAL_DMA_DeInit+0x386>
  {
     return HAL_ERROR;
  }

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);
2000444a:	6803      	ldr	r3, [r0, #0]

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
2000444c:	4daf      	ldr	r5, [pc, #700]	; (2000470c <HAL_DMA_DeInit+0x2d4>)
  {
     return HAL_ERROR;
  }

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);
2000444e:	681a      	ldr	r2, [r3, #0]
20004450:	4caf      	ldr	r4, [pc, #700]	; (20004710 <HAL_DMA_DeInit+0x2d8>)
20004452:	f022 0201 	bic.w	r2, r2, #1
20004456:	601a      	str	r2, [r3, #0]

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
20004458:	42ab      	cmp	r3, r5

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);

  /* Reset DMA Channel control register */
  hdma->Instance->CCR  = 0;
2000445a:	f04f 0200 	mov.w	r2, #0
2000445e:	601a      	str	r2, [r3, #0]

  /* Reset DMA Channel Number of Data to Transfer register */
  hdma->Instance->CNDTR = 0;
20004460:	605a      	str	r2, [r3, #4]

  /* Reset DMA Channel peripheral address register */
  hdma->Instance->CPAR  = 0;
20004462:	609a      	str	r2, [r3, #8]

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;
20004464:	60da      	str	r2, [r3, #12]

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
20004466:	d92e      	bls.n	200044c6 <HAL_DMA_DeInit+0x8e>
20004468:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
2000446c:	4ea9      	ldr	r6, [pc, #676]	; (20004714 <HAL_DMA_DeInit+0x2dc>)
2000446e:	f502 3201 	add.w	r2, r2, #132096	; 0x20400
20004472:	42b3      	cmp	r3, r6
20004474:	6857      	ldr	r7, [r2, #4]
20004476:	d013      	beq.n	200044a0 <HAL_DMA_DeInit+0x68>
20004478:	49a7      	ldr	r1, [pc, #668]	; (20004718 <HAL_DMA_DeInit+0x2e0>)
2000447a:	428b      	cmp	r3, r1
2000447c:	d012      	beq.n	200044a4 <HAL_DMA_DeInit+0x6c>
2000447e:	3114      	adds	r1, #20
20004480:	428b      	cmp	r3, r1
20004482:	d011      	beq.n	200044a8 <HAL_DMA_DeInit+0x70>
20004484:	3114      	adds	r1, #20
20004486:	428b      	cmp	r3, r1
20004488:	d011      	beq.n	200044ae <HAL_DMA_DeInit+0x76>
2000448a:	3114      	adds	r1, #20
2000448c:	428b      	cmp	r3, r1
2000448e:	d011      	beq.n	200044b4 <HAL_DMA_DeInit+0x7c>
20004490:	3114      	adds	r1, #20
20004492:	428b      	cmp	r3, r1
20004494:	bf0c      	ite	eq
20004496:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
2000449a:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
2000449e:	e00b      	b.n	200044b8 <HAL_DMA_DeInit+0x80>
200044a0:	2101      	movs	r1, #1
200044a2:	e009      	b.n	200044b8 <HAL_DMA_DeInit+0x80>
200044a4:	2110      	movs	r1, #16
200044a6:	e007      	b.n	200044b8 <HAL_DMA_DeInit+0x80>
200044a8:	f44f 7180 	mov.w	r1, #256	; 0x100
200044ac:	e004      	b.n	200044b8 <HAL_DMA_DeInit+0x80>
200044ae:	f44f 5180 	mov.w	r1, #4096	; 0x1000
200044b2:	e001      	b.n	200044b8 <HAL_DMA_DeInit+0x80>
200044b4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
200044b8:	4339      	orrs	r1, r7
200044ba:	6051      	str	r1, [r2, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
200044bc:	42b3      	cmp	r3, r6
200044be:	6857      	ldr	r7, [r2, #4]
200044c0:	d12d      	bne.n	2000451e <HAL_DMA_DeInit+0xe6>
200044c2:	2102      	movs	r1, #2
200044c4:	e049      	b.n	2000455a <HAL_DMA_DeInit+0x122>

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
200044c6:	4a95      	ldr	r2, [pc, #596]	; (2000471c <HAL_DMA_DeInit+0x2e4>)
200044c8:	42a3      	cmp	r3, r4
200044ca:	6851      	ldr	r1, [r2, #4]
200044cc:	d013      	beq.n	200044f6 <HAL_DMA_DeInit+0xbe>
200044ce:	321c      	adds	r2, #28
200044d0:	4293      	cmp	r3, r2
200044d2:	d012      	beq.n	200044fa <HAL_DMA_DeInit+0xc2>
200044d4:	3214      	adds	r2, #20
200044d6:	4293      	cmp	r3, r2
200044d8:	d011      	beq.n	200044fe <HAL_DMA_DeInit+0xc6>
200044da:	3214      	adds	r2, #20
200044dc:	4293      	cmp	r3, r2
200044de:	d011      	beq.n	20004504 <HAL_DMA_DeInit+0xcc>
200044e0:	3214      	adds	r2, #20
200044e2:	4293      	cmp	r3, r2
200044e4:	d011      	beq.n	2000450a <HAL_DMA_DeInit+0xd2>
200044e6:	3214      	adds	r2, #20
200044e8:	4293      	cmp	r3, r2
200044ea:	bf0c      	ite	eq
200044ec:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
200044f0:	f04f 7280 	movne.w	r2, #16777216	; 0x1000000
200044f4:	e00b      	b.n	2000450e <HAL_DMA_DeInit+0xd6>
200044f6:	2201      	movs	r2, #1
200044f8:	e009      	b.n	2000450e <HAL_DMA_DeInit+0xd6>
200044fa:	2210      	movs	r2, #16
200044fc:	e007      	b.n	2000450e <HAL_DMA_DeInit+0xd6>
200044fe:	f44f 7280 	mov.w	r2, #256	; 0x100
20004502:	e004      	b.n	2000450e <HAL_DMA_DeInit+0xd6>
20004504:	f44f 5280 	mov.w	r2, #4096	; 0x1000
20004508:	e001      	b.n	2000450e <HAL_DMA_DeInit+0xd6>
2000450a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000450e:	430a      	orrs	r2, r1
20004510:	4982      	ldr	r1, [pc, #520]	; (2000471c <HAL_DMA_DeInit+0x2e4>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
20004512:	42a3      	cmp	r3, r4

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
20004514:	604a      	str	r2, [r1, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
20004516:	6849      	ldr	r1, [r1, #4]
20004518:	d126      	bne.n	20004568 <HAL_DMA_DeInit+0x130>
2000451a:	2202      	movs	r2, #2
2000451c:	e042      	b.n	200045a4 <HAL_DMA_DeInit+0x16c>
2000451e:	497e      	ldr	r1, [pc, #504]	; (20004718 <HAL_DMA_DeInit+0x2e0>)
20004520:	428b      	cmp	r3, r1
20004522:	d010      	beq.n	20004546 <HAL_DMA_DeInit+0x10e>
20004524:	3114      	adds	r1, #20
20004526:	428b      	cmp	r3, r1
20004528:	d00f      	beq.n	2000454a <HAL_DMA_DeInit+0x112>
2000452a:	3114      	adds	r1, #20
2000452c:	428b      	cmp	r3, r1
2000452e:	d00f      	beq.n	20004550 <HAL_DMA_DeInit+0x118>
20004530:	3114      	adds	r1, #20
20004532:	428b      	cmp	r3, r1
20004534:	d00f      	beq.n	20004556 <HAL_DMA_DeInit+0x11e>
20004536:	3114      	adds	r1, #20
20004538:	428b      	cmp	r3, r1
2000453a:	bf0c      	ite	eq
2000453c:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
20004540:	f04f 7100 	movne.w	r1, #33554432	; 0x2000000
20004544:	e009      	b.n	2000455a <HAL_DMA_DeInit+0x122>
20004546:	2120      	movs	r1, #32
20004548:	e007      	b.n	2000455a <HAL_DMA_DeInit+0x122>
2000454a:	f44f 7100 	mov.w	r1, #512	; 0x200
2000454e:	e004      	b.n	2000455a <HAL_DMA_DeInit+0x122>
20004550:	f44f 5100 	mov.w	r1, #8192	; 0x2000
20004554:	e001      	b.n	2000455a <HAL_DMA_DeInit+0x122>
20004556:	f44f 3100 	mov.w	r1, #131072	; 0x20000
2000455a:	4339      	orrs	r1, r7
2000455c:	6051      	str	r1, [r2, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
2000455e:	42b3      	cmp	r3, r6
20004560:	6857      	ldr	r7, [r2, #4]
20004562:	d127      	bne.n	200045b4 <HAL_DMA_DeInit+0x17c>
20004564:	2108      	movs	r1, #8
20004566:	e043      	b.n	200045f0 <HAL_DMA_DeInit+0x1b8>
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
20004568:	4a6d      	ldr	r2, [pc, #436]	; (20004720 <HAL_DMA_DeInit+0x2e8>)
2000456a:	4293      	cmp	r3, r2
2000456c:	d010      	beq.n	20004590 <HAL_DMA_DeInit+0x158>
2000456e:	3214      	adds	r2, #20
20004570:	4293      	cmp	r3, r2
20004572:	d00f      	beq.n	20004594 <HAL_DMA_DeInit+0x15c>
20004574:	3214      	adds	r2, #20
20004576:	4293      	cmp	r3, r2
20004578:	d00f      	beq.n	2000459a <HAL_DMA_DeInit+0x162>
2000457a:	3214      	adds	r2, #20
2000457c:	4293      	cmp	r3, r2
2000457e:	d00f      	beq.n	200045a0 <HAL_DMA_DeInit+0x168>
20004580:	3214      	adds	r2, #20
20004582:	4293      	cmp	r3, r2
20004584:	bf0c      	ite	eq
20004586:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
2000458a:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
2000458e:	e009      	b.n	200045a4 <HAL_DMA_DeInit+0x16c>
20004590:	2220      	movs	r2, #32
20004592:	e007      	b.n	200045a4 <HAL_DMA_DeInit+0x16c>
20004594:	f44f 7200 	mov.w	r2, #512	; 0x200
20004598:	e004      	b.n	200045a4 <HAL_DMA_DeInit+0x16c>
2000459a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
2000459e:	e001      	b.n	200045a4 <HAL_DMA_DeInit+0x16c>
200045a0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
200045a4:	430a      	orrs	r2, r1
200045a6:	495d      	ldr	r1, [pc, #372]	; (2000471c <HAL_DMA_DeInit+0x2e4>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
200045a8:	42a3      	cmp	r3, r4
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
200045aa:	604a      	str	r2, [r1, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
200045ac:	6849      	ldr	r1, [r1, #4]
200045ae:	d126      	bne.n	200045fe <HAL_DMA_DeInit+0x1c6>
200045b0:	2208      	movs	r2, #8
200045b2:	e042      	b.n	2000463a <HAL_DMA_DeInit+0x202>
200045b4:	4958      	ldr	r1, [pc, #352]	; (20004718 <HAL_DMA_DeInit+0x2e0>)
200045b6:	428b      	cmp	r3, r1
200045b8:	d010      	beq.n	200045dc <HAL_DMA_DeInit+0x1a4>
200045ba:	3114      	adds	r1, #20
200045bc:	428b      	cmp	r3, r1
200045be:	d00f      	beq.n	200045e0 <HAL_DMA_DeInit+0x1a8>
200045c0:	3114      	adds	r1, #20
200045c2:	428b      	cmp	r3, r1
200045c4:	d00f      	beq.n	200045e6 <HAL_DMA_DeInit+0x1ae>
200045c6:	3114      	adds	r1, #20
200045c8:	428b      	cmp	r3, r1
200045ca:	d00f      	beq.n	200045ec <HAL_DMA_DeInit+0x1b4>
200045cc:	3114      	adds	r1, #20
200045ce:	428b      	cmp	r3, r1
200045d0:	bf0c      	ite	eq
200045d2:	f44f 0100 	moveq.w	r1, #8388608	; 0x800000
200045d6:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
200045da:	e009      	b.n	200045f0 <HAL_DMA_DeInit+0x1b8>
200045dc:	2180      	movs	r1, #128	; 0x80
200045de:	e007      	b.n	200045f0 <HAL_DMA_DeInit+0x1b8>
200045e0:	f44f 6100 	mov.w	r1, #2048	; 0x800
200045e4:	e004      	b.n	200045f0 <HAL_DMA_DeInit+0x1b8>
200045e6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
200045ea:	e001      	b.n	200045f0 <HAL_DMA_DeInit+0x1b8>
200045ec:	f44f 2100 	mov.w	r1, #524288	; 0x80000
200045f0:	4339      	orrs	r1, r7
200045f2:	6051      	str	r1, [r2, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
200045f4:	42b3      	cmp	r3, r6
200045f6:	6857      	ldr	r7, [r2, #4]
200045f8:	d127      	bne.n	2000464a <HAL_DMA_DeInit+0x212>
200045fa:	2104      	movs	r1, #4
200045fc:	e043      	b.n	20004686 <HAL_DMA_DeInit+0x24e>
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
200045fe:	4a48      	ldr	r2, [pc, #288]	; (20004720 <HAL_DMA_DeInit+0x2e8>)
20004600:	4293      	cmp	r3, r2
20004602:	d010      	beq.n	20004626 <HAL_DMA_DeInit+0x1ee>
20004604:	3214      	adds	r2, #20
20004606:	4293      	cmp	r3, r2
20004608:	d00f      	beq.n	2000462a <HAL_DMA_DeInit+0x1f2>
2000460a:	3214      	adds	r2, #20
2000460c:	4293      	cmp	r3, r2
2000460e:	d00f      	beq.n	20004630 <HAL_DMA_DeInit+0x1f8>
20004610:	3214      	adds	r2, #20
20004612:	4293      	cmp	r3, r2
20004614:	d00f      	beq.n	20004636 <HAL_DMA_DeInit+0x1fe>
20004616:	3214      	adds	r2, #20
20004618:	4293      	cmp	r3, r2
2000461a:	bf0c      	ite	eq
2000461c:	f44f 0200 	moveq.w	r2, #8388608	; 0x800000
20004620:	f04f 6200 	movne.w	r2, #134217728	; 0x8000000
20004624:	e009      	b.n	2000463a <HAL_DMA_DeInit+0x202>
20004626:	2280      	movs	r2, #128	; 0x80
20004628:	e007      	b.n	2000463a <HAL_DMA_DeInit+0x202>
2000462a:	f44f 6200 	mov.w	r2, #2048	; 0x800
2000462e:	e004      	b.n	2000463a <HAL_DMA_DeInit+0x202>
20004630:	f44f 4200 	mov.w	r2, #32768	; 0x8000
20004634:	e001      	b.n	2000463a <HAL_DMA_DeInit+0x202>
20004636:	f44f 2200 	mov.w	r2, #524288	; 0x80000
2000463a:	430a      	orrs	r2, r1
2000463c:	4937      	ldr	r1, [pc, #220]	; (2000471c <HAL_DMA_DeInit+0x2e4>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
2000463e:	42a3      	cmp	r3, r4
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
20004640:	604a      	str	r2, [r1, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
20004642:	6849      	ldr	r1, [r1, #4]
20004644:	d122      	bne.n	2000468c <HAL_DMA_DeInit+0x254>
20004646:	2204      	movs	r2, #4
20004648:	e03e      	b.n	200046c8 <HAL_DMA_DeInit+0x290>
2000464a:	4933      	ldr	r1, [pc, #204]	; (20004718 <HAL_DMA_DeInit+0x2e0>)
2000464c:	428b      	cmp	r3, r1
2000464e:	d010      	beq.n	20004672 <HAL_DMA_DeInit+0x23a>
20004650:	3114      	adds	r1, #20
20004652:	428b      	cmp	r3, r1
20004654:	d00f      	beq.n	20004676 <HAL_DMA_DeInit+0x23e>
20004656:	3114      	adds	r1, #20
20004658:	428b      	cmp	r3, r1
2000465a:	d00f      	beq.n	2000467c <HAL_DMA_DeInit+0x244>
2000465c:	3114      	adds	r1, #20
2000465e:	428b      	cmp	r3, r1
20004660:	d00f      	beq.n	20004682 <HAL_DMA_DeInit+0x24a>
20004662:	3114      	adds	r1, #20
20004664:	428b      	cmp	r3, r1
20004666:	bf0c      	ite	eq
20004668:	f44f 0180 	moveq.w	r1, #4194304	; 0x400000
2000466c:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
20004670:	e009      	b.n	20004686 <HAL_DMA_DeInit+0x24e>
20004672:	2140      	movs	r1, #64	; 0x40
20004674:	e007      	b.n	20004686 <HAL_DMA_DeInit+0x24e>
20004676:	f44f 6180 	mov.w	r1, #1024	; 0x400
2000467a:	e004      	b.n	20004686 <HAL_DMA_DeInit+0x24e>
2000467c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
20004680:	e001      	b.n	20004686 <HAL_DMA_DeInit+0x24e>
20004682:	f44f 2180 	mov.w	r1, #262144	; 0x40000
20004686:	4339      	orrs	r1, r7
20004688:	6051      	str	r1, [r2, #4]
2000468a:	e020      	b.n	200046ce <HAL_DMA_DeInit+0x296>
2000468c:	4a24      	ldr	r2, [pc, #144]	; (20004720 <HAL_DMA_DeInit+0x2e8>)
2000468e:	4293      	cmp	r3, r2
20004690:	d010      	beq.n	200046b4 <HAL_DMA_DeInit+0x27c>
20004692:	3214      	adds	r2, #20
20004694:	4293      	cmp	r3, r2
20004696:	d00f      	beq.n	200046b8 <HAL_DMA_DeInit+0x280>
20004698:	3214      	adds	r2, #20
2000469a:	4293      	cmp	r3, r2
2000469c:	d00f      	beq.n	200046be <HAL_DMA_DeInit+0x286>
2000469e:	3214      	adds	r2, #20
200046a0:	4293      	cmp	r3, r2
200046a2:	d00f      	beq.n	200046c4 <HAL_DMA_DeInit+0x28c>
200046a4:	3214      	adds	r2, #20
200046a6:	4293      	cmp	r3, r2
200046a8:	bf0c      	ite	eq
200046aa:	f44f 0280 	moveq.w	r2, #4194304	; 0x400000
200046ae:	f04f 6280 	movne.w	r2, #67108864	; 0x4000000
200046b2:	e009      	b.n	200046c8 <HAL_DMA_DeInit+0x290>
200046b4:	2240      	movs	r2, #64	; 0x40
200046b6:	e007      	b.n	200046c8 <HAL_DMA_DeInit+0x290>
200046b8:	f44f 6280 	mov.w	r2, #1024	; 0x400
200046bc:	e004      	b.n	200046c8 <HAL_DMA_DeInit+0x290>
200046be:	f44f 4280 	mov.w	r2, #16384	; 0x4000
200046c2:	e001      	b.n	200046c8 <HAL_DMA_DeInit+0x290>
200046c4:	f44f 2280 	mov.w	r2, #262144	; 0x40000
200046c8:	430a      	orrs	r2, r1
200046ca:	4914      	ldr	r1, [pc, #80]	; (2000471c <HAL_DMA_DeInit+0x2e4>)
200046cc:	604a      	str	r2, [r1, #4]

  /* Reset DMA channel selection register */
  if (hdma->Instance == DMA1_Channel1)
200046ce:	42a3      	cmp	r3, r4
200046d0:	d104      	bne.n	200046dc <HAL_DMA_DeInit+0x2a4>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C1S;
200046d2:	4a14      	ldr	r2, [pc, #80]	; (20004724 <HAL_DMA_DeInit+0x2ec>)
200046d4:	6813      	ldr	r3, [r2, #0]
200046d6:	f023 030f 	bic.w	r3, r3, #15
200046da:	e014      	b.n	20004706 <HAL_DMA_DeInit+0x2ce>
  }
  else if (hdma->Instance == DMA1_Channel2)
200046dc:	4a10      	ldr	r2, [pc, #64]	; (20004720 <HAL_DMA_DeInit+0x2e8>)
200046de:	4293      	cmp	r3, r2
200046e0:	d037      	beq.n	20004752 <HAL_DMA_DeInit+0x31a>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C2S;
  }
  else if (hdma->Instance == DMA1_Channel3)
200046e2:	4a11      	ldr	r2, [pc, #68]	; (20004728 <HAL_DMA_DeInit+0x2f0>)
200046e4:	4293      	cmp	r3, r2
200046e6:	d03e      	beq.n	20004766 <HAL_DMA_DeInit+0x32e>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C3S;
  }
  else if (hdma->Instance == DMA1_Channel4)
200046e8:	4a10      	ldr	r2, [pc, #64]	; (2000472c <HAL_DMA_DeInit+0x2f4>)
200046ea:	4293      	cmp	r3, r2
200046ec:	d043      	beq.n	20004776 <HAL_DMA_DeInit+0x33e>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C4S;
  }
  else if (hdma->Instance == DMA1_Channel5)
200046ee:	4a10      	ldr	r2, [pc, #64]	; (20004730 <HAL_DMA_DeInit+0x2f8>)
200046f0:	4293      	cmp	r3, r2
200046f2:	d048      	beq.n	20004786 <HAL_DMA_DeInit+0x34e>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C5S;
  }
  else if (hdma->Instance == DMA1_Channel6)
200046f4:	4a0f      	ldr	r2, [pc, #60]	; (20004734 <HAL_DMA_DeInit+0x2fc>)
200046f6:	4293      	cmp	r3, r2
200046f8:	d04d      	beq.n	20004796 <HAL_DMA_DeInit+0x35e>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C6S;
  }
  else if (hdma->Instance == DMA1_Channel7)
200046fa:	42ab      	cmp	r3, r5
200046fc:	d11c      	bne.n	20004738 <HAL_DMA_DeInit+0x300>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C7S;
200046fe:	4a09      	ldr	r2, [pc, #36]	; (20004724 <HAL_DMA_DeInit+0x2ec>)
20004700:	6813      	ldr	r3, [r2, #0]
20004702:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
20004706:	6013      	str	r3, [r2, #0]
20004708:	e051      	b.n	200047ae <HAL_DMA_DeInit+0x376>
2000470a:	bf00      	nop
2000470c:	40020080 	.word	0x40020080
20004710:	40020008 	.word	0x40020008
20004714:	40020408 	.word	0x40020408
20004718:	4002041c 	.word	0x4002041c
2000471c:	40020000 	.word	0x40020000
20004720:	4002001c 	.word	0x4002001c
20004724:	400200a8 	.word	0x400200a8
20004728:	40020030 	.word	0x40020030
2000472c:	40020044 	.word	0x40020044
20004730:	40020058 	.word	0x40020058
20004734:	4002006c 	.word	0x4002006c
  }
  else if (hdma->Instance == DMA2_Channel1)
20004738:	4a22      	ldr	r2, [pc, #136]	; (200047c4 <HAL_DMA_DeInit+0x38c>)
2000473a:	4293      	cmp	r3, r2
2000473c:	d106      	bne.n	2000474c <HAL_DMA_DeInit+0x314>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C1S;
2000473e:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
20004742:	f023 030f 	bic.w	r3, r3, #15
20004746:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
2000474a:	e030      	b.n	200047ae <HAL_DMA_DeInit+0x376>
  }
  else if (hdma->Instance == DMA2_Channel2)
2000474c:	4a1e      	ldr	r2, [pc, #120]	; (200047c8 <HAL_DMA_DeInit+0x390>)
2000474e:	4293      	cmp	r3, r2
20004750:	d106      	bne.n	20004760 <HAL_DMA_DeInit+0x328>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C2S;
20004752:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
20004756:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
2000475a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
2000475e:	e026      	b.n	200047ae <HAL_DMA_DeInit+0x376>
  }
  else if (hdma->Instance == DMA2_Channel3)
20004760:	4a1a      	ldr	r2, [pc, #104]	; (200047cc <HAL_DMA_DeInit+0x394>)
20004762:	4293      	cmp	r3, r2
20004764:	d104      	bne.n	20004770 <HAL_DMA_DeInit+0x338>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C3S;
20004766:	6f93      	ldr	r3, [r2, #120]	; 0x78
20004768:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
2000476c:	6793      	str	r3, [r2, #120]	; 0x78
2000476e:	e01e      	b.n	200047ae <HAL_DMA_DeInit+0x376>
  }
  else if (hdma->Instance == DMA2_Channel4)
20004770:	4a17      	ldr	r2, [pc, #92]	; (200047d0 <HAL_DMA_DeInit+0x398>)
20004772:	4293      	cmp	r3, r2
20004774:	d104      	bne.n	20004780 <HAL_DMA_DeInit+0x348>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C4S;
20004776:	6e53      	ldr	r3, [r2, #100]	; 0x64
20004778:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
2000477c:	6653      	str	r3, [r2, #100]	; 0x64
2000477e:	e016      	b.n	200047ae <HAL_DMA_DeInit+0x376>
  }
  else if (hdma->Instance == DMA2_Channel5)
20004780:	4a14      	ldr	r2, [pc, #80]	; (200047d4 <HAL_DMA_DeInit+0x39c>)
20004782:	4293      	cmp	r3, r2
20004784:	d104      	bne.n	20004790 <HAL_DMA_DeInit+0x358>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C5S;
20004786:	6d13      	ldr	r3, [r2, #80]	; 0x50
20004788:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
2000478c:	6513      	str	r3, [r2, #80]	; 0x50
2000478e:	e00e      	b.n	200047ae <HAL_DMA_DeInit+0x376>
  }
  else if (hdma->Instance == DMA2_Channel6)
20004790:	4a11      	ldr	r2, [pc, #68]	; (200047d8 <HAL_DMA_DeInit+0x3a0>)
20004792:	4293      	cmp	r3, r2
20004794:	d104      	bne.n	200047a0 <HAL_DMA_DeInit+0x368>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C6S;
20004796:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
20004798:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
2000479c:	63d3      	str	r3, [r2, #60]	; 0x3c
2000479e:	e006      	b.n	200047ae <HAL_DMA_DeInit+0x376>
  }
  else if (hdma->Instance == DMA2_Channel7)
200047a0:	4a0e      	ldr	r2, [pc, #56]	; (200047dc <HAL_DMA_DeInit+0x3a4>)
200047a2:	4293      	cmp	r3, r2
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C7S;
200047a4:	bf02      	ittt	eq
200047a6:	6a93      	ldreq	r3, [r2, #40]	; 0x28
200047a8:	f023 6370 	biceq.w	r3, r3, #251658240	; 0xf000000
200047ac:	6293      	streq	r3, [r2, #40]	; 0x28
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
200047ae:	2300      	movs	r3, #0
200047b0:	6383      	str	r3, [r0, #56]	; 0x38

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);
200047b2:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
200047b6:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25

  /* Release Lock */
  __HAL_UNLOCK(hdma);

  return HAL_OK;
200047ba:	4618      	mov	r0, r3
200047bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
  /* Check the DMA handle allocation */
  if(hdma == NULL)
  {
    return HAL_ERROR;
200047be:	2001      	movs	r0, #1

  /* Release Lock */
  __HAL_UNLOCK(hdma);

  return HAL_OK;
}
200047c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
200047c2:	bf00      	nop
200047c4:	40020408 	.word	0x40020408
200047c8:	4002041c 	.word	0x4002041c
200047cc:	40020430 	.word	0x40020430
200047d0:	40020444 	.word	0x40020444
200047d4:	40020458 	.word	0x40020458
200047d8:	4002046c 	.word	0x4002046c
200047dc:	40020480 	.word	0x40020480

200047e0 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
200047e0:	b530      	push	{r4, r5, lr}
  /* Process locked */
  __HAL_LOCK(hdma);
200047e2:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
200047e6:	2c01      	cmp	r4, #1
200047e8:	f04f 0402 	mov.w	r4, #2
200047ec:	d01b      	beq.n	20004826 <HAL_DMA_Start_IT+0x46>

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
200047ee:	f880 4025 	strb.w	r4, [r0, #37]	; 0x25

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
200047f2:	6804      	ldr	r4, [r0, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Process locked */
  __HAL_LOCK(hdma);
200047f4:	2501      	movs	r5, #1
200047f6:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
200047fa:	6825      	ldr	r5, [r4, #0]
200047fc:	f025 0501 	bic.w	r5, r5, #1
20004800:	6025      	str	r5, [r4, #0]
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
20004802:	6063      	str	r3, [r4, #4]

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
20004804:	6883      	ldr	r3, [r0, #8]
20004806:	2b10      	cmp	r3, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
20004808:	bf0b      	itete	eq
2000480a:	60a2      	streq	r2, [r4, #8]
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
2000480c:	60a1      	strne	r1, [r4, #8]
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;

    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
2000480e:	60e1      	streq	r1, [r4, #12]
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
20004810:	60e2      	strne	r2, [r4, #12]
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);

  /* Enable the transfer complete interrupt */
  /* Enable the Half transfer complete interrupt */
  /* Enable the transfer Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
20004812:	6823      	ldr	r3, [r4, #0]
20004814:	f043 030e 	orr.w	r3, r3, #14
20004818:	6023      	str	r3, [r4, #0]

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
2000481a:	6823      	ldr	r3, [r4, #0]
2000481c:	f043 0301 	orr.w	r3, r3, #1
20004820:	6023      	str	r3, [r4, #0]

  return HAL_OK;
20004822:	2000      	movs	r0, #0
20004824:	bd30      	pop	{r4, r5, pc}
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Process locked */
  __HAL_LOCK(hdma);
20004826:	4620      	mov	r0, r4

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);

  return HAL_OK;
}
20004828:	bd30      	pop	{r4, r5, pc}

2000482a <HAL_DMA_Abort>:
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
  uint32_t tickstart = 0;

  /* Disable the channel */
  __HAL_DMA_DISABLE(hdma);
2000482a:	6802      	ldr	r2, [r0, #0]
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
2000482c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0;

  /* Disable the channel */
  __HAL_DMA_DISABLE(hdma);
2000482e:	6813      	ldr	r3, [r2, #0]
20004830:	f023 0301 	bic.w	r3, r3, #1
20004834:	6013      	str	r3, [r2, #0]
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
20004836:	4604      	mov	r4, r0

  /* Disable the channel */
  __HAL_DMA_DISABLE(hdma);

  /* Get timeout */
  tickstart = HAL_GetTick();
20004838:	f7ff f80a 	bl	20003850 <HAL_GetTick>
2000483c:	4605      	mov	r5, r0

  /* Check if the DMA Channel is effectively disabled */
  while((hdma->Instance->CCR & DMA_CCR_EN) != 0)
2000483e:	6823      	ldr	r3, [r4, #0]
20004840:	6818      	ldr	r0, [r3, #0]
20004842:	f010 0001 	ands.w	r0, r0, #1
20004846:	d010      	beq.n	2000486a <HAL_DMA_Abort+0x40>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
20004848:	f7ff f802 	bl	20003850 <HAL_GetTick>
2000484c:	1b40      	subs	r0, r0, r5
2000484e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
20004852:	d9f4      	bls.n	2000483e <HAL_DMA_Abort+0x14>
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
20004854:	6ba3      	ldr	r3, [r4, #56]	; 0x38
20004856:	f043 0320 	orr.w	r3, r3, #32
2000485a:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
2000485c:	2003      	movs	r0, #3

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
2000485e:	2300      	movs	r3, #0
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
20004860:	f884 0025 	strb.w	r0, [r4, #37]	; 0x25

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
20004864:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24

      return HAL_TIMEOUT;
20004868:	bd38      	pop	{r3, r4, r5, pc}
    }
  }
  /* Change the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
2000486a:	2301      	movs	r3, #1
2000486c:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
  
  /* Process Unlocked */
  __HAL_UNLOCK(hdma);
20004870:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
  
  return HAL_OK; 
}
20004874:	bd38      	pop	{r3, r4, r5, pc}
	...

20004878 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
20004878:	b570      	push	{r4, r5, r6, lr}
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
2000487a:	6803      	ldr	r3, [r0, #0]
2000487c:	4db3      	ldr	r5, [pc, #716]	; (20004b4c <HAL_DMA_IRQHandler+0x2d4>)
2000487e:	42ab      	cmp	r3, r5
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
20004880:	4604      	mov	r4, r0
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
20004882:	d927      	bls.n	200048d4 <HAL_DMA_IRQHandler+0x5c>
20004884:	4ab2      	ldr	r2, [pc, #712]	; (20004b50 <HAL_DMA_IRQHandler+0x2d8>)
20004886:	6811      	ldr	r1, [r2, #0]
20004888:	3208      	adds	r2, #8
2000488a:	4293      	cmp	r3, r2
2000488c:	d013      	beq.n	200048b6 <HAL_DMA_IRQHandler+0x3e>
2000488e:	3214      	adds	r2, #20
20004890:	4293      	cmp	r3, r2
20004892:	d012      	beq.n	200048ba <HAL_DMA_IRQHandler+0x42>
20004894:	3214      	adds	r2, #20
20004896:	4293      	cmp	r3, r2
20004898:	d011      	beq.n	200048be <HAL_DMA_IRQHandler+0x46>
2000489a:	3214      	adds	r2, #20
2000489c:	4293      	cmp	r3, r2
2000489e:	d011      	beq.n	200048c4 <HAL_DMA_IRQHandler+0x4c>
200048a0:	3214      	adds	r2, #20
200048a2:	4293      	cmp	r3, r2
200048a4:	d011      	beq.n	200048ca <HAL_DMA_IRQHandler+0x52>
200048a6:	3214      	adds	r2, #20
200048a8:	4293      	cmp	r3, r2
200048aa:	bf0c      	ite	eq
200048ac:	f44f 0200 	moveq.w	r2, #8388608	; 0x800000
200048b0:	f04f 6200 	movne.w	r2, #134217728	; 0x8000000
200048b4:	e00b      	b.n	200048ce <HAL_DMA_IRQHandler+0x56>
200048b6:	2208      	movs	r2, #8
200048b8:	e009      	b.n	200048ce <HAL_DMA_IRQHandler+0x56>
200048ba:	2280      	movs	r2, #128	; 0x80
200048bc:	e007      	b.n	200048ce <HAL_DMA_IRQHandler+0x56>
200048be:	f44f 6200 	mov.w	r2, #2048	; 0x800
200048c2:	e004      	b.n	200048ce <HAL_DMA_IRQHandler+0x56>
200048c4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
200048c8:	e001      	b.n	200048ce <HAL_DMA_IRQHandler+0x56>
200048ca:	f44f 2200 	mov.w	r2, #524288	; 0x80000
200048ce:	420a      	tst	r2, r1
200048d0:	d128      	bne.n	20004924 <HAL_DMA_IRQHandler+0xac>
200048d2:	e092      	b.n	200049fa <HAL_DMA_IRQHandler+0x182>
200048d4:	4a9f      	ldr	r2, [pc, #636]	; (20004b54 <HAL_DMA_IRQHandler+0x2dc>)
200048d6:	6811      	ldr	r1, [r2, #0]
200048d8:	3208      	adds	r2, #8
200048da:	4293      	cmp	r3, r2
200048dc:	d013      	beq.n	20004906 <HAL_DMA_IRQHandler+0x8e>
200048de:	3214      	adds	r2, #20
200048e0:	4293      	cmp	r3, r2
200048e2:	d012      	beq.n	2000490a <HAL_DMA_IRQHandler+0x92>
200048e4:	3214      	adds	r2, #20
200048e6:	4293      	cmp	r3, r2
200048e8:	d011      	beq.n	2000490e <HAL_DMA_IRQHandler+0x96>
200048ea:	3214      	adds	r2, #20
200048ec:	4293      	cmp	r3, r2
200048ee:	d011      	beq.n	20004914 <HAL_DMA_IRQHandler+0x9c>
200048f0:	3214      	adds	r2, #20
200048f2:	4293      	cmp	r3, r2
200048f4:	d011      	beq.n	2000491a <HAL_DMA_IRQHandler+0xa2>
200048f6:	3214      	adds	r2, #20
200048f8:	4293      	cmp	r3, r2
200048fa:	bf0c      	ite	eq
200048fc:	f44f 0200 	moveq.w	r2, #8388608	; 0x800000
20004900:	f04f 6200 	movne.w	r2, #134217728	; 0x8000000
20004904:	e00b      	b.n	2000491e <HAL_DMA_IRQHandler+0xa6>
20004906:	2208      	movs	r2, #8
20004908:	e009      	b.n	2000491e <HAL_DMA_IRQHandler+0xa6>
2000490a:	2280      	movs	r2, #128	; 0x80
2000490c:	e007      	b.n	2000491e <HAL_DMA_IRQHandler+0xa6>
2000490e:	f44f 6200 	mov.w	r2, #2048	; 0x800
20004912:	e004      	b.n	2000491e <HAL_DMA_IRQHandler+0xa6>
20004914:	f44f 4200 	mov.w	r2, #32768	; 0x8000
20004918:	e001      	b.n	2000491e <HAL_DMA_IRQHandler+0xa6>
2000491a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
2000491e:	420a      	tst	r2, r1
20004920:	f000 8093 	beq.w	20004a4a <HAL_DMA_IRQHandler+0x1d2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
20004924:	681a      	ldr	r2, [r3, #0]
20004926:	0712      	lsls	r2, r2, #28
20004928:	d564      	bpl.n	200049f4 <HAL_DMA_IRQHandler+0x17c>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
2000492a:	681a      	ldr	r2, [r3, #0]

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
2000492c:	42ab      	cmp	r3, r5
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
2000492e:	f022 0208 	bic.w	r2, r2, #8
20004932:	601a      	str	r2, [r3, #0]

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
20004934:	d928      	bls.n	20004988 <HAL_DMA_IRQHandler+0x110>
20004936:	4988      	ldr	r1, [pc, #544]	; (20004b58 <HAL_DMA_IRQHandler+0x2e0>)
20004938:	4a85      	ldr	r2, [pc, #532]	; (20004b50 <HAL_DMA_IRQHandler+0x2d8>)
2000493a:	428b      	cmp	r3, r1
2000493c:	6850      	ldr	r0, [r2, #4]
2000493e:	4611      	mov	r1, r2
20004940:	d013      	beq.n	2000496a <HAL_DMA_IRQHandler+0xf2>
20004942:	321c      	adds	r2, #28
20004944:	4293      	cmp	r3, r2
20004946:	d012      	beq.n	2000496e <HAL_DMA_IRQHandler+0xf6>
20004948:	3214      	adds	r2, #20
2000494a:	4293      	cmp	r3, r2
2000494c:	d011      	beq.n	20004972 <HAL_DMA_IRQHandler+0xfa>
2000494e:	3214      	adds	r2, #20
20004950:	4293      	cmp	r3, r2
20004952:	d011      	beq.n	20004978 <HAL_DMA_IRQHandler+0x100>
20004954:	3214      	adds	r2, #20
20004956:	4293      	cmp	r3, r2
20004958:	d011      	beq.n	2000497e <HAL_DMA_IRQHandler+0x106>
2000495a:	3214      	adds	r2, #20
2000495c:	4293      	cmp	r3, r2
2000495e:	bf14      	ite	ne
20004960:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
20004964:	f44f 0300 	moveq.w	r3, #8388608	; 0x800000
20004968:	e00b      	b.n	20004982 <HAL_DMA_IRQHandler+0x10a>
2000496a:	2308      	movs	r3, #8
2000496c:	e009      	b.n	20004982 <HAL_DMA_IRQHandler+0x10a>
2000496e:	2380      	movs	r3, #128	; 0x80
20004970:	e007      	b.n	20004982 <HAL_DMA_IRQHandler+0x10a>
20004972:	f44f 6300 	mov.w	r3, #2048	; 0x800
20004976:	e004      	b.n	20004982 <HAL_DMA_IRQHandler+0x10a>
20004978:	f44f 4300 	mov.w	r3, #32768	; 0x8000
2000497c:	e001      	b.n	20004982 <HAL_DMA_IRQHandler+0x10a>
2000497e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20004982:	4303      	orrs	r3, r0
20004984:	604b      	str	r3, [r1, #4]
20004986:	e027      	b.n	200049d8 <HAL_DMA_IRQHandler+0x160>
20004988:	4a72      	ldr	r2, [pc, #456]	; (20004b54 <HAL_DMA_IRQHandler+0x2dc>)
2000498a:	6851      	ldr	r1, [r2, #4]
2000498c:	3208      	adds	r2, #8
2000498e:	4293      	cmp	r3, r2
20004990:	d013      	beq.n	200049ba <HAL_DMA_IRQHandler+0x142>
20004992:	3214      	adds	r2, #20
20004994:	4293      	cmp	r3, r2
20004996:	d012      	beq.n	200049be <HAL_DMA_IRQHandler+0x146>
20004998:	3214      	adds	r2, #20
2000499a:	4293      	cmp	r3, r2
2000499c:	d011      	beq.n	200049c2 <HAL_DMA_IRQHandler+0x14a>
2000499e:	3214      	adds	r2, #20
200049a0:	4293      	cmp	r3, r2
200049a2:	d011      	beq.n	200049c8 <HAL_DMA_IRQHandler+0x150>
200049a4:	3214      	adds	r2, #20
200049a6:	4293      	cmp	r3, r2
200049a8:	d011      	beq.n	200049ce <HAL_DMA_IRQHandler+0x156>
200049aa:	3214      	adds	r2, #20
200049ac:	4293      	cmp	r3, r2
200049ae:	bf14      	ite	ne
200049b0:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
200049b4:	f44f 0300 	moveq.w	r3, #8388608	; 0x800000
200049b8:	e00b      	b.n	200049d2 <HAL_DMA_IRQHandler+0x15a>
200049ba:	2308      	movs	r3, #8
200049bc:	e009      	b.n	200049d2 <HAL_DMA_IRQHandler+0x15a>
200049be:	2380      	movs	r3, #128	; 0x80
200049c0:	e007      	b.n	200049d2 <HAL_DMA_IRQHandler+0x15a>
200049c2:	f44f 6300 	mov.w	r3, #2048	; 0x800
200049c6:	e004      	b.n	200049d2 <HAL_DMA_IRQHandler+0x15a>
200049c8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
200049cc:	e001      	b.n	200049d2 <HAL_DMA_IRQHandler+0x15a>
200049ce:	f44f 2300 	mov.w	r3, #524288	; 0x80000
200049d2:	4a60      	ldr	r2, [pc, #384]	; (20004b54 <HAL_DMA_IRQHandler+0x2dc>)
200049d4:	430b      	orrs	r3, r1
200049d6:	6053      	str	r3, [r2, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
200049d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
200049da:	f043 0301 	orr.w	r3, r3, #1
200049de:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
200049e0:	2304      	movs	r3, #4
200049e2:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
200049e6:	2300      	movs	r3, #0
200049e8:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24

      if (hdma->XferErrorCallback != NULL)
200049ec:	6b63      	ldr	r3, [r4, #52]	; 0x34
200049ee:	b10b      	cbz	r3, 200049f4 <HAL_DMA_IRQHandler+0x17c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
200049f0:	4620      	mov	r0, r4
200049f2:	4798      	blx	r3
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
200049f4:	6823      	ldr	r3, [r4, #0]
200049f6:	42ab      	cmp	r3, r5
200049f8:	d927      	bls.n	20004a4a <HAL_DMA_IRQHandler+0x1d2>
200049fa:	4a55      	ldr	r2, [pc, #340]	; (20004b50 <HAL_DMA_IRQHandler+0x2d8>)
200049fc:	6811      	ldr	r1, [r2, #0]
200049fe:	3208      	adds	r2, #8
20004a00:	4293      	cmp	r3, r2
20004a02:	d013      	beq.n	20004a2c <HAL_DMA_IRQHandler+0x1b4>
20004a04:	3214      	adds	r2, #20
20004a06:	4293      	cmp	r3, r2
20004a08:	d012      	beq.n	20004a30 <HAL_DMA_IRQHandler+0x1b8>
20004a0a:	3214      	adds	r2, #20
20004a0c:	4293      	cmp	r3, r2
20004a0e:	d011      	beq.n	20004a34 <HAL_DMA_IRQHandler+0x1bc>
20004a10:	3214      	adds	r2, #20
20004a12:	4293      	cmp	r3, r2
20004a14:	d011      	beq.n	20004a3a <HAL_DMA_IRQHandler+0x1c2>
20004a16:	3214      	adds	r2, #20
20004a18:	4293      	cmp	r3, r2
20004a1a:	d011      	beq.n	20004a40 <HAL_DMA_IRQHandler+0x1c8>
20004a1c:	3214      	adds	r2, #20
20004a1e:	4293      	cmp	r3, r2
20004a20:	bf0c      	ite	eq
20004a22:	f44f 0280 	moveq.w	r2, #4194304	; 0x400000
20004a26:	f04f 6280 	movne.w	r2, #67108864	; 0x4000000
20004a2a:	e00b      	b.n	20004a44 <HAL_DMA_IRQHandler+0x1cc>
20004a2c:	2204      	movs	r2, #4
20004a2e:	e009      	b.n	20004a44 <HAL_DMA_IRQHandler+0x1cc>
20004a30:	2240      	movs	r2, #64	; 0x40
20004a32:	e007      	b.n	20004a44 <HAL_DMA_IRQHandler+0x1cc>
20004a34:	f44f 6280 	mov.w	r2, #1024	; 0x400
20004a38:	e004      	b.n	20004a44 <HAL_DMA_IRQHandler+0x1cc>
20004a3a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
20004a3e:	e001      	b.n	20004a44 <HAL_DMA_IRQHandler+0x1cc>
20004a40:	f44f 2280 	mov.w	r2, #262144	; 0x40000
20004a44:	420a      	tst	r2, r1
20004a46:	d127      	bne.n	20004a98 <HAL_DMA_IRQHandler+0x220>
20004a48:	e139      	b.n	20004cbe <HAL_DMA_IRQHandler+0x446>
20004a4a:	4a42      	ldr	r2, [pc, #264]	; (20004b54 <HAL_DMA_IRQHandler+0x2dc>)
20004a4c:	6811      	ldr	r1, [r2, #0]
20004a4e:	3208      	adds	r2, #8
20004a50:	4293      	cmp	r3, r2
20004a52:	d013      	beq.n	20004a7c <HAL_DMA_IRQHandler+0x204>
20004a54:	3214      	adds	r2, #20
20004a56:	4293      	cmp	r3, r2
20004a58:	d012      	beq.n	20004a80 <HAL_DMA_IRQHandler+0x208>
20004a5a:	3214      	adds	r2, #20
20004a5c:	4293      	cmp	r3, r2
20004a5e:	d011      	beq.n	20004a84 <HAL_DMA_IRQHandler+0x20c>
20004a60:	3214      	adds	r2, #20
20004a62:	4293      	cmp	r3, r2
20004a64:	d011      	beq.n	20004a8a <HAL_DMA_IRQHandler+0x212>
20004a66:	3214      	adds	r2, #20
20004a68:	4293      	cmp	r3, r2
20004a6a:	d011      	beq.n	20004a90 <HAL_DMA_IRQHandler+0x218>
20004a6c:	3214      	adds	r2, #20
20004a6e:	4293      	cmp	r3, r2
20004a70:	bf0c      	ite	eq
20004a72:	f44f 0280 	moveq.w	r2, #4194304	; 0x400000
20004a76:	f04f 6280 	movne.w	r2, #67108864	; 0x4000000
20004a7a:	e00b      	b.n	20004a94 <HAL_DMA_IRQHandler+0x21c>
20004a7c:	2204      	movs	r2, #4
20004a7e:	e009      	b.n	20004a94 <HAL_DMA_IRQHandler+0x21c>
20004a80:	2240      	movs	r2, #64	; 0x40
20004a82:	e007      	b.n	20004a94 <HAL_DMA_IRQHandler+0x21c>
20004a84:	f44f 6280 	mov.w	r2, #1024	; 0x400
20004a88:	e004      	b.n	20004a94 <HAL_DMA_IRQHandler+0x21c>
20004a8a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
20004a8e:	e001      	b.n	20004a94 <HAL_DMA_IRQHandler+0x21c>
20004a90:	f44f 2280 	mov.w	r2, #262144	; 0x40000
20004a94:	420a      	tst	r2, r1
20004a96:	d037      	beq.n	20004b08 <HAL_DMA_IRQHandler+0x290>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
20004a98:	681a      	ldr	r2, [r3, #0]
20004a9a:	0756      	lsls	r6, r2, #29
20004a9c:	d52f      	bpl.n	20004afe <HAL_DMA_IRQHandler+0x286>
    {
      /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
20004a9e:	681a      	ldr	r2, [r3, #0]
20004aa0:	0690      	lsls	r0, r2, #26
20004aa2:	d403      	bmi.n	20004aac <HAL_DMA_IRQHandler+0x234>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
20004aa4:	681a      	ldr	r2, [r3, #0]
20004aa6:	f022 0204 	bic.w	r2, r2, #4
20004aaa:	601a      	str	r2, [r3, #0]
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
20004aac:	42ab      	cmp	r3, r5
20004aae:	d96f      	bls.n	20004b90 <HAL_DMA_IRQHandler+0x318>
20004ab0:	4929      	ldr	r1, [pc, #164]	; (20004b58 <HAL_DMA_IRQHandler+0x2e0>)
20004ab2:	4a27      	ldr	r2, [pc, #156]	; (20004b50 <HAL_DMA_IRQHandler+0x2d8>)
20004ab4:	428b      	cmp	r3, r1
20004ab6:	6850      	ldr	r0, [r2, #4]
20004ab8:	4611      	mov	r1, r2
20004aba:	f000 809d 	beq.w	20004bf8 <HAL_DMA_IRQHandler+0x380>
20004abe:	4a27      	ldr	r2, [pc, #156]	; (20004b5c <HAL_DMA_IRQHandler+0x2e4>)
20004ac0:	4293      	cmp	r3, r2
20004ac2:	f000 808e 	beq.w	20004be2 <HAL_DMA_IRQHandler+0x36a>
20004ac6:	3214      	adds	r2, #20
20004ac8:	4293      	cmp	r3, r2
20004aca:	f000 808c 	beq.w	20004be6 <HAL_DMA_IRQHandler+0x36e>
20004ace:	3214      	adds	r2, #20
20004ad0:	4293      	cmp	r3, r2
20004ad2:	f000 808b 	beq.w	20004bec <HAL_DMA_IRQHandler+0x374>
20004ad6:	3214      	adds	r2, #20
20004ad8:	4293      	cmp	r3, r2
20004ada:	f000 808a 	beq.w	20004bf2 <HAL_DMA_IRQHandler+0x37a>
20004ade:	3214      	adds	r2, #20
20004ae0:	4293      	cmp	r3, r2
20004ae2:	bf0c      	ite	eq
20004ae4:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
20004ae8:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
20004aec:	4303      	orrs	r3, r0
20004aee:	604b      	str	r3, [r1, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
20004af0:	2311      	movs	r3, #17
20004af2:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25

      if(hdma->XferHalfCpltCallback != NULL)
20004af6:	6b23      	ldr	r3, [r4, #48]	; 0x30
20004af8:	b10b      	cbz	r3, 20004afe <HAL_DMA_IRQHandler+0x286>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
20004afa:	4620      	mov	r0, r4
20004afc:	4798      	blx	r3
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
20004afe:	6823      	ldr	r3, [r4, #0]
20004b00:	42ab      	cmp	r3, r5
20004b02:	d902      	bls.n	20004b0a <HAL_DMA_IRQHandler+0x292>
20004b04:	4a12      	ldr	r2, [pc, #72]	; (20004b50 <HAL_DMA_IRQHandler+0x2d8>)
20004b06:	e001      	b.n	20004b0c <HAL_DMA_IRQHandler+0x294>
20004b08:	6823      	ldr	r3, [r4, #0]
20004b0a:	4a12      	ldr	r2, [pc, #72]	; (20004b54 <HAL_DMA_IRQHandler+0x2dc>)
20004b0c:	6811      	ldr	r1, [r2, #0]
20004b0e:	3208      	adds	r2, #8
20004b10:	4293      	cmp	r3, r2
20004b12:	d013      	beq.n	20004b3c <HAL_DMA_IRQHandler+0x2c4>
20004b14:	3214      	adds	r2, #20
20004b16:	4293      	cmp	r3, r2
20004b18:	d012      	beq.n	20004b40 <HAL_DMA_IRQHandler+0x2c8>
20004b1a:	3214      	adds	r2, #20
20004b1c:	4293      	cmp	r3, r2
20004b1e:	d011      	beq.n	20004b44 <HAL_DMA_IRQHandler+0x2cc>
20004b20:	3214      	adds	r2, #20
20004b22:	4293      	cmp	r3, r2
20004b24:	d01c      	beq.n	20004b60 <HAL_DMA_IRQHandler+0x2e8>
20004b26:	3214      	adds	r2, #20
20004b28:	4293      	cmp	r3, r2
20004b2a:	d01c      	beq.n	20004b66 <HAL_DMA_IRQHandler+0x2ee>
20004b2c:	3214      	adds	r2, #20
20004b2e:	4293      	cmp	r3, r2
20004b30:	bf0c      	ite	eq
20004b32:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
20004b36:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
20004b3a:	e016      	b.n	20004b6a <HAL_DMA_IRQHandler+0x2f2>
20004b3c:	2202      	movs	r2, #2
20004b3e:	e014      	b.n	20004b6a <HAL_DMA_IRQHandler+0x2f2>
20004b40:	2220      	movs	r2, #32
20004b42:	e012      	b.n	20004b6a <HAL_DMA_IRQHandler+0x2f2>
20004b44:	f44f 7200 	mov.w	r2, #512	; 0x200
20004b48:	e00f      	b.n	20004b6a <HAL_DMA_IRQHandler+0x2f2>
20004b4a:	bf00      	nop
20004b4c:	40020080 	.word	0x40020080
20004b50:	40020400 	.word	0x40020400
20004b54:	40020000 	.word	0x40020000
20004b58:	40020408 	.word	0x40020408
20004b5c:	4002041c 	.word	0x4002041c
20004b60:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20004b64:	e001      	b.n	20004b6a <HAL_DMA_IRQHandler+0x2f2>
20004b66:	f44f 3200 	mov.w	r2, #131072	; 0x20000
20004b6a:	420a      	tst	r2, r1
20004b6c:	bf14      	ite	ne
20004b6e:	2201      	movne	r2, #1
20004b70:	2200      	moveq	r2, #0
20004b72:	2a00      	cmp	r2, #0
20004b74:	f000 80a5 	beq.w	20004cc2 <HAL_DMA_IRQHandler+0x44a>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
20004b78:	681a      	ldr	r2, [r3, #0]
20004b7a:	0791      	lsls	r1, r2, #30
20004b7c:	f140 80a1 	bpl.w	20004cc2 <HAL_DMA_IRQHandler+0x44a>
    {
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
20004b80:	681a      	ldr	r2, [r3, #0]
20004b82:	0692      	lsls	r2, r2, #26
20004b84:	d43a      	bmi.n	20004bfc <HAL_DMA_IRQHandler+0x384>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
20004b86:	681a      	ldr	r2, [r3, #0]
20004b88:	f022 0202 	bic.w	r2, r2, #2
20004b8c:	601a      	str	r2, [r3, #0]
20004b8e:	e035      	b.n	20004bfc <HAL_DMA_IRQHandler+0x384>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
20004b90:	4a4c      	ldr	r2, [pc, #304]	; (20004cc4 <HAL_DMA_IRQHandler+0x44c>)
20004b92:	6851      	ldr	r1, [r2, #4]
20004b94:	3208      	adds	r2, #8
20004b96:	4293      	cmp	r3, r2
20004b98:	d013      	beq.n	20004bc2 <HAL_DMA_IRQHandler+0x34a>
20004b9a:	3214      	adds	r2, #20
20004b9c:	4293      	cmp	r3, r2
20004b9e:	d012      	beq.n	20004bc6 <HAL_DMA_IRQHandler+0x34e>
20004ba0:	3214      	adds	r2, #20
20004ba2:	4293      	cmp	r3, r2
20004ba4:	d011      	beq.n	20004bca <HAL_DMA_IRQHandler+0x352>
20004ba6:	3214      	adds	r2, #20
20004ba8:	4293      	cmp	r3, r2
20004baa:	d011      	beq.n	20004bd0 <HAL_DMA_IRQHandler+0x358>
20004bac:	3214      	adds	r2, #20
20004bae:	4293      	cmp	r3, r2
20004bb0:	d011      	beq.n	20004bd6 <HAL_DMA_IRQHandler+0x35e>
20004bb2:	3214      	adds	r2, #20
20004bb4:	4293      	cmp	r3, r2
20004bb6:	bf0c      	ite	eq
20004bb8:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
20004bbc:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
20004bc0:	e00b      	b.n	20004bda <HAL_DMA_IRQHandler+0x362>
20004bc2:	2304      	movs	r3, #4
20004bc4:	e009      	b.n	20004bda <HAL_DMA_IRQHandler+0x362>
20004bc6:	2340      	movs	r3, #64	; 0x40
20004bc8:	e007      	b.n	20004bda <HAL_DMA_IRQHandler+0x362>
20004bca:	f44f 6380 	mov.w	r3, #1024	; 0x400
20004bce:	e004      	b.n	20004bda <HAL_DMA_IRQHandler+0x362>
20004bd0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
20004bd4:	e001      	b.n	20004bda <HAL_DMA_IRQHandler+0x362>
20004bd6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20004bda:	4a3a      	ldr	r2, [pc, #232]	; (20004cc4 <HAL_DMA_IRQHandler+0x44c>)
20004bdc:	430b      	orrs	r3, r1
20004bde:	6053      	str	r3, [r2, #4]
20004be0:	e786      	b.n	20004af0 <HAL_DMA_IRQHandler+0x278>
20004be2:	2340      	movs	r3, #64	; 0x40
20004be4:	e782      	b.n	20004aec <HAL_DMA_IRQHandler+0x274>
20004be6:	f44f 6380 	mov.w	r3, #1024	; 0x400
20004bea:	e77f      	b.n	20004aec <HAL_DMA_IRQHandler+0x274>
20004bec:	f44f 4380 	mov.w	r3, #16384	; 0x4000
20004bf0:	e77c      	b.n	20004aec <HAL_DMA_IRQHandler+0x274>
20004bf2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20004bf6:	e779      	b.n	20004aec <HAL_DMA_IRQHandler+0x274>
20004bf8:	2304      	movs	r3, #4
20004bfa:	e777      	b.n	20004aec <HAL_DMA_IRQHandler+0x274>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
20004bfc:	42ab      	cmp	r3, r5
20004bfe:	d835      	bhi.n	20004c6c <HAL_DMA_IRQHandler+0x3f4>
20004c00:	4a30      	ldr	r2, [pc, #192]	; (20004cc4 <HAL_DMA_IRQHandler+0x44c>)
20004c02:	6851      	ldr	r1, [r2, #4]
20004c04:	3208      	adds	r2, #8
20004c06:	4293      	cmp	r3, r2
20004c08:	d013      	beq.n	20004c32 <HAL_DMA_IRQHandler+0x3ba>
20004c0a:	3214      	adds	r2, #20
20004c0c:	4293      	cmp	r3, r2
20004c0e:	d012      	beq.n	20004c36 <HAL_DMA_IRQHandler+0x3be>
20004c10:	3214      	adds	r2, #20
20004c12:	4293      	cmp	r3, r2
20004c14:	d011      	beq.n	20004c3a <HAL_DMA_IRQHandler+0x3c2>
20004c16:	3214      	adds	r2, #20
20004c18:	4293      	cmp	r3, r2
20004c1a:	d011      	beq.n	20004c40 <HAL_DMA_IRQHandler+0x3c8>
20004c1c:	3214      	adds	r2, #20
20004c1e:	4293      	cmp	r3, r2
20004c20:	d011      	beq.n	20004c46 <HAL_DMA_IRQHandler+0x3ce>
20004c22:	3214      	adds	r2, #20
20004c24:	4293      	cmp	r3, r2
20004c26:	bf0c      	ite	eq
20004c28:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
20004c2c:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
20004c30:	e00b      	b.n	20004c4a <HAL_DMA_IRQHandler+0x3d2>
20004c32:	2302      	movs	r3, #2
20004c34:	e009      	b.n	20004c4a <HAL_DMA_IRQHandler+0x3d2>
20004c36:	2320      	movs	r3, #32
20004c38:	e007      	b.n	20004c4a <HAL_DMA_IRQHandler+0x3d2>
20004c3a:	f44f 7300 	mov.w	r3, #512	; 0x200
20004c3e:	e004      	b.n	20004c4a <HAL_DMA_IRQHandler+0x3d2>
20004c40:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20004c44:	e001      	b.n	20004c4a <HAL_DMA_IRQHandler+0x3d2>
20004c46:	f44f 3300 	mov.w	r3, #131072	; 0x20000
20004c4a:	4a1e      	ldr	r2, [pc, #120]	; (20004cc4 <HAL_DMA_IRQHandler+0x44c>)
20004c4c:	430b      	orrs	r3, r1
20004c4e:	6053      	str	r3, [r2, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
20004c50:	6ba3      	ldr	r3, [r4, #56]	; 0x38
20004c52:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
20004c54:	2301      	movs	r3, #1
20004c56:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
20004c5a:	2300      	movs	r3, #0
20004c5c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24

      if(hdma->XferCpltCallback != NULL)
20004c60:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
20004c62:	b373      	cbz	r3, 20004cc2 <HAL_DMA_IRQHandler+0x44a>
      {
        /* Transfer complete callback */
        hdma->XferCpltCallback(hdma);
20004c64:	4620      	mov	r0, r4
      }
    }
  }
}
20004c66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      __HAL_UNLOCK(hdma);

      if(hdma->XferCpltCallback != NULL)
      {
        /* Transfer complete callback */
        hdma->XferCpltCallback(hdma);
20004c6a:	4718      	bx	r3
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
20004c6c:	4916      	ldr	r1, [pc, #88]	; (20004cc8 <HAL_DMA_IRQHandler+0x450>)
20004c6e:	4a17      	ldr	r2, [pc, #92]	; (20004ccc <HAL_DMA_IRQHandler+0x454>)
20004c70:	428b      	cmp	r3, r1
20004c72:	6850      	ldr	r0, [r2, #4]
20004c74:	4611      	mov	r1, r2
20004c76:	d020      	beq.n	20004cba <HAL_DMA_IRQHandler+0x442>
20004c78:	4a15      	ldr	r2, [pc, #84]	; (20004cd0 <HAL_DMA_IRQHandler+0x458>)
20004c7a:	4293      	cmp	r3, r2
20004c7c:	d010      	beq.n	20004ca0 <HAL_DMA_IRQHandler+0x428>
20004c7e:	3214      	adds	r2, #20
20004c80:	4293      	cmp	r3, r2
20004c82:	d00f      	beq.n	20004ca4 <HAL_DMA_IRQHandler+0x42c>
20004c84:	3214      	adds	r2, #20
20004c86:	4293      	cmp	r3, r2
20004c88:	d00f      	beq.n	20004caa <HAL_DMA_IRQHandler+0x432>
20004c8a:	3214      	adds	r2, #20
20004c8c:	4293      	cmp	r3, r2
20004c8e:	d00f      	beq.n	20004cb0 <HAL_DMA_IRQHandler+0x438>
20004c90:	3214      	adds	r2, #20
20004c92:	4293      	cmp	r3, r2
20004c94:	bf0c      	ite	eq
20004c96:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
20004c9a:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
20004c9e:	e009      	b.n	20004cb4 <HAL_DMA_IRQHandler+0x43c>
20004ca0:	2320      	movs	r3, #32
20004ca2:	e007      	b.n	20004cb4 <HAL_DMA_IRQHandler+0x43c>
20004ca4:	f44f 7300 	mov.w	r3, #512	; 0x200
20004ca8:	e004      	b.n	20004cb4 <HAL_DMA_IRQHandler+0x43c>
20004caa:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20004cae:	e001      	b.n	20004cb4 <HAL_DMA_IRQHandler+0x43c>
20004cb0:	f44f 3300 	mov.w	r3, #131072	; 0x20000
20004cb4:	4303      	orrs	r3, r0
20004cb6:	604b      	str	r3, [r1, #4]
20004cb8:	e7ca      	b.n	20004c50 <HAL_DMA_IRQHandler+0x3d8>
20004cba:	2302      	movs	r3, #2
20004cbc:	e7fa      	b.n	20004cb4 <HAL_DMA_IRQHandler+0x43c>
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
20004cbe:	6823      	ldr	r3, [r4, #0]
20004cc0:	e720      	b.n	20004b04 <HAL_DMA_IRQHandler+0x28c>
20004cc2:	bd70      	pop	{r4, r5, r6, pc}
20004cc4:	40020000 	.word	0x40020000
20004cc8:	40020408 	.word	0x40020408
20004ccc:	40020400 	.word	0x40020400
20004cd0:	4002041c 	.word	0x4002041c

20004cd4 <FLASH_SetErrorCode>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))
20004cd4:	4b32      	ldr	r3, [pc, #200]	; (20004da0 <FLASH_SetErrorCode+0xcc>)
20004cd6:	691a      	ldr	r2, [r3, #16]
20004cd8:	0792      	lsls	r2, r2, #30
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OP;
20004cda:	bf41      	itttt	mi
20004cdc:	4931      	ldrmi	r1, [pc, #196]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004cde:	684a      	ldrmi	r2, [r1, #4]
20004ce0:	f042 0201 	orrmi.w	r2, r2, #1
20004ce4:	604a      	strmi	r2, [r1, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR))
20004ce6:	691b      	ldr	r3, [r3, #16]
20004ce8:	071b      	lsls	r3, r3, #28
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
20004cea:	bf41      	itttt	mi
20004cec:	4a2d      	ldrmi	r2, [pc, #180]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004cee:	6853      	ldrmi	r3, [r2, #4]
20004cf0:	f043 0302 	orrmi.w	r3, r3, #2
20004cf4:	6053      	strmi	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
20004cf6:	4b2a      	ldr	r3, [pc, #168]	; (20004da0 <FLASH_SetErrorCode+0xcc>)
20004cf8:	691a      	ldr	r2, [r3, #16]
20004cfa:	06d0      	lsls	r0, r2, #27
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
20004cfc:	bf41      	itttt	mi
20004cfe:	4929      	ldrmi	r1, [pc, #164]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d00:	684a      	ldrmi	r2, [r1, #4]
20004d02:	f042 0204 	orrmi.w	r2, r2, #4
20004d06:	604a      	strmi	r2, [r1, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))
20004d08:	691b      	ldr	r3, [r3, #16]
20004d0a:	0699      	lsls	r1, r3, #26
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
20004d0c:	bf41      	itttt	mi
20004d0e:	4a25      	ldrmi	r2, [pc, #148]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d10:	6853      	ldrmi	r3, [r2, #4]
20004d12:	f043 0308 	orrmi.w	r3, r3, #8
20004d16:	6053      	strmi	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR))
20004d18:	4b21      	ldr	r3, [pc, #132]	; (20004da0 <FLASH_SetErrorCode+0xcc>)
20004d1a:	691a      	ldr	r2, [r3, #16]
20004d1c:	0652      	lsls	r2, r2, #25
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_SIZ;
20004d1e:	bf41      	itttt	mi
20004d20:	4920      	ldrmi	r1, [pc, #128]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d22:	684a      	ldrmi	r2, [r1, #4]
20004d24:	f042 0210 	orrmi.w	r2, r2, #16
20004d28:	604a      	strmi	r2, [r1, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))
20004d2a:	691b      	ldr	r3, [r3, #16]
20004d2c:	061b      	lsls	r3, r3, #24
  { 
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
20004d2e:	bf41      	itttt	mi
20004d30:	4a1c      	ldrmi	r2, [pc, #112]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d32:	6853      	ldrmi	r3, [r2, #4]
20004d34:	f043 0320 	orrmi.w	r3, r3, #32
20004d38:	6053      	strmi	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR))
20004d3a:	4b19      	ldr	r3, [pc, #100]	; (20004da0 <FLASH_SetErrorCode+0xcc>)
20004d3c:	691a      	ldr	r2, [r3, #16]
20004d3e:	05d0      	lsls	r0, r2, #23
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_MIS;
20004d40:	bf41      	itttt	mi
20004d42:	4918      	ldrmi	r1, [pc, #96]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d44:	684a      	ldrmi	r2, [r1, #4]
20004d46:	f042 0240 	orrmi.w	r2, r2, #64	; 0x40
20004d4a:	604a      	strmi	r2, [r1, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR))
20004d4c:	691b      	ldr	r3, [r3, #16]
20004d4e:	0599      	lsls	r1, r3, #22
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_FAST;
20004d50:	bf41      	itttt	mi
20004d52:	4a14      	ldrmi	r2, [pc, #80]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d54:	6853      	ldrmi	r3, [r2, #4]
20004d56:	f043 0380 	orrmi.w	r3, r3, #128	; 0x80
20004d5a:	6053      	strmi	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))
20004d5c:	4b10      	ldr	r3, [pc, #64]	; (20004da0 <FLASH_SetErrorCode+0xcc>)
20004d5e:	691a      	ldr	r2, [r3, #16]
20004d60:	0452      	lsls	r2, r2, #17
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
20004d62:	bf41      	itttt	mi
20004d64:	490f      	ldrmi	r1, [pc, #60]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d66:	684a      	ldrmi	r2, [r1, #4]
20004d68:	f442 7280 	orrmi.w	r2, r2, #256	; 0x100
20004d6c:	604a      	strmi	r2, [r1, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
20004d6e:	691b      	ldr	r3, [r3, #16]
20004d70:	041b      	lsls	r3, r3, #16
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
20004d72:	bf41      	itttt	mi
20004d74:	4a0b      	ldrmi	r2, [pc, #44]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d76:	6853      	ldrmi	r3, [r2, #4]
20004d78:	f443 7300 	orrmi.w	r3, r3, #512	; 0x200
20004d7c:	6053      	strmi	r3, [r2, #4]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD))
20004d7e:	4b08      	ldr	r3, [pc, #32]	; (20004da0 <FLASH_SetErrorCode+0xcc>)
20004d80:	699a      	ldr	r2, [r3, #24]
20004d82:	2a00      	cmp	r2, #0
  { 
   pFlash.ErrorCode |= HAL_FLASH_ERROR_ECCD;
20004d84:	bfbf      	itttt	lt
20004d86:	4907      	ldrlt	r1, [pc, #28]	; (20004da4 <FLASH_SetErrorCode+0xd0>)
20004d88:	684a      	ldrlt	r2, [r1, #4]
20004d8a:	f442 6280 	orrlt.w	r2, r2, #1024	; 0x400
20004d8e:	604a      	strlt	r2, [r1, #4]
  }

  /* Clear error programming flags */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
20004d90:	699a      	ldr	r2, [r3, #24]
20004d92:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
20004d96:	619a      	str	r2, [r3, #24]
20004d98:	f24c 32fa 	movw	r2, #50170	; 0xc3fa
20004d9c:	611a      	str	r2, [r3, #16]
20004d9e:	4770      	bx	lr
20004da0:	40022000 	.word	0x40022000
20004da4:	20008b60 	.word	0x20008b60

20004da8 <FLASH_Program_Fast>:
  * @param  Address: specifies the address to be programmed.
  * @param  DataAddress: specifies the address where the data are stored.
  * @retval None
  */
static void FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress)
{
20004da8:	b5d0      	push	{r4, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(Address));

  /* Set FSTPG bit */
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
20004daa:	4c0a      	ldr	r4, [pc, #40]	; (20004dd4 <FLASH_Program_Fast+0x2c>)
20004dac:	6962      	ldr	r2, [r4, #20]
20004dae:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
  */
static void FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress)
{
  uint8_t row_index = 32;
  __IO uint64_t *dest_addr = (__IO uint64_t*)Address;
  __IO uint64_t *src_addr = (__IO uint64_t*)DataAddress;
20004db2:	460b      	mov	r3, r1

  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(Address));

  /* Set FSTPG bit */
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
20004db4:	6162      	str	r2, [r4, #20]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
20004db6:	b672      	cpsid	i
20004db8:	f501 7480 	add.w	r4, r1, #256	; 0x100
  __disable_irq();
  
  /* Program the 32 double word */
  do
  {
    *dest_addr++ = *src_addr++;
20004dbc:	e9d3 6700 	ldrd	r6, r7, [r3]
20004dc0:	1a42      	subs	r2, r0, r1
20004dc2:	441a      	add	r2, r3
20004dc4:	3308      	adds	r3, #8
  } while (--row_index != 0);
20004dc6:	42a3      	cmp	r3, r4
  __disable_irq();
  
  /* Program the 32 double word */
  do
  {
    *dest_addr++ = *src_addr++;
20004dc8:	e9c2 6700 	strd	r6, r7, [r2]
  } while (--row_index != 0);
20004dcc:	d1f6      	bne.n	20004dbc <FLASH_Program_Fast+0x14>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
20004dce:	b662      	cpsie	i
20004dd0:	bdd0      	pop	{r4, r6, r7, pc}
20004dd2:	bf00      	nop
20004dd4:	40022000 	.word	0x40022000

20004dd8 <HAL_FLASH_Unlock>:
  * @brief  Unlock the FLASH control register access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
20004dd8:	4b06      	ldr	r3, [pc, #24]	; (20004df4 <HAL_FLASH_Unlock+0x1c>)
20004dda:	695a      	ldr	r2, [r3, #20]
20004ddc:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
20004dde:	bfbf      	itttt	lt
20004de0:	4a05      	ldrlt	r2, [pc, #20]	; (20004df8 <HAL_FLASH_Unlock+0x20>)
20004de2:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
20004de4:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
  else
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
20004de8:	2000      	movlt	r0, #0
{
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
20004dea:	bfb4      	ite	lt
20004dec:	609a      	strlt	r2, [r3, #8]
  }
  else
  {
    return HAL_ERROR;
20004dee:	2001      	movge	r0, #1
  }
  
  return HAL_OK;
}
20004df0:	4770      	bx	lr
20004df2:	bf00      	nop
20004df4:	40022000 	.word	0x40022000
20004df8:	45670123 	.word	0x45670123

20004dfc <HAL_FLASH_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
20004dfc:	4a03      	ldr	r2, [pc, #12]	; (20004e0c <HAL_FLASH_Lock+0x10>)
20004dfe:	6953      	ldr	r3, [r2, #20]
20004e00:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
20004e04:	6153      	str	r3, [r2, #20]
  
  return HAL_OK;  
}
20004e06:	2000      	movs	r0, #0
20004e08:	4770      	bx	lr
20004e0a:	bf00      	nop
20004e0c:	40022000 	.word	0x40022000

20004e10 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout: maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
20004e10:	b538      	push	{r3, r4, r5, lr}
20004e12:	4604      	mov	r4, r0
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
    
  uint32_t timeout = HAL_GetTick() + Timeout;
20004e14:	f7fe fd1c 	bl	20003850 <HAL_GetTick>
20004e18:	1905      	adds	r5, r0, r4
     
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
20004e1a:	4b1e      	ldr	r3, [pc, #120]	; (20004e94 <FLASH_WaitForLastOperation+0x84>)
20004e1c:	691a      	ldr	r2, [r3, #16]
20004e1e:	03d2      	lsls	r2, r2, #15
20004e20:	d507      	bpl.n	20004e32 <FLASH_WaitForLastOperation+0x22>
  { 
    if(Timeout != HAL_MAX_DELAY)
20004e22:	1c61      	adds	r1, r4, #1
20004e24:	d0f9      	beq.n	20004e1a <FLASH_WaitForLastOperation+0xa>
    {
      if(HAL_GetTick() >= timeout)
20004e26:	f7fe fd13 	bl	20003850 <HAL_GetTick>
20004e2a:	42a8      	cmp	r0, r5
20004e2c:	d3f5      	bcc.n	20004e1a <FLASH_WaitForLastOperation+0xa>
      {
        return HAL_TIMEOUT;
20004e2e:	2003      	movs	r0, #3
20004e30:	bd38      	pop	{r3, r4, r5, pc}
      }
    } 
  }
  
  if((__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR)) || 
20004e32:	691a      	ldr	r2, [r3, #16]
20004e34:	0790      	lsls	r0, r2, #30
20004e36:	d41f      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
20004e38:	691a      	ldr	r2, [r3, #16]
20004e3a:	0711      	lsls	r1, r2, #28
20004e3c:	d41c      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
20004e3e:	691a      	ldr	r2, [r3, #16]
        return HAL_TIMEOUT;
      }
    } 
  }
  
  if((__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR)) || 
20004e40:	06d2      	lsls	r2, r2, #27
20004e42:	d419      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
20004e44:	691a      	ldr	r2, [r3, #16]
20004e46:	0695      	lsls	r5, r2, #26
20004e48:	d416      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))  ||
20004e4a:	691a      	ldr	r2, [r3, #16]
      }
    } 
  }
  
  if((__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR)) || 
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
20004e4c:	0654      	lsls	r4, r2, #25
20004e4e:	d413      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))  ||
20004e50:	691a      	ldr	r2, [r3, #16]
20004e52:	0610      	lsls	r0, r2, #24
20004e54:	d410      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR)) || 
20004e56:	691a      	ldr	r2, [r3, #16]
    } 
  }
  
  if((__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR)) || 
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))  ||
20004e58:	05d1      	lsls	r1, r2, #23
20004e5a:	d40d      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR)) || 
20004e5c:	691a      	ldr	r2, [r3, #16]
20004e5e:	0592      	lsls	r2, r2, #22
20004e60:	d40a      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)) ||
20004e62:	691b      	ldr	r3, [r3, #16]
  }
  
  if((__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR)) || 
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))  ||
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR)) || 
20004e64:	045b      	lsls	r3, r3, #17
20004e66:	d407      	bmi.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)) ||
20004e68:	4a0a      	ldr	r2, [pc, #40]	; (20004e94 <FLASH_WaitForLastOperation+0x84>)
20004e6a:	6910      	ldr	r0, [r2, #16]
20004e6c:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
20004e70:	d102      	bne.n	20004e78 <FLASH_WaitForLastOperation+0x68>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD)))
20004e72:	6993      	ldr	r3, [r2, #24]
  
  if((__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PROGERR)) || 
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))  || 
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR))  ||
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_MISERR)) || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_FASTERR)) || 
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))  || (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)) ||
20004e74:	2b00      	cmp	r3, #0
20004e76:	da03      	bge.n	20004e80 <FLASH_WaitForLastOperation+0x70>
     (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD)))
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
20004e78:	f7ff ff2c 	bl	20004cd4 <FLASH_SetErrorCode>
    
    return HAL_ERROR;
20004e7c:	2001      	movs	r0, #1
20004e7e:	bd38      	pop	{r3, r4, r5, pc}
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
20004e80:	6913      	ldr	r3, [r2, #16]
20004e82:	f013 0301 	ands.w	r3, r3, #1
20004e86:	d002      	beq.n	20004e8e <FLASH_WaitForLastOperation+0x7e>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20004e88:	2301      	movs	r3, #1
20004e8a:	6113      	str	r3, [r2, #16]
20004e8c:	bd38      	pop	{r3, r4, r5, pc}
  }
  
  /* If there is an error flag set */
  return HAL_OK;  
20004e8e:	4618      	mov	r0, r3
}
20004e90:	bd38      	pop	{r3, r4, r5, pc}
20004e92:	bf00      	nop
20004e94:	40022000 	.word	0x40022000

20004e98 <HAL_FLASH_Program>:
  *                are stored the data for the row fast program
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
20004e98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t prog_bit = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004e9c:	4d1c      	ldr	r5, [pc, #112]	; (20004f10 <HAL_FLASH_Program+0x78>)
  *                are stored the data for the row fast program
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
20004e9e:	4699      	mov	r9, r3
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t prog_bit = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004ea0:	782b      	ldrb	r3, [r5, #0]
20004ea2:	2b01      	cmp	r3, #1
  *                are stored the data for the row fast program
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
20004ea4:	4606      	mov	r6, r0
20004ea6:	460f      	mov	r7, r1
20004ea8:	4690      	mov	r8, r2
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t prog_bit = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004eaa:	d02d      	beq.n	20004f08 <HAL_FLASH_Program+0x70>
20004eac:	2401      	movs	r4, #1

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004eae:	f24c 3050 	movw	r0, #50000	; 0xc350
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t prog_bit = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004eb2:	702c      	strb	r4, [r5, #0]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004eb4:	f7ff ffac 	bl	20004e10 <FLASH_WaitForLastOperation>
20004eb8:	4603      	mov	r3, r0
  
  if(status == HAL_OK)
20004eba:	bb0b      	cbnz	r3, 20004f00 <HAL_FLASH_Program+0x68>
  {
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
20004ebc:	606b      	str	r3, [r5, #4]

    if(TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
20004ebe:	b946      	cbnz	r6, 20004ed2 <HAL_FLASH_Program+0x3a>
{
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Set PG bit */
  SET_BIT(FLASH->CR, FLASH_CR_PG);
20004ec0:	4a14      	ldr	r2, [pc, #80]	; (20004f14 <HAL_FLASH_Program+0x7c>)
20004ec2:	6950      	ldr	r0, [r2, #20]
20004ec4:	4320      	orrs	r0, r4
20004ec6:	6150      	str	r0, [r2, #20]
  
  /* Program the double word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
20004ec8:	f8c7 8000 	str.w	r8, [r7]
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
20004ecc:	f8c7 9004 	str.w	r9, [r7, #4]
20004ed0:	e00c      	b.n	20004eec <HAL_FLASH_Program+0x54>
    {
      /* Program double-word (64-bit) at a specified address */
      FLASH_Program_DoubleWord(Address, Data);
      prog_bit = FLASH_CR_PG;
    }
    else if((TypeProgram == FLASH_TYPEPROGRAM_FAST) || (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST))
20004ed2:	1e73      	subs	r3, r6, #1
20004ed4:	2b01      	cmp	r3, #1
20004ed6:	d901      	bls.n	20004edc <HAL_FLASH_Program+0x44>
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t prog_bit = 0;
20004ed8:	2400      	movs	r4, #0
20004eda:	e007      	b.n	20004eec <HAL_FLASH_Program+0x54>
      prog_bit = FLASH_CR_PG;
    }
    else if((TypeProgram == FLASH_TYPEPROGRAM_FAST) || (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST))
    {
      /* Fast program a 32 row double-word (64-bit) at a specified address */
      FLASH_Program_Fast(Address, (uint32_t)Data);
20004edc:	4638      	mov	r0, r7
20004ede:	4641      	mov	r1, r8
20004ee0:	f7ff ff62 	bl	20004da8 <FLASH_Program_Fast>
      
      /* If it is the last row, the bit will be cleared at the end of the operation */
      if(TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST)
20004ee4:	2e02      	cmp	r6, #2
20004ee6:	d1f7      	bne.n	20004ed8 <HAL_FLASH_Program+0x40>
      {
        prog_bit = FLASH_CR_FSTPG;
20004ee8:	f44f 2480 	mov.w	r4, #262144	; 0x40000
      }
    }

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004eec:	f24c 3050 	movw	r0, #50000	; 0xc350
20004ef0:	f7ff ff8e 	bl	20004e10 <FLASH_WaitForLastOperation>
    
    /* If the program operation is completed, disable the PG or FSTPG Bit */
    if (prog_bit != 0)
20004ef4:	b124      	cbz	r4, 20004f00 <HAL_FLASH_Program+0x68>
    {
      CLEAR_BIT(FLASH->CR, prog_bit);
20004ef6:	4a07      	ldr	r2, [pc, #28]	; (20004f14 <HAL_FLASH_Program+0x7c>)
20004ef8:	6953      	ldr	r3, [r2, #20]
20004efa:	ea23 0404 	bic.w	r4, r3, r4
20004efe:	6154      	str	r4, [r2, #20]
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
20004f00:	2300      	movs	r3, #0
20004f02:	702b      	strb	r3, [r5, #0]

  return status;  
20004f04:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t prog_bit = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004f08:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);

  return status;  
}
20004f0a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
20004f0e:	bf00      	nop
20004f10:	20008b60 	.word	0x20008b60
20004f14:	40022000 	.word	0x40022000

20004f18 <FLASH_MassErase>:
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
20004f18:	4b09      	ldr	r3, [pc, #36]	; (20004f40 <FLASH_MassErase+0x28>)
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));

  /* Set the Mass Erase Bit for the bank 1 if requested */
  if((Banks & FLASH_BANK_1) != RESET)
20004f1a:	f010 0f01 	tst.w	r0, #1
  {
    SET_BIT(FLASH->CR, FLASH_CR_MER1);
20004f1e:	bf1e      	ittt	ne
20004f20:	695a      	ldrne	r2, [r3, #20]
20004f22:	f042 0204 	orrne.w	r2, r2, #4
20004f26:	615a      	strne	r2, [r3, #20]
  }
  
  /* Set the Mass Erase Bit for the bank 2 if requested */
  if((Banks & FLASH_BANK_2) != RESET)
20004f28:	0782      	lsls	r2, r0, #30
  {
    SET_BIT(FLASH->CR, FLASH_CR_MER2);
20004f2a:	bf42      	ittt	mi
20004f2c:	695a      	ldrmi	r2, [r3, #20]
20004f2e:	f442 4200 	orrmi.w	r2, r2, #32768	; 0x8000
20004f32:	615a      	strmi	r2, [r3, #20]
  }

  /* Proceed to erase all sectors */
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
20004f34:	695a      	ldr	r2, [r3, #20]
20004f36:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20004f3a:	615a      	str	r2, [r3, #20]
20004f3c:	4770      	bx	lr
20004f3e:	bf00      	nop
20004f40:	40022000 	.word	0x40022000

20004f44 <FLASH_PageErase>:
  *            @arg FLASH_BANK_1: Page in bank 1 to be erased
  *            @arg FLASH_BANK_2: Page in bank 2 to be erased
  * @retval None
  */
void FLASH_PageErase(uint32_t Page, uint32_t Banks)
{
20004f44:	4b0c      	ldr	r3, [pc, #48]	; (20004f78 <FLASH_PageErase+0x34>)
  assert_param(IS_FLASH_PAGE(Page));
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

  if((Banks & FLASH_BANK_1) != RESET)
  {
    CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
20004f46:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_FLASH_PAGE(Page));
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

  if((Banks & FLASH_BANK_1) != RESET)
20004f48:	f011 0f01 	tst.w	r1, #1
  {
    CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
20004f4c:	bf14      	ite	ne
20004f4e:	f422 6200 	bicne.w	r2, r2, #2048	; 0x800
  }
  else
  {
    SET_BIT(FLASH->CR, FLASH_CR_BKER);
20004f52:	f442 6200 	orreq.w	r2, r2, #2048	; 0x800
20004f56:	615a      	str	r2, [r3, #20]
  }

  /* Proceed to erase the page */
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, (Page << 3));
20004f58:	695a      	ldr	r2, [r3, #20]
20004f5a:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
20004f5e:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
20004f62:	6158      	str	r0, [r3, #20]
  SET_BIT(FLASH->CR, FLASH_CR_PER);
20004f64:	695a      	ldr	r2, [r3, #20]
20004f66:	f042 0202 	orr.w	r2, r2, #2
20004f6a:	615a      	str	r2, [r3, #20]
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
20004f6c:	695a      	ldr	r2, [r3, #20]
20004f6e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20004f72:	615a      	str	r2, [r3, #20]
20004f74:	4770      	bx	lr
20004f76:	bf00      	nop
20004f78:	40022000 	.word	0x40022000

20004f7c <FLASH_FlushCaches>:
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != RESET)
20004f7c:	4b10      	ldr	r3, [pc, #64]	; (20004fc0 <FLASH_FlushCaches+0x44>)
20004f7e:	681a      	ldr	r2, [r3, #0]
20004f80:	0591      	lsls	r1, r2, #22
20004f82:	d50b      	bpl.n	20004f9c <FLASH_FlushCaches+0x20>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
20004f84:	681a      	ldr	r2, [r3, #0]
20004f86:	f422 7200 	bic.w	r2, r2, #512	; 0x200
20004f8a:	601a      	str	r2, [r3, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
20004f8c:	681a      	ldr	r2, [r3, #0]
20004f8e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
20004f92:	601a      	str	r2, [r3, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
20004f94:	681a      	ldr	r2, [r3, #0]
20004f96:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20004f9a:	601a      	str	r2, [r3, #0]
  }
  
  /* Flush data cache */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
20004f9c:	4b08      	ldr	r3, [pc, #32]	; (20004fc0 <FLASH_FlushCaches+0x44>)
20004f9e:	681a      	ldr	r2, [r3, #0]
20004fa0:	0552      	lsls	r2, r2, #21
20004fa2:	d50b      	bpl.n	20004fbc <FLASH_FlushCaches+0x40>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
20004fa4:	681a      	ldr	r2, [r3, #0]
20004fa6:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
20004faa:	601a      	str	r2, [r3, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
20004fac:	681a      	ldr	r2, [r3, #0]
20004fae:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
20004fb2:	601a      	str	r2, [r3, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
20004fb4:	681a      	ldr	r2, [r3, #0]
20004fb6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20004fba:	601a      	str	r2, [r3, #0]
20004fbc:	4770      	bx	lr
20004fbe:	bf00      	nop
20004fc0:	40022000 	.word	0x40022000

20004fc4 <HAL_FLASHEx_Erase>:
  *         the pages have been correctly erased)
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
20004fc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t page_index = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004fc8:	4d26      	ldr	r5, [pc, #152]	; (20005064 <HAL_FLASHEx_Erase+0xa0>)
20004fca:	782b      	ldrb	r3, [r5, #0]
20004fcc:	2b01      	cmp	r3, #1
  *         the pages have been correctly erased)
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
20004fce:	4606      	mov	r6, r0
20004fd0:	4688      	mov	r8, r1
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t page_index = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004fd2:	d043      	beq.n	2000505c <HAL_FLASHEx_Erase+0x98>
20004fd4:	2301      	movs	r3, #1

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004fd6:	f24c 3050 	movw	r0, #50000	; 0xc350
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t page_index = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004fda:	702b      	strb	r3, [r5, #0]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004fdc:	f7ff ff18 	bl	20004e10 <FLASH_WaitForLastOperation>

  if (status == HAL_OK)
20004fe0:	4604      	mov	r4, r0
20004fe2:	2800      	cmp	r0, #0
20004fe4:	d135      	bne.n	20005052 <HAL_FLASHEx_Erase+0x8e>
  {
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;

    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
20004fe6:	6833      	ldr	r3, [r6, #0]
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);

  if (status == HAL_OK)
  {
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
20004fe8:	6068      	str	r0, [r5, #4]

    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
20004fea:	2b01      	cmp	r3, #1
20004fec:	d10f      	bne.n	2000500e <HAL_FLASHEx_Erase+0x4a>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->Banks);
20004fee:	6870      	ldr	r0, [r6, #4]
20004ff0:	f7ff ff92 	bl	20004f18 <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004ff4:	f24c 3050 	movw	r0, #50000	; 0xc350
20004ff8:	f7ff ff0a 	bl	20004e10 <FLASH_WaitForLastOperation>

      /* If the erase operation is completed, disable the MER1 and MER2 Bits */
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
20004ffc:	4a1a      	ldr	r2, [pc, #104]	; (20005068 <HAL_FLASHEx_Erase+0xa4>)
20004ffe:	6953      	ldr	r3, [r2, #20]
20005000:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
20005004:	f023 0304 	bic.w	r3, r3, #4
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->Banks);

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20005008:	4604      	mov	r4, r0

      /* If the erase operation is completed, disable the MER1 and MER2 Bits */
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
2000500a:	6153      	str	r3, [r2, #20]
2000500c:	e01f      	b.n	2000504e <HAL_FLASHEx_Erase+0x8a>
    }
    else
    {
      /*Initialization of PageError variable*/
      *PageError = 0xFFFFFFFF;
2000500e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
20005012:	f8c8 3000 	str.w	r3, [r8]
      
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
20005016:	68b7      	ldr	r7, [r6, #8]
20005018:	68f2      	ldr	r2, [r6, #12]
2000501a:	68b3      	ldr	r3, [r6, #8]
2000501c:	4413      	add	r3, r2
2000501e:	429f      	cmp	r7, r3
20005020:	d215      	bcs.n	2000504e <HAL_FLASHEx_Erase+0x8a>
      {
        FLASH_PageErase(page_index, pEraseInit->Banks);
20005022:	4638      	mov	r0, r7
20005024:	6871      	ldr	r1, [r6, #4]
20005026:	f7ff ff8d 	bl	20004f44 <FLASH_PageErase>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
2000502a:	f24c 3050 	movw	r0, #50000	; 0xc350
2000502e:	f7ff feef 	bl	20004e10 <FLASH_WaitForLastOperation>

        /* If the erase operation is completed, disable the PER Bit */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
20005032:	4a0d      	ldr	r2, [pc, #52]	; (20005068 <HAL_FLASHEx_Erase+0xa4>)
20005034:	6953      	ldr	r3, [r2, #20]
20005036:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
2000503a:	f023 0302 	bic.w	r3, r3, #2
2000503e:	6153      	str	r3, [r2, #20]

        if (status != HAL_OK)
20005040:	b118      	cbz	r0, 2000504a <HAL_FLASHEx_Erase+0x86>
        {
          /* In case of error, stop erase procedure and return the faulty address */
          *PageError = page_index;
20005042:	f8c8 7000 	str.w	r7, [r8]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
      {
        FLASH_PageErase(page_index, pEraseInit->Banks);

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20005046:	4604      	mov	r4, r0

        if (status != HAL_OK)
        {
          /* In case of error, stop erase procedure and return the faulty address */
          *PageError = page_index;
          break;
20005048:	e001      	b.n	2000504e <HAL_FLASHEx_Erase+0x8a>
    else
    {
      /*Initialization of PageError variable*/
      *PageError = 0xFFFFFFFF;
      
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
2000504a:	3701      	adds	r7, #1
2000504c:	e7e4      	b.n	20005018 <HAL_FLASHEx_Erase+0x54>
        }
      }
    }
    
    /* Flush the caches to be sure of the data consistency */
    FLASH_FlushCaches();
2000504e:	f7ff ff95 	bl	20004f7c <FLASH_FlushCaches>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
20005052:	2300      	movs	r3, #0
20005054:	702b      	strb	r3, [r5, #0]

  return status;
20005056:	4620      	mov	r0, r4
20005058:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t page_index = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
2000505c:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);

  return status;
}
2000505e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20005062:	bf00      	nop
20005064:	20008b60 	.word	0x20008b60
20005068:	40022000 	.word	0x40022000

2000506c <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR1 & PWR_CR1_VOS);
2000506c:	4b02      	ldr	r3, [pc, #8]	; (20005078 <HAL_PWREx_GetVoltageRange+0xc>)
2000506e:	6818      	ldr	r0, [r3, #0]
}
20005070:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
20005074:	4770      	bx	lr
20005076:	bf00      	nop
20005078:	40007000 	.word	0x40007000

2000507c <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present. 
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
2000507c:	4a02      	ldr	r2, [pc, #8]	; (20005088 <HAL_PWREx_EnableVddIO2+0xc>)
2000507e:	6853      	ldr	r3, [r2, #4]
20005080:	f443 7300 	orr.w	r3, r3, #512	; 0x200
20005084:	6053      	str	r3, [r2, #4]
20005086:	4770      	bx	lr
20005088:	40007000 	.word	0x40007000

2000508c <dbgputc>:
    /*
     * Call the chip-specific code to write the char to the debug serial UART
     * FIXME: replace with chip delay function, current chip delay function fails
     *        with unresponsive systick counter.
    */
    MOD_DEBUG_USART->TDR = x;
2000508c:	b280      	uxth	r0, r0
2000508e:	4b03      	ldr	r3, [pc, #12]	; (2000509c <dbgputc+0x10>)
20005090:	8518      	strh	r0, [r3, #40]	; 0x28
20005092:	f640 437f 	movw	r3, #3199	; 0xc7f
    while (count < 3200) {
20005096:	3b01      	subs	r3, #1
20005098:	d1fd      	bne.n	20005096 <dbgputc+0xa>
        y = 1000/count + 1;
        count ++;
        x = y;
    }
}
2000509a:	4770      	bx	lr
2000509c:	40004800 	.word	0x40004800

200050a0 <dbgprint>:
 *
 * @param str The string to display (safe with NULL pointer)
 *
 * @returns Nothing
 */
void dbgprint(const char *str) {
200050a0:	b510      	push	{r4, lr}
    if (str != NULL) {
200050a2:	b130      	cbz	r0, 200050b2 <dbgprint+0x12>
200050a4:	1e44      	subs	r4, r0, #1
        while (*str != 0) {
200050a6:	f814 0f01 	ldrb.w	r0, [r4, #1]!
200050aa:	b110      	cbz	r0, 200050b2 <dbgprint+0x12>
            dbgputc(*str);
200050ac:	f7ff ffee 	bl	2000508c <dbgputc>
200050b0:	e7f9      	b.n	200050a6 <dbgprint+0x6>
200050b2:	bd10      	pop	{r4, pc}

200050b4 <dbgprinthex8>:
 *
 * @param num The number to display
 *
 * @returns Nothing
 */
void dbgprinthex8(uint8_t num) {
200050b4:	b510      	push	{r4, lr}
200050b6:	4604      	mov	r4, r0
    int digit;
    int nybble;

    for (digit = 1; digit >= 0; digit--) {
        nybble = (num >> (digit << 2)) & 0x0f;
200050b8:	1100      	asrs	r0, r0, #4
        if (nybble < 10) {
200050ba:	2809      	cmp	r0, #9
            dbgputc('0' + nybble);
        } else {
            dbgputc('a' + (nybble - 10));
200050bc:	bfcc      	ite	gt
200050be:	3057      	addgt	r0, #87	; 0x57
    int nybble;

    for (digit = 1; digit >= 0; digit--) {
        nybble = (num >> (digit << 2)) & 0x0f;
        if (nybble < 10) {
            dbgputc('0' + nybble);
200050c0:	3030      	addle	r0, #48	; 0x30
200050c2:	f7ff ffe3 	bl	2000508c <dbgputc>
void dbgprinthex8(uint8_t num) {
    int digit;
    int nybble;

    for (digit = 1; digit >= 0; digit--) {
        nybble = (num >> (digit << 2)) & 0x0f;
200050c6:	f004 000f 	and.w	r0, r4, #15
        if (nybble < 10) {
200050ca:	2809      	cmp	r0, #9
200050cc:	d904      	bls.n	200050d8 <dbgprinthex8+0x24>
            dbgputc('0' + nybble);
        } else {
            dbgputc('a' + (nybble - 10));
200050ce:	3057      	adds	r0, #87	; 0x57
        }
    }
}
200050d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    for (digit = 1; digit >= 0; digit--) {
        nybble = (num >> (digit << 2)) & 0x0f;
        if (nybble < 10) {
            dbgputc('0' + nybble);
        } else {
            dbgputc('a' + (nybble - 10));
200050d4:	f7ff bfda 	b.w	2000508c <dbgputc>
    int nybble;

    for (digit = 1; digit >= 0; digit--) {
        nybble = (num >> (digit << 2)) & 0x0f;
        if (nybble < 10) {
            dbgputc('0' + nybble);
200050d8:	3030      	adds	r0, #48	; 0x30
        } else {
            dbgputc('a' + (nybble - 10));
        }
    }
}
200050da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    int nybble;

    for (digit = 1; digit >= 0; digit--) {
        nybble = (num >> (digit << 2)) & 0x0f;
        if (nybble < 10) {
            dbgputc('0' + nybble);
200050de:	f7ff bfd5 	b.w	2000508c <dbgputc>

200050e2 <dbgprinthex32>:
 *
 * @param num The number to display
 *
 * @returns Nothing
 */
void dbgprinthex32(uint32_t num) {
200050e2:	b510      	push	{r4, lr}
200050e4:	4604      	mov	r4, r0
    int byte;
    uint8_t byte_value;

    for (byte = 3; byte >= 0; byte--) {
        byte_value = (num >> (byte << 3)) & 0x0ff;
        dbgprinthex8(byte_value);
200050e6:	0e00      	lsrs	r0, r0, #24
200050e8:	f7ff ffe4 	bl	200050b4 <dbgprinthex8>
200050ec:	f3c4 4007 	ubfx	r0, r4, #16, #8
200050f0:	f7ff ffe0 	bl	200050b4 <dbgprinthex8>
200050f4:	f3c4 2007 	ubfx	r0, r4, #8, #8
200050f8:	f7ff ffdc 	bl	200050b4 <dbgprinthex8>
200050fc:	b2e0      	uxtb	r0, r4
    }
}
200050fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    int byte;
    uint8_t byte_value;

    for (byte = 3; byte >= 0; byte--) {
        byte_value = (num >> (byte << 3)) & 0x0ff;
        dbgprinthex8(byte_value);
20005102:	f7ff bfd7 	b.w	200050b4 <dbgprinthex8>

20005106 <dbgprintx32>:
 * @param num The number to display
 * @param s2 The optional string to issue after the number.
 *
 * @returns Nothing
 */
void dbgprintx32(const char * s1, uint32_t num, const char * s2) {
20005106:	b538      	push	{r3, r4, r5, lr}
20005108:	460d      	mov	r5, r1
2000510a:	4614      	mov	r4, r2
    dbgprint(s1);
2000510c:	f7ff ffc8 	bl	200050a0 <dbgprint>
    dbgprinthex32(num);
20005110:	4628      	mov	r0, r5
20005112:	f7ff ffe6 	bl	200050e2 <dbgprinthex32>
    dbgprint(s2);
20005116:	4620      	mov	r0, r4
}
20005118:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 * @returns Nothing
 */
void dbgprintx32(const char * s1, uint32_t num, const char * s2) {
    dbgprint(s1);
    dbgprinthex32(num);
    dbgprint(s2);
2000511c:	f7ff bfc0 	b.w	200050a0 <dbgprint>

20005120 <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart: UART handle.
  * @retval None
  */
 __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
20005120:	4770      	bx	lr
	...

20005124 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
20005124:	b538      	push	{r3, r4, r5, lr}
20005126:	4604      	mov	r4, r0
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
20005128:	6805      	ldr	r5, [r0, #0]
   *  the UART Word Length, Parity, Mode and oversampling:
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2000512a:	68a2      	ldr	r2, [r4, #8]
2000512c:	6921      	ldr	r1, [r4, #16]
2000512e:	69c3      	ldr	r3, [r0, #28]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
20005130:	6828      	ldr	r0, [r5, #0]
   *  the UART Word Length, Parity, Mode and oversampling:
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
20005132:	4311      	orrs	r1, r2
20005134:	6962      	ldr	r2, [r4, #20]
20005136:	430a      	orrs	r2, r1
20005138:	ea42 0103 	orr.w	r1, r2, r3
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
2000513c:	4a9a      	ldr	r2, [pc, #616]	; (200053a8 <UART_SetConfig+0x284>)
2000513e:	4002      	ands	r2, r0
20005140:	430a      	orrs	r2, r1
20005142:	602a      	str	r2, [r5, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
20005144:	686a      	ldr	r2, [r5, #4]
20005146:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
2000514a:	68e2      	ldr	r2, [r4, #12]
2000514c:	430a      	orrs	r2, r1
2000514e:	606a      	str	r2, [r5, #4]
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
  if (!(UART_INSTANCE_LOWPOWER(huart)))
20005150:	4a96      	ldr	r2, [pc, #600]	; (200053ac <UART_SetConfig+0x288>)
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
20005152:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
20005154:	4295      	cmp	r5, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
20005156:	bf1c      	itt	ne
20005158:	6a22      	ldrne	r2, [r4, #32]
2000515a:	4311      	orrne	r1, r2
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
2000515c:	68aa      	ldr	r2, [r5, #8]
2000515e:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
20005162:	430a      	orrs	r2, r1
20005164:	60aa      	str	r2, [r5, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
20005166:	4a92      	ldr	r2, [pc, #584]	; (200053b0 <UART_SetConfig+0x28c>)
20005168:	4295      	cmp	r5, r2
2000516a:	d107      	bne.n	2000517c <UART_SetConfig+0x58>
2000516c:	f502 4258 	add.w	r2, r2, #55296	; 0xd800
20005170:	4990      	ldr	r1, [pc, #576]	; (200053b4 <UART_SetConfig+0x290>)
20005172:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
20005176:	f002 0203 	and.w	r2, r2, #3
2000517a:	e009      	b.n	20005190 <UART_SetConfig+0x6c>
2000517c:	4a8e      	ldr	r2, [pc, #568]	; (200053b8 <UART_SetConfig+0x294>)
2000517e:	4295      	cmp	r5, r2
20005180:	d10c      	bne.n	2000519c <UART_SetConfig+0x78>
20005182:	f502 32e6 	add.w	r2, r2, #117760	; 0x1cc00
20005186:	498d      	ldr	r1, [pc, #564]	; (200053bc <UART_SetConfig+0x298>)
20005188:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
2000518c:	f002 020c 	and.w	r2, r2, #12
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
20005190:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20005194:	5c8a      	ldrb	r2, [r1, r2]
20005196:	f040 8092 	bne.w	200052be <UART_SetConfig+0x19a>
2000519a:	e053      	b.n	20005244 <UART_SetConfig+0x120>
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
2000519c:	4a88      	ldr	r2, [pc, #544]	; (200053c0 <UART_SetConfig+0x29c>)
2000519e:	4295      	cmp	r5, r2
200051a0:	d110      	bne.n	200051c4 <UART_SetConfig+0xa0>
200051a2:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
200051a6:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
200051aa:	f002 0230 	and.w	r2, r2, #48	; 0x30
200051ae:	2a10      	cmp	r2, #16
200051b0:	d060      	beq.n	20005274 <UART_SetConfig+0x150>
200051b2:	d802      	bhi.n	200051ba <UART_SetConfig+0x96>
200051b4:	2a00      	cmp	r2, #0
200051b6:	d04e      	beq.n	20005256 <UART_SetConfig+0x132>
200051b8:	e074      	b.n	200052a4 <UART_SetConfig+0x180>
200051ba:	2a20      	cmp	r2, #32
200051bc:	d054      	beq.n	20005268 <UART_SetConfig+0x144>
200051be:	2a30      	cmp	r2, #48	; 0x30
200051c0:	d062      	beq.n	20005288 <UART_SetConfig+0x164>
200051c2:	e06f      	b.n	200052a4 <UART_SetConfig+0x180>
200051c4:	4a7f      	ldr	r2, [pc, #508]	; (200053c4 <UART_SetConfig+0x2a0>)
200051c6:	4295      	cmp	r5, r2
200051c8:	d10e      	bne.n	200051e8 <UART_SetConfig+0xc4>
200051ca:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
200051ce:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
200051d2:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
200051d6:	2a40      	cmp	r2, #64	; 0x40
200051d8:	f000 809d 	beq.w	20005316 <UART_SetConfig+0x1f2>
200051dc:	d926      	bls.n	2000522c <UART_SetConfig+0x108>
200051de:	2a80      	cmp	r2, #128	; 0x80
200051e0:	f000 80d8 	beq.w	20005394 <UART_SetConfig+0x270>
200051e4:	2ac0      	cmp	r2, #192	; 0xc0
200051e6:	e02a      	b.n	2000523e <UART_SetConfig+0x11a>
200051e8:	4a77      	ldr	r2, [pc, #476]	; (200053c8 <UART_SetConfig+0x2a4>)
200051ea:	4295      	cmp	r5, r2
200051ec:	d111      	bne.n	20005212 <UART_SetConfig+0xee>
200051ee:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
200051f2:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
200051f6:	f402 7240 	and.w	r2, r2, #768	; 0x300
200051fa:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
200051fe:	f000 808a 	beq.w	20005316 <UART_SetConfig+0x1f2>
20005202:	d913      	bls.n	2000522c <UART_SetConfig+0x108>
20005204:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
20005208:	f000 80c4 	beq.w	20005394 <UART_SetConfig+0x270>
2000520c:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
20005210:	e015      	b.n	2000523e <UART_SetConfig+0x11a>
20005212:	4a66      	ldr	r2, [pc, #408]	; (200053ac <UART_SetConfig+0x288>)
20005214:	4295      	cmp	r5, r2
20005216:	d145      	bne.n	200052a4 <UART_SetConfig+0x180>
20005218:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
2000521c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
20005220:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
20005224:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
20005228:	d075      	beq.n	20005316 <UART_SetConfig+0x1f2>
2000522a:	d802      	bhi.n	20005232 <UART_SetConfig+0x10e>
2000522c:	2a00      	cmp	r2, #0
2000522e:	d06b      	beq.n	20005308 <UART_SetConfig+0x1e4>
20005230:	e035      	b.n	2000529e <UART_SetConfig+0x17a>
20005232:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
20005236:	f000 80ad 	beq.w	20005394 <UART_SetConfig+0x270>
2000523a:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
2000523e:	f000 80a1 	beq.w	20005384 <UART_SetConfig+0x260>
20005242:	e02c      	b.n	2000529e <UART_SetConfig+0x17a>
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  {
    switch (clocksource)
20005244:	2a08      	cmp	r2, #8
20005246:	d830      	bhi.n	200052aa <UART_SetConfig+0x186>
20005248:	e8df f002 	tbb	[pc, r2]
2000524c:	2f110b08 	.word	0x2f110b08
20005250:	2f2f2f17 	.word	0x2f2f2f17
20005254:	21          	.byte	0x21
20005255:	00          	.byte	0x00
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
20005256:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000525a:	d139      	bne.n	200052d0 <UART_SetConfig+0x1ac>
  {
    switch (clocksource)
    {
    case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
2000525c:	f7fd fefa 	bl	20003054 <HAL_RCC_GetPCLK1Freq>
20005260:	e00d      	b.n	2000527e <UART_SetConfig+0x15a>
      break;
    case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
20005262:	f7fd ff0d 	bl	20003080 <HAL_RCC_GetPCLK2Freq>
20005266:	e00a      	b.n	2000527e <UART_SetConfig+0x15a>
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
20005268:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000526c:	d136      	bne.n	200052dc <UART_SetConfig+0x1b8>
      break;
    case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_HSI:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
2000526e:	6860      	ldr	r0, [r4, #4]
20005270:	4b56      	ldr	r3, [pc, #344]	; (200053cc <UART_SetConfig+0x2a8>)
20005272:	e00f      	b.n	20005294 <UART_SetConfig+0x170>
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
20005274:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20005278:	d136      	bne.n	200052e8 <UART_SetConfig+0x1c4>
      break;
    case UART_CLOCKSOURCE_HSI:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
2000527a:	f7fd fe69 	bl	20002f50 <HAL_RCC_GetSysClockFreq>
2000527e:	0040      	lsls	r0, r0, #1
20005280:	6863      	ldr	r3, [r4, #4]
20005282:	fbb0 f3f3 	udiv	r3, r0, r3
20005286:	e007      	b.n	20005298 <UART_SetConfig+0x174>
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
20005288:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000528c:	d134      	bne.n	200052f8 <UART_SetConfig+0x1d4>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
2000528e:	6860      	ldr	r0, [r4, #4]
20005290:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20005294:	fbb3 f3f0 	udiv	r3, r3, r0
20005298:	b29b      	uxth	r3, r3
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
  HAL_StatusTypeDef ret               = HAL_OK;
2000529a:	2200      	movs	r2, #0
    case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
      break;
2000529c:	e007      	b.n	200052ae <UART_SetConfig+0x18a>

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);

  /* Check LPUART instance */
  if(UART_INSTANCE_LOWPOWER(huart))
2000529e:	4a43      	ldr	r2, [pc, #268]	; (200053ac <UART_SetConfig+0x288>)
200052a0:	4295      	cmp	r5, r2
200052a2:	d07e      	beq.n	200053a2 <UART_SetConfig+0x27e>
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
200052a4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200052a8:	d17b      	bne.n	200053a2 <UART_SetConfig+0x27e>
    case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
      break;
      case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
200052aa:	2201      	movs	r2, #1
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
200052ac:	2300      	movs	r3, #0
    default:
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0;
200052ae:	f023 000f 	bic.w	r0, r3, #15
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
    huart->Instance->BRR = brrtemp;
200052b2:	6821      	ldr	r1, [r4, #0]
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0;
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
200052b4:	f3c3 0342 	ubfx	r3, r3, #1, #3
    huart->Instance->BRR = brrtemp;
200052b8:	4303      	orrs	r3, r0
200052ba:	60cb      	str	r3, [r1, #12]
200052bc:	e072      	b.n	200053a4 <UART_SetConfig+0x280>
  }
  else
  {
    switch (clocksource)
200052be:	2a08      	cmp	r2, #8
200052c0:	d86f      	bhi.n	200053a2 <UART_SetConfig+0x27e>
200052c2:	e8df f002 	tbb	[pc, r2]
200052c6:	0805      	.short	0x0805
200052c8:	6e116e0b 	.word	0x6e116e0b
200052cc:	6e6e      	.short	0x6e6e
200052ce:	19          	.byte	0x19
200052cf:	00          	.byte	0x00
    {
    case UART_CLOCKSOURCE_PCLK1:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
200052d0:	f7fd fec0 	bl	20003054 <HAL_RCC_GetPCLK1Freq>
200052d4:	e00a      	b.n	200052ec <UART_SetConfig+0x1c8>
      break;
    case UART_CLOCKSOURCE_PCLK2:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
200052d6:	f7fd fed3 	bl	20003080 <HAL_RCC_GetPCLK2Freq>
200052da:	e007      	b.n	200052ec <UART_SetConfig+0x1c8>
      break;
    case UART_CLOCKSOURCE_HSI:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
200052dc:	6862      	ldr	r2, [r4, #4]
200052de:	4b3c      	ldr	r3, [pc, #240]	; (200053d0 <UART_SetConfig+0x2ac>)
200052e0:	fbb3 f3f2 	udiv	r3, r3, r2
200052e4:	b29b      	uxth	r3, r3
200052e6:	e00c      	b.n	20005302 <UART_SetConfig+0x1de>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
200052e8:	f7fd fe32 	bl	20002f50 <HAL_RCC_GetSysClockFreq>
200052ec:	6863      	ldr	r3, [r4, #4]
200052ee:	fbb0 f0f3 	udiv	r0, r0, r3
200052f2:	b280      	uxth	r0, r0
200052f4:	60e8      	str	r0, [r5, #12]
200052f6:	e005      	b.n	20005304 <UART_SetConfig+0x1e0>
      break;
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
200052f8:	6862      	ldr	r2, [r4, #4]
200052fa:	f44f 4300 	mov.w	r3, #32768	; 0x8000
200052fe:	fbb3 f3f2 	udiv	r3, r3, r2
20005302:	60eb      	str	r3, [r5, #12]
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
  HAL_StatusTypeDef ret               = HAL_OK;
20005304:	2200      	movs	r2, #0
    case UART_CLOCKSOURCE_SYSCLK:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
      break;
20005306:	e04d      	b.n	200053a4 <UART_SetConfig+0x280>

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);

  /* Check LPUART instance */
  if(UART_INSTANCE_LOWPOWER(huart))
20005308:	4a28      	ldr	r2, [pc, #160]	; (200053ac <UART_SetConfig+0x288>)
2000530a:	4295      	cmp	r5, r2
2000530c:	d1a3      	bne.n	20005256 <UART_SetConfig+0x132>
    tmpreg = 0;

    switch (clocksource)
    {
    case UART_CLOCKSOURCE_PCLK1:
      tmpreg = HAL_RCC_GetPCLK1Freq();
2000530e:	f7fd fea1 	bl	20003054 <HAL_RCC_GetPCLK1Freq>
      break;
20005312:	2300      	movs	r3, #0
20005314:	e005      	b.n	20005322 <UART_SetConfig+0x1fe>

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);

  /* Check LPUART instance */
  if(UART_INSTANCE_LOWPOWER(huart))
20005316:	4a25      	ldr	r2, [pc, #148]	; (200053ac <UART_SetConfig+0x288>)
20005318:	4295      	cmp	r5, r2
2000531a:	d1ab      	bne.n	20005274 <UART_SetConfig+0x150>
      break;
    case UART_CLOCKSOURCE_HSI:
      tmpreg = (uint32_t) HSI_VALUE;
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      tmpreg = HAL_RCC_GetSysClockFreq();
2000531c:	f7fd fe18 	bl	20002f50 <HAL_RCC_GetSysClockFreq>
      break;
20005320:	2304      	movs	r3, #4
        ret = HAL_ERROR;
      break;
    }

    /* if proper clock source reported */
    if (tmpreg != 0)
20005322:	2800      	cmp	r0, #0
20005324:	d0ee      	beq.n	20005304 <UART_SetConfig+0x1e0>
    {
      /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ( (tmpreg < (3 * huart->Init.BaudRate) ) ||
20005326:	6862      	ldr	r2, [r4, #4]
20005328:	eb02 0142 	add.w	r1, r2, r2, lsl #1
2000532c:	4288      	cmp	r0, r1
2000532e:	d338      	bcc.n	200053a2 <UART_SetConfig+0x27e>
20005330:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
20005334:	d835      	bhi.n	200053a2 <UART_SetConfig+0x27e>
      {
        ret = HAL_ERROR;
      }
      else
      {
        switch (clocksource)
20005336:	2b08      	cmp	r3, #8
20005338:	d81b      	bhi.n	20005372 <UART_SetConfig+0x24e>
2000533a:	e8df f003 	tbb	[pc, r3]
2000533e:	1a05      	.short	0x1a05
20005340:	1a0a1a08 	.word	0x1a0a1a08
20005344:	1a1a      	.short	0x1a1a
20005346:	14          	.byte	0x14
20005347:	00          	.byte	0x00
        {
        case UART_CLOCKSOURCE_PCLK1:
            tmpreg = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
20005348:	f7fd fe84 	bl	20003054 <HAL_RCC_GetPCLK1Freq>
2000534c:	e003      	b.n	20005356 <UART_SetConfig+0x232>
          break;
        case UART_CLOCKSOURCE_HSI:
            tmpreg = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate));
2000534e:	4821      	ldr	r0, [pc, #132]	; (200053d4 <UART_SetConfig+0x2b0>)
20005350:	e00b      	b.n	2000536a <UART_SetConfig+0x246>
          break;
        case UART_CLOCKSOURCE_SYSCLK:
            tmpreg = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
20005352:	f7fd fdfd 	bl	20002f50 <HAL_RCC_GetSysClockFreq>
20005356:	4601      	mov	r1, r0
20005358:	6862      	ldr	r2, [r4, #4]
2000535a:	2300      	movs	r3, #0
2000535c:	0200      	lsls	r0, r0, #8
2000535e:	0e09      	lsrs	r1, r1, #24
20005360:	f000 f990 	bl	20005684 <__aeabi_uldivmod>
20005364:	e003      	b.n	2000536e <UART_SetConfig+0x24a>
          break;
        case UART_CLOCKSOURCE_LSE:
            tmpreg = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
20005366:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
2000536a:	fbb0 f0f2 	udiv	r0, r0, r2
          break;
2000536e:	2200      	movs	r2, #0
20005370:	e000      	b.n	20005374 <UART_SetConfig+0x250>
        case UART_CLOCKSOURCE_UNDEFINED:
        default:
            ret = HAL_ERROR;
20005372:	2201      	movs	r2, #1
          break;
        }
   
        if ((tmpreg >= UART_LPUART_BRR_MIN) && (tmpreg <= UART_LPUART_BRR_MAX))
20005374:	4b18      	ldr	r3, [pc, #96]	; (200053d8 <UART_SetConfig+0x2b4>)
20005376:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
2000537a:	4299      	cmp	r1, r3
2000537c:	d811      	bhi.n	200053a2 <UART_SetConfig+0x27e>
        {
           huart->Instance->BRR = tmpreg;
2000537e:	6823      	ldr	r3, [r4, #0]
20005380:	60d8      	str	r0, [r3, #12]
20005382:	e00f      	b.n	200053a4 <UART_SetConfig+0x280>

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);

  /* Check LPUART instance */
  if(UART_INSTANCE_LOWPOWER(huart))
20005384:	4a09      	ldr	r2, [pc, #36]	; (200053ac <UART_SetConfig+0x288>)
20005386:	4295      	cmp	r5, r2
20005388:	f47f af7e 	bne.w	20005288 <UART_SetConfig+0x164>
2000538c:	2308      	movs	r3, #8
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      tmpreg = HAL_RCC_GetSysClockFreq();
      break;
    case UART_CLOCKSOURCE_LSE:
      tmpreg = (uint32_t) LSE_VALUE;
2000538e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
20005392:	e7c8      	b.n	20005326 <UART_SetConfig+0x202>

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);

  /* Check LPUART instance */
  if(UART_INSTANCE_LOWPOWER(huart))
20005394:	4a05      	ldr	r2, [pc, #20]	; (200053ac <UART_SetConfig+0x288>)
20005396:	4295      	cmp	r5, r2
20005398:	f47f af66 	bne.w	20005268 <UART_SetConfig+0x144>
2000539c:	2302      	movs	r3, #2
    {
    case UART_CLOCKSOURCE_PCLK1:
      tmpreg = HAL_RCC_GetPCLK1Freq();
      break;
    case UART_CLOCKSOURCE_HSI:
      tmpreg = (uint32_t) HSI_VALUE;
2000539e:	480c      	ldr	r0, [pc, #48]	; (200053d0 <UART_SetConfig+0x2ac>)
200053a0:	e7c1      	b.n	20005326 <UART_SetConfig+0x202>
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
      break;
      case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
200053a2:	2201      	movs	r2, #1
    }
  }

  return ret;

}
200053a4:	4610      	mov	r0, r2
200053a6:	bd38      	pop	{r3, r4, r5, pc}
200053a8:	efff69f3 	.word	0xefff69f3
200053ac:	40008000 	.word	0x40008000
200053b0:	40013800 	.word	0x40013800
200053b4:	20006666 	.word	0x20006666
200053b8:	40004400 	.word	0x40004400
200053bc:	20006659 	.word	0x20006659
200053c0:	40004800 	.word	0x40004800
200053c4:	40004c00 	.word	0x40004c00
200053c8:	40005000 	.word	0x40005000
200053cc:	01e84800 	.word	0x01e84800
200053d0:	00f42400 	.word	0x00f42400
200053d4:	f4240000 	.word	0xf4240000
200053d8:	000ffcff 	.word	0x000ffcff

200053dc <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
200053dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
200053de:	07da      	lsls	r2, r3, #31
  * @brief Configure the UART peripheral advanced features.
  * @param huart: UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
200053e0:	b510      	push	{r4, lr}

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
200053e2:	bf41      	itttt	mi
200053e4:	6804      	ldrmi	r4, [r0, #0]
200053e6:	6862      	ldrmi	r2, [r4, #4]
200053e8:	f422 3100 	bicmi.w	r1, r2, #131072	; 0x20000
200053ec:	6a82      	ldrmi	r2, [r0, #40]	; 0x28
200053ee:	bf44      	itt	mi
200053f0:	430a      	orrmi	r2, r1
200053f2:	6062      	strmi	r2, [r4, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
200053f4:	079c      	lsls	r4, r3, #30
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
200053f6:	bf41      	itttt	mi
200053f8:	6804      	ldrmi	r4, [r0, #0]
200053fa:	6862      	ldrmi	r2, [r4, #4]
200053fc:	f422 3180 	bicmi.w	r1, r2, #65536	; 0x10000
20005400:	6ac2      	ldrmi	r2, [r0, #44]	; 0x2c
20005402:	bf44      	itt	mi
20005404:	430a      	orrmi	r2, r1
20005406:	6062      	strmi	r2, [r4, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
20005408:	0759      	lsls	r1, r3, #29
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
2000540a:	bf41      	itttt	mi
2000540c:	6804      	ldrmi	r4, [r0, #0]
2000540e:	6862      	ldrmi	r2, [r4, #4]
20005410:	f422 2180 	bicmi.w	r1, r2, #262144	; 0x40000
20005414:	6b02      	ldrmi	r2, [r0, #48]	; 0x30
20005416:	bf44      	itt	mi
20005418:	430a      	orrmi	r2, r1
2000541a:	6062      	strmi	r2, [r4, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
2000541c:	071a      	lsls	r2, r3, #28
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
2000541e:	bf41      	itttt	mi
20005420:	6804      	ldrmi	r4, [r0, #0]
20005422:	6862      	ldrmi	r2, [r4, #4]
20005424:	f422 4100 	bicmi.w	r1, r2, #32768	; 0x8000
20005428:	6b42      	ldrmi	r2, [r0, #52]	; 0x34
2000542a:	bf44      	itt	mi
2000542c:	430a      	orrmi	r2, r1
2000542e:	6062      	strmi	r2, [r4, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
20005430:	06dc      	lsls	r4, r3, #27
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
20005432:	bf41      	itttt	mi
20005434:	6804      	ldrmi	r4, [r0, #0]
20005436:	68a2      	ldrmi	r2, [r4, #8]
20005438:	f422 5180 	bicmi.w	r1, r2, #4096	; 0x1000
2000543c:	6b82      	ldrmi	r2, [r0, #56]	; 0x38
2000543e:	bf44      	itt	mi
20005440:	430a      	orrmi	r2, r1
20005442:	60a2      	strmi	r2, [r4, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
20005444:	0699      	lsls	r1, r3, #26
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
20005446:	bf41      	itttt	mi
20005448:	6804      	ldrmi	r4, [r0, #0]
2000544a:	68a2      	ldrmi	r2, [r4, #8]
2000544c:	f422 5100 	bicmi.w	r1, r2, #8192	; 0x2000
20005450:	6bc2      	ldrmi	r2, [r0, #60]	; 0x3c
20005452:	bf44      	itt	mi
20005454:	430a      	orrmi	r2, r1
20005456:	60a2      	strmi	r2, [r4, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
20005458:	065a      	lsls	r2, r3, #25
2000545a:	d510      	bpl.n	2000547e <UART_AdvFeatureConfig+0xa2>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
2000545c:	6801      	ldr	r1, [r0, #0]
2000545e:	6c04      	ldr	r4, [r0, #64]	; 0x40
20005460:	684a      	ldr	r2, [r1, #4]
20005462:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
20005466:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
20005468:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
2000546c:	604a      	str	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
2000546e:	bf01      	itttt	eq
20005470:	684a      	ldreq	r2, [r1, #4]
20005472:	f422 04c0 	biceq.w	r4, r2, #6291456	; 0x600000
20005476:	6c42      	ldreq	r2, [r0, #68]	; 0x44
20005478:	4322      	orreq	r2, r4
2000547a:	bf08      	it	eq
2000547c:	604a      	streq	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
2000547e:	061b      	lsls	r3, r3, #24
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
20005480:	bf41      	itttt	mi
20005482:	6801      	ldrmi	r1, [r0, #0]
20005484:	684b      	ldrmi	r3, [r1, #4]
20005486:	f423 2200 	bicmi.w	r2, r3, #524288	; 0x80000
2000548a:	6c83      	ldrmi	r3, [r0, #72]	; 0x48
2000548c:	bf44      	itt	mi
2000548e:	4313      	orrmi	r3, r2
20005490:	604b      	strmi	r3, [r1, #4]
20005492:	bd10      	pop	{r4, pc}

20005494 <UART_WaitOnFlagUntilTimeout>:
  * @param  Status: the Flag status (SET or RESET).
  * @param  Timeout: Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
20005494:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
20005498:	4604      	mov	r4, r0
2000549a:	460e      	mov	r6, r1
2000549c:	4690      	mov	r8, r2
2000549e:	461d      	mov	r5, r3
  uint32_t tickstart = HAL_GetTick();
200054a0:	f7fe f9d6 	bl	20003850 <HAL_GetTick>
200054a4:	4607      	mov	r7, r0

  /* Wait until flag is set */
  if(Status == RESET)
200054a6:	f1b8 0f00 	cmp.w	r8, #0
200054aa:	d136      	bne.n	2000551a <UART_WaitOnFlagUntilTimeout+0x86>
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
200054ac:	6822      	ldr	r2, [r4, #0]
200054ae:	69d3      	ldr	r3, [r2, #28]
200054b0:	4033      	ands	r3, r6
200054b2:	42b3      	cmp	r3, r6
200054b4:	d00e      	beq.n	200054d4 <UART_WaitOnFlagUntilTimeout+0x40>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
200054b6:	1c69      	adds	r1, r5, #1
200054b8:	d0f9      	beq.n	200054ae <UART_WaitOnFlagUntilTimeout+0x1a>
      {
        if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
200054ba:	b17d      	cbz	r5, 200054dc <UART_WaitOnFlagUntilTimeout+0x48>
200054bc:	f7fe f9c8 	bl	20003850 <HAL_GetTick>
200054c0:	1bc0      	subs	r0, r0, r7
200054c2:	42a8      	cmp	r0, r5
200054c4:	d9f2      	bls.n	200054ac <UART_WaitOnFlagUntilTimeout+0x18>
200054c6:	e009      	b.n	200054dc <UART_WaitOnFlagUntilTimeout+0x48>
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
200054c8:	1c6b      	adds	r3, r5, #1
200054ca:	d106      	bne.n	200054da <UART_WaitOnFlagUntilTimeout+0x46>
      }
    }
  }
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
200054cc:	69d3      	ldr	r3, [r2, #28]
200054ce:	4033      	ands	r3, r6
200054d0:	42b3      	cmp	r3, r6
200054d2:	d0f9      	beq.n	200054c8 <UART_WaitOnFlagUntilTimeout+0x34>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
200054d4:	2000      	movs	r0, #0
200054d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
200054da:	b9cd      	cbnz	r5, 20005510 <UART_WaitOnFlagUntilTimeout+0x7c>
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
200054dc:	6823      	ldr	r3, [r4, #0]
200054de:	681a      	ldr	r2, [r3, #0]
200054e0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
200054e4:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
200054e6:	681a      	ldr	r2, [r3, #0]
200054e8:	f022 0220 	bic.w	r2, r2, #32
200054ec:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
200054ee:	681a      	ldr	r2, [r3, #0]
200054f0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
200054f4:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
200054f6:	689a      	ldr	r2, [r3, #8]
200054f8:	f022 0201 	bic.w	r2, r2, #1
200054fc:	609a      	str	r2, [r3, #8]

          huart->State= HAL_UART_STATE_READY;
200054fe:	2301      	movs	r3, #1
20005500:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
20005504:	2300      	movs	r3, #0
20005506:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68

          return HAL_TIMEOUT;
2000550a:	2003      	movs	r0, #3
2000550c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
20005510:	f7fe f99e 	bl	20003850 <HAL_GetTick>
20005514:	1bc0      	subs	r0, r0, r7
20005516:	42a8      	cmp	r0, r5
20005518:	d8e0      	bhi.n	200054dc <UART_WaitOnFlagUntilTimeout+0x48>
      }
    }
  }
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
2000551a:	6822      	ldr	r2, [r4, #0]
2000551c:	e7d6      	b.n	200054cc <UART_WaitOnFlagUntilTimeout+0x38>

2000551e <UART_CheckIdleState>:
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2000551e:	2200      	movs	r2, #0

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
20005520:	6803      	ldr	r3, [r0, #0]
  * @brief Check the UART Idle State.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
20005522:	b510      	push	{r4, lr}
  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
20005524:	66c2      	str	r2, [r0, #108]	; 0x6c

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
20005526:	681b      	ldr	r3, [r3, #0]
20005528:	0719      	lsls	r1, r3, #28
  * @brief Check the UART Idle State.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
2000552a:	4604      	mov	r4, r0
  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
2000552c:	d404      	bmi.n	20005538 <UART_CheckIdleState+0x1a>
      /* Timeout occurred */
      return HAL_TIMEOUT;
    }
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
2000552e:	6823      	ldr	r3, [r4, #0]
20005530:	681b      	ldr	r3, [r3, #0]
20005532:	075b      	lsls	r3, r3, #29
20005534:	d514      	bpl.n	20005560 <UART_CheckIdleState+0x42>
20005536:	e009      	b.n	2000554c <UART_CheckIdleState+0x2e>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
  {
    /* Wait until TEACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
20005538:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
2000553c:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
20005540:	f7ff ffa8 	bl	20005494 <UART_WaitOnFlagUntilTimeout>
20005544:	2800      	cmp	r0, #0
20005546:	d0f2      	beq.n	2000552e <UART_CheckIdleState+0x10>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
20005548:	2003      	movs	r0, #3
2000554a:	bd10      	pop	{r4, pc}
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
  {
    /* Wait until REACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET,  HAL_UART_TIMEOUT_VALUE) != HAL_OK)
2000554c:	4620      	mov	r0, r4
2000554e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
20005552:	2200      	movs	r2, #0
20005554:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
20005558:	f7ff ff9c 	bl	20005494 <UART_WaitOnFlagUntilTimeout>
2000555c:	2800      	cmp	r0, #0
2000555e:	d1f3      	bne.n	20005548 <UART_CheckIdleState+0x2a>
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->State= HAL_UART_STATE_READY;
20005560:	2301      	movs	r3, #1

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
20005562:	2000      	movs	r0, #0
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->State= HAL_UART_STATE_READY;
20005564:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
20005568:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68

  return HAL_OK;
2000556c:	bd10      	pop	{r4, pc}

2000556e <HAL_UART_Init>:
  *         parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
2000556e:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
20005570:	4604      	mov	r4, r0
20005572:	b360      	cbz	r0, 200055ce <HAL_UART_Init+0x60>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }

  if(huart->State == HAL_UART_STATE_RESET)
20005574:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
20005578:	f003 02ff 	and.w	r2, r3, #255	; 0xff
2000557c:	b91b      	cbnz	r3, 20005586 <HAL_UART_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
2000557e:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
20005582:	f7ff fdcd 	bl	20005120 <HAL_UART_MspInit>
  }

  huart->State = HAL_UART_STATE_BUSY;

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
20005586:	6822      	ldr	r2, [r4, #0]

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
  }

  huart->State = HAL_UART_STATE_BUSY;
20005588:	2302      	movs	r3, #2
2000558a:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
2000558e:	6813      	ldr	r3, [r2, #0]
20005590:	f023 0301 	bic.w	r3, r3, #1
20005594:	6013      	str	r3, [r2, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
20005596:	4620      	mov	r0, r4
20005598:	f7ff fdc4 	bl	20005124 <UART_SetConfig>
2000559c:	2801      	cmp	r0, #1
2000559e:	d016      	beq.n	200055ce <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
200055a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
200055a2:	b113      	cbz	r3, 200055aa <HAL_UART_Init+0x3c>
  {
    UART_AdvFeatureConfig(huart);
200055a4:	4620      	mov	r0, r4
200055a6:	f7ff ff19 	bl	200053dc <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
200055aa:	6823      	ldr	r3, [r4, #0]
200055ac:	685a      	ldr	r2, [r3, #4]
200055ae:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
200055b2:	605a      	str	r2, [r3, #4]
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
200055b4:	689a      	ldr	r2, [r3, #8]
200055b6:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
200055ba:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
200055bc:	681a      	ldr	r2, [r3, #0]
200055be:	f042 0201 	orr.w	r2, r2, #1

  /* TEACK and/or REACK to check before moving huart->State to Ready */
  return (UART_CheckIdleState(huart));
200055c2:	4620      	mov	r0, r4
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
200055c4:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->State to Ready */
  return (UART_CheckIdleState(huart));
}
200055c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);

  /* TEACK and/or REACK to check before moving huart->State to Ready */
  return (UART_CheckIdleState(huart));
200055ca:	f7ff bfa8 	b.w	2000551e <UART_CheckIdleState>
}
200055ce:	2001      	movs	r0, #1
200055d0:	bd10      	pop	{r4, pc}
	...

200055d4 <ramlog_addchar>:

void ramlog_addchar(char ch)
{
    int nexthead;

    if (rl_dev->rl_validity != RAMLOG_VALIDITY) return;
200055d4:	4a10      	ldr	r2, [pc, #64]	; (20005618 <ramlog_addchar+0x44>)
200055d6:	4b11      	ldr	r3, [pc, #68]	; (2000561c <ramlog_addchar+0x48>)
200055d8:	6811      	ldr	r1, [r2, #0]
200055da:	4299      	cmp	r1, r3
};

static struct ramlog_dev_s *rl_dev = (struct ramlog_dev_s *)CONFIG_RAMLOG_ADDR;

void ramlog_addchar(char ch)
{
200055dc:	b510      	push	{r4, lr}
    int nexthead;

    if (rl_dev->rl_validity != RAMLOG_VALIDITY) return;
200055de:	d119      	bne.n	20005614 <ramlog_addchar+0x40>

    /* Calculate the write index AFTER the next byte is written */
    nexthead = rl_dev->rl_head + 1;
200055e0:	8893      	ldrh	r3, [r2, #4]
    if (nexthead >= rl_dev->rl_bufsize) {
200055e2:	68d4      	ldr	r4, [r2, #12]
        nexthead = 0;
    }

    /* Would the next write overflow the circular buffer? */
    if (nexthead == rl_dev->rl_tail) {
200055e4:	88d1      	ldrh	r1, [r2, #6]
    int nexthead;

    if (rl_dev->rl_validity != RAMLOG_VALIDITY) return;

    /* Calculate the write index AFTER the next byte is written */
    nexthead = rl_dev->rl_head + 1;
200055e6:	b29b      	uxth	r3, r3
200055e8:	3301      	adds	r3, #1
    if (nexthead >= rl_dev->rl_bufsize) {
        nexthead = 0;
200055ea:	42a3      	cmp	r3, r4
200055ec:	bf28      	it	cs
200055ee:	2300      	movcs	r3, #0
    }

    /* Would the next write overflow the circular buffer? */
    if (nexthead == rl_dev->rl_tail) {
200055f0:	b289      	uxth	r1, r1
200055f2:	428b      	cmp	r3, r1
200055f4:	d107      	bne.n	20005606 <ramlog_addchar+0x32>
        /* Yes, so move tail to drop oldest byte from buffer */
        if (++rl_dev->rl_tail >= rl_dev->rl_bufsize) {
200055f6:	88d1      	ldrh	r1, [r2, #6]
200055f8:	3101      	adds	r1, #1
200055fa:	b289      	uxth	r1, r1
200055fc:	42a1      	cmp	r1, r4
200055fe:	80d1      	strh	r1, [r2, #6]
          rl_dev->rl_tail = 0;
20005600:	bf24      	itt	cs
20005602:	2100      	movcs	r1, #0
20005604:	80d1      	strhcs	r1, [r2, #6]
        }
    }

    rl_dev->rl_buffer[rl_dev->rl_head] = ch;
20005606:	4a04      	ldr	r2, [pc, #16]	; (20005618 <ramlog_addchar+0x44>)
20005608:	8891      	ldrh	r1, [r2, #4]
2000560a:	6914      	ldr	r4, [r2, #16]
2000560c:	b289      	uxth	r1, r1
    rl_dev->rl_head = nexthead;
2000560e:	b29b      	uxth	r3, r3
        if (++rl_dev->rl_tail >= rl_dev->rl_bufsize) {
          rl_dev->rl_tail = 0;
        }
    }

    rl_dev->rl_buffer[rl_dev->rl_head] = ch;
20005610:	5460      	strb	r0, [r4, r1]
    rl_dev->rl_head = nexthead;
20005612:	8093      	strh	r3, [r2, #4]
20005614:	bd10      	pop	{r4, pc}
20005616:	bf00      	nop
20005618:	20017000 	.word	0x20017000
2000561c:	0f1e2d3c 	.word	0x0f1e2d3c

20005620 <ramlog_write>:
}

void ramlog_write(const char *buffer, uint32_t len)
{
20005620:	b538      	push	{r3, r4, r5, lr}
20005622:	4604      	mov	r4, r0
20005624:	1845      	adds	r5, r0, r1
    int nwritten;

    for (nwritten = 0; nwritten < len; nwritten++) {
20005626:	42ac      	cmp	r4, r5
20005628:	d004      	beq.n	20005634 <ramlog_write+0x14>
        ramlog_addchar(buffer[nwritten]);
2000562a:	f814 0b01 	ldrb.w	r0, [r4], #1
2000562e:	f7ff ffd1 	bl	200055d4 <ramlog_addchar>
20005632:	e7f8      	b.n	20005626 <ramlog_write+0x6>
    }
}
20005634:	bd38      	pop	{r3, r4, r5, pc}

20005636 <ramlog_writehex8>:

void ramlog_writehex8(uint8_t num)
{
20005636:	b510      	push	{r4, lr}
20005638:	4604      	mov	r4, r0
    int digit;
    int nibble;

    for (digit = 1; digit >= 0; digit--) {
        nibble = (num >> (digit << 2)) & 0x0f;
2000563a:	1100      	asrs	r0, r0, #4
        if (nibble < 10) {
2000563c:	2809      	cmp	r0, #9
            ramlog_addchar('0' + nibble);
        } else {
            ramlog_addchar('a' + (nibble - 10));
2000563e:	bfcc      	ite	gt
20005640:	3057      	addgt	r0, #87	; 0x57
    int nibble;

    for (digit = 1; digit >= 0; digit--) {
        nibble = (num >> (digit << 2)) & 0x0f;
        if (nibble < 10) {
            ramlog_addchar('0' + nibble);
20005642:	3030      	addle	r0, #48	; 0x30
20005644:	f7ff ffc6 	bl	200055d4 <ramlog_addchar>
{
    int digit;
    int nibble;

    for (digit = 1; digit >= 0; digit--) {
        nibble = (num >> (digit << 2)) & 0x0f;
20005648:	f004 000f 	and.w	r0, r4, #15
        if (nibble < 10) {
2000564c:	2809      	cmp	r0, #9
            ramlog_addchar('0' + nibble);
        } else {
            ramlog_addchar('a' + (nibble - 10));
2000564e:	bf8c      	ite	hi
20005650:	3057      	addhi	r0, #87	; 0x57
    int nibble;

    for (digit = 1; digit >= 0; digit--) {
        nibble = (num >> (digit << 2)) & 0x0f;
        if (nibble < 10) {
            ramlog_addchar('0' + nibble);
20005652:	3030      	addls	r0, #48	; 0x30
        } else {
            ramlog_addchar('a' + (nibble - 10));
        }
    }
}
20005654:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    int nibble;

    for (digit = 1; digit >= 0; digit--) {
        nibble = (num >> (digit << 2)) & 0x0f;
        if (nibble < 10) {
            ramlog_addchar('0' + nibble);
20005658:	f7ff bfbc 	b.w	200055d4 <ramlog_addchar>

2000565c <ramlog_reason>:
        }
    }
}

void ramlog_reason(void)
{
2000565c:	b508      	push	{r3, lr}
    ramlog_write("--[MuC Loader]-- Reason: ", 25);
2000565e:	2119      	movs	r1, #25
20005660:	4806      	ldr	r0, [pc, #24]	; (2000567c <ramlog_reason+0x20>)
20005662:	f7ff ffdd 	bl	20005620 <ramlog_write>
    ramlog_writehex8(get_flash_reason());
20005666:	f7fa fe05 	bl	20000274 <get_flash_reason>
2000566a:	b2c0      	uxtb	r0, r0
2000566c:	f7ff ffe3 	bl	20005636 <ramlog_writehex8>
    ramlog_addchar('\n');
20005670:	200a      	movs	r0, #10
}
20005672:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void ramlog_reason(void)
{
    ramlog_write("--[MuC Loader]-- Reason: ", 25);
    ramlog_writehex8(get_flash_reason());
    ramlog_addchar('\n');
20005676:	f7ff bfad 	b.w	200055d4 <ramlog_addchar>
2000567a:	bf00      	nop
2000567c:	2000666a 	.word	0x2000666a

20005680 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
20005680:	e7fe      	b.n	20005680 <ADC1_2_IRQHandler>
	...

20005684 <__aeabi_uldivmod>:
20005684:	b953      	cbnz	r3, 2000569c <__aeabi_uldivmod+0x18>
20005686:	b94a      	cbnz	r2, 2000569c <__aeabi_uldivmod+0x18>
20005688:	2900      	cmp	r1, #0
2000568a:	bf08      	it	eq
2000568c:	2800      	cmpeq	r0, #0
2000568e:	bf1c      	itt	ne
20005690:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
20005694:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
20005698:	f000 b83c 	b.w	20005714 <__aeabi_idiv0>
2000569c:	b082      	sub	sp, #8
2000569e:	46ec      	mov	ip, sp
200056a0:	e92d 5000 	stmdb	sp!, {ip, lr}
200056a4:	f000 f81e 	bl	200056e4 <__gnu_uldivmod_helper>
200056a8:	f8dd e004 	ldr.w	lr, [sp, #4]
200056ac:	b002      	add	sp, #8
200056ae:	bc0c      	pop	{r2, r3}
200056b0:	4770      	bx	lr
200056b2:	bf00      	nop

200056b4 <__gnu_ldivmod_helper>:
200056b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
200056b8:	9c06      	ldr	r4, [sp, #24]
200056ba:	4615      	mov	r5, r2
200056bc:	4606      	mov	r6, r0
200056be:	460f      	mov	r7, r1
200056c0:	4698      	mov	r8, r3
200056c2:	f000 f829 	bl	20005718 <__divdi3>
200056c6:	fb05 f301 	mul.w	r3, r5, r1
200056ca:	fb00 3808 	mla	r8, r0, r8, r3
200056ce:	fba5 2300 	umull	r2, r3, r5, r0
200056d2:	1ab2      	subs	r2, r6, r2
200056d4:	4443      	add	r3, r8
200056d6:	eb67 0303 	sbc.w	r3, r7, r3
200056da:	e9c4 2300 	strd	r2, r3, [r4]
200056de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
200056e2:	bf00      	nop

200056e4 <__gnu_uldivmod_helper>:
200056e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
200056e8:	9c06      	ldr	r4, [sp, #24]
200056ea:	4690      	mov	r8, r2
200056ec:	4606      	mov	r6, r0
200056ee:	460f      	mov	r7, r1
200056f0:	461d      	mov	r5, r3
200056f2:	f000 f95f 	bl	200059b4 <__udivdi3>
200056f6:	fb00 f505 	mul.w	r5, r0, r5
200056fa:	fba0 2308 	umull	r2, r3, r0, r8
200056fe:	fb08 5501 	mla	r5, r8, r1, r5
20005702:	1ab2      	subs	r2, r6, r2
20005704:	442b      	add	r3, r5
20005706:	eb67 0303 	sbc.w	r3, r7, r3
2000570a:	e9c4 2300 	strd	r2, r3, [r4]
2000570e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20005712:	bf00      	nop

20005714 <__aeabi_idiv0>:
20005714:	4770      	bx	lr
20005716:	bf00      	nop

20005718 <__divdi3>:
20005718:	2900      	cmp	r1, #0
2000571a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
2000571e:	f2c0 80a6 	blt.w	2000586e <__divdi3+0x156>
20005722:	2600      	movs	r6, #0
20005724:	2b00      	cmp	r3, #0
20005726:	f2c0 809c 	blt.w	20005862 <__divdi3+0x14a>
2000572a:	4688      	mov	r8, r1
2000572c:	4694      	mov	ip, r2
2000572e:	469e      	mov	lr, r3
20005730:	4615      	mov	r5, r2
20005732:	4604      	mov	r4, r0
20005734:	460f      	mov	r7, r1
20005736:	2b00      	cmp	r3, #0
20005738:	d13d      	bne.n	200057b6 <__divdi3+0x9e>
2000573a:	428a      	cmp	r2, r1
2000573c:	d959      	bls.n	200057f2 <__divdi3+0xda>
2000573e:	fab2 f382 	clz	r3, r2
20005742:	b13b      	cbz	r3, 20005754 <__divdi3+0x3c>
20005744:	f1c3 0220 	rsb	r2, r3, #32
20005748:	409f      	lsls	r7, r3
2000574a:	fa20 f202 	lsr.w	r2, r0, r2
2000574e:	409d      	lsls	r5, r3
20005750:	4317      	orrs	r7, r2
20005752:	409c      	lsls	r4, r3
20005754:	0c29      	lsrs	r1, r5, #16
20005756:	0c22      	lsrs	r2, r4, #16
20005758:	fbb7 fef1 	udiv	lr, r7, r1
2000575c:	b2a8      	uxth	r0, r5
2000575e:	fb01 771e 	mls	r7, r1, lr, r7
20005762:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
20005766:	fb00 f30e 	mul.w	r3, r0, lr
2000576a:	42bb      	cmp	r3, r7
2000576c:	d90a      	bls.n	20005784 <__divdi3+0x6c>
2000576e:	197f      	adds	r7, r7, r5
20005770:	f10e 32ff 	add.w	r2, lr, #4294967295	; 0xffffffff
20005774:	f080 8105 	bcs.w	20005982 <__divdi3+0x26a>
20005778:	42bb      	cmp	r3, r7
2000577a:	f240 8102 	bls.w	20005982 <__divdi3+0x26a>
2000577e:	f1ae 0e02 	sub.w	lr, lr, #2
20005782:	442f      	add	r7, r5
20005784:	1aff      	subs	r7, r7, r3
20005786:	b2a4      	uxth	r4, r4
20005788:	fbb7 f3f1 	udiv	r3, r7, r1
2000578c:	fb01 7713 	mls	r7, r1, r3, r7
20005790:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
20005794:	fb00 f003 	mul.w	r0, r0, r3
20005798:	42b8      	cmp	r0, r7
2000579a:	d908      	bls.n	200057ae <__divdi3+0x96>
2000579c:	197f      	adds	r7, r7, r5
2000579e:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
200057a2:	f080 80f0 	bcs.w	20005986 <__divdi3+0x26e>
200057a6:	42b8      	cmp	r0, r7
200057a8:	f240 80ed 	bls.w	20005986 <__divdi3+0x26e>
200057ac:	3b02      	subs	r3, #2
200057ae:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
200057b2:	2200      	movs	r2, #0
200057b4:	e003      	b.n	200057be <__divdi3+0xa6>
200057b6:	428b      	cmp	r3, r1
200057b8:	d90f      	bls.n	200057da <__divdi3+0xc2>
200057ba:	2200      	movs	r2, #0
200057bc:	4613      	mov	r3, r2
200057be:	1c34      	adds	r4, r6, #0
200057c0:	bf18      	it	ne
200057c2:	2401      	movne	r4, #1
200057c4:	4260      	negs	r0, r4
200057c6:	f04f 0500 	mov.w	r5, #0
200057ca:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
200057ce:	4058      	eors	r0, r3
200057d0:	4051      	eors	r1, r2
200057d2:	1900      	adds	r0, r0, r4
200057d4:	4169      	adcs	r1, r5
200057d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
200057da:	fab3 f283 	clz	r2, r3
200057de:	2a00      	cmp	r2, #0
200057e0:	f040 8086 	bne.w	200058f0 <__divdi3+0x1d8>
200057e4:	428b      	cmp	r3, r1
200057e6:	d302      	bcc.n	200057ee <__divdi3+0xd6>
200057e8:	4584      	cmp	ip, r0
200057ea:	f200 80db 	bhi.w	200059a4 <__divdi3+0x28c>
200057ee:	2301      	movs	r3, #1
200057f0:	e7e5      	b.n	200057be <__divdi3+0xa6>
200057f2:	b912      	cbnz	r2, 200057fa <__divdi3+0xe2>
200057f4:	2301      	movs	r3, #1
200057f6:	fbb3 f5f2 	udiv	r5, r3, r2
200057fa:	fab5 f085 	clz	r0, r5
200057fe:	2800      	cmp	r0, #0
20005800:	d13b      	bne.n	2000587a <__divdi3+0x162>
20005802:	1b78      	subs	r0, r7, r5
20005804:	ea4f 4e15 	mov.w	lr, r5, lsr #16
20005808:	fa1f fc85 	uxth.w	ip, r5
2000580c:	2201      	movs	r2, #1
2000580e:	fbb0 f8fe 	udiv	r8, r0, lr
20005812:	0c21      	lsrs	r1, r4, #16
20005814:	fb0e 0718 	mls	r7, lr, r8, r0
20005818:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
2000581c:	fb0c f308 	mul.w	r3, ip, r8
20005820:	42bb      	cmp	r3, r7
20005822:	d907      	bls.n	20005834 <__divdi3+0x11c>
20005824:	197f      	adds	r7, r7, r5
20005826:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
2000582a:	d202      	bcs.n	20005832 <__divdi3+0x11a>
2000582c:	42bb      	cmp	r3, r7
2000582e:	f200 80bd 	bhi.w	200059ac <__divdi3+0x294>
20005832:	4688      	mov	r8, r1
20005834:	1aff      	subs	r7, r7, r3
20005836:	b2a4      	uxth	r4, r4
20005838:	fbb7 f3fe 	udiv	r3, r7, lr
2000583c:	fb0e 7713 	mls	r7, lr, r3, r7
20005840:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
20005844:	fb0c fc03 	mul.w	ip, ip, r3
20005848:	45bc      	cmp	ip, r7
2000584a:	d907      	bls.n	2000585c <__divdi3+0x144>
2000584c:	197f      	adds	r7, r7, r5
2000584e:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
20005852:	d202      	bcs.n	2000585a <__divdi3+0x142>
20005854:	45bc      	cmp	ip, r7
20005856:	f200 80a7 	bhi.w	200059a8 <__divdi3+0x290>
2000585a:	460b      	mov	r3, r1
2000585c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
20005860:	e7ad      	b.n	200057be <__divdi3+0xa6>
20005862:	4252      	negs	r2, r2
20005864:	ea6f 0606 	mvn.w	r6, r6
20005868:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
2000586c:	e75d      	b.n	2000572a <__divdi3+0x12>
2000586e:	4240      	negs	r0, r0
20005870:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
20005874:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
20005878:	e754      	b.n	20005724 <__divdi3+0xc>
2000587a:	f1c0 0220 	rsb	r2, r0, #32
2000587e:	fa24 f102 	lsr.w	r1, r4, r2
20005882:	fa07 f300 	lsl.w	r3, r7, r0
20005886:	4085      	lsls	r5, r0
20005888:	ea4f 4e15 	mov.w	lr, r5, lsr #16
2000588c:	40d7      	lsrs	r7, r2
2000588e:	4319      	orrs	r1, r3
20005890:	fbb7 f2fe 	udiv	r2, r7, lr
20005894:	0c0b      	lsrs	r3, r1, #16
20005896:	fb0e 7712 	mls	r7, lr, r2, r7
2000589a:	fa1f fc85 	uxth.w	ip, r5
2000589e:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
200058a2:	fb0c f702 	mul.w	r7, ip, r2
200058a6:	429f      	cmp	r7, r3
200058a8:	fa04 f400 	lsl.w	r4, r4, r0
200058ac:	d907      	bls.n	200058be <__divdi3+0x1a6>
200058ae:	195b      	adds	r3, r3, r5
200058b0:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
200058b4:	d274      	bcs.n	200059a0 <__divdi3+0x288>
200058b6:	429f      	cmp	r7, r3
200058b8:	d972      	bls.n	200059a0 <__divdi3+0x288>
200058ba:	3a02      	subs	r2, #2
200058bc:	442b      	add	r3, r5
200058be:	1bdf      	subs	r7, r3, r7
200058c0:	b289      	uxth	r1, r1
200058c2:	fbb7 f8fe 	udiv	r8, r7, lr
200058c6:	fb0e 7318 	mls	r3, lr, r8, r7
200058ca:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
200058ce:	fb0c f708 	mul.w	r7, ip, r8
200058d2:	429f      	cmp	r7, r3
200058d4:	d908      	bls.n	200058e8 <__divdi3+0x1d0>
200058d6:	195b      	adds	r3, r3, r5
200058d8:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
200058dc:	d25c      	bcs.n	20005998 <__divdi3+0x280>
200058de:	429f      	cmp	r7, r3
200058e0:	d95a      	bls.n	20005998 <__divdi3+0x280>
200058e2:	f1a8 0802 	sub.w	r8, r8, #2
200058e6:	442b      	add	r3, r5
200058e8:	1bd8      	subs	r0, r3, r7
200058ea:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
200058ee:	e78e      	b.n	2000580e <__divdi3+0xf6>
200058f0:	f1c2 0320 	rsb	r3, r2, #32
200058f4:	fa2c f103 	lsr.w	r1, ip, r3
200058f8:	fa0e fe02 	lsl.w	lr, lr, r2
200058fc:	fa20 f703 	lsr.w	r7, r0, r3
20005900:	ea41 0e0e 	orr.w	lr, r1, lr
20005904:	fa08 f002 	lsl.w	r0, r8, r2
20005908:	fa28 f103 	lsr.w	r1, r8, r3
2000590c:	ea4f 451e 	mov.w	r5, lr, lsr #16
20005910:	4338      	orrs	r0, r7
20005912:	fbb1 f8f5 	udiv	r8, r1, r5
20005916:	0c03      	lsrs	r3, r0, #16
20005918:	fb05 1118 	mls	r1, r5, r8, r1
2000591c:	fa1f f78e 	uxth.w	r7, lr
20005920:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
20005924:	fb07 f308 	mul.w	r3, r7, r8
20005928:	428b      	cmp	r3, r1
2000592a:	fa0c fc02 	lsl.w	ip, ip, r2
2000592e:	d909      	bls.n	20005944 <__divdi3+0x22c>
20005930:	eb11 010e 	adds.w	r1, r1, lr
20005934:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
20005938:	d230      	bcs.n	2000599c <__divdi3+0x284>
2000593a:	428b      	cmp	r3, r1
2000593c:	d92e      	bls.n	2000599c <__divdi3+0x284>
2000593e:	f1a8 0802 	sub.w	r8, r8, #2
20005942:	4471      	add	r1, lr
20005944:	1ac9      	subs	r1, r1, r3
20005946:	b280      	uxth	r0, r0
20005948:	fbb1 f3f5 	udiv	r3, r1, r5
2000594c:	fb05 1113 	mls	r1, r5, r3, r1
20005950:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
20005954:	fb07 f703 	mul.w	r7, r7, r3
20005958:	428f      	cmp	r7, r1
2000595a:	d908      	bls.n	2000596e <__divdi3+0x256>
2000595c:	eb11 010e 	adds.w	r1, r1, lr
20005960:	f103 30ff 	add.w	r0, r3, #4294967295	; 0xffffffff
20005964:	d216      	bcs.n	20005994 <__divdi3+0x27c>
20005966:	428f      	cmp	r7, r1
20005968:	d914      	bls.n	20005994 <__divdi3+0x27c>
2000596a:	3b02      	subs	r3, #2
2000596c:	4471      	add	r1, lr
2000596e:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
20005972:	1bc9      	subs	r1, r1, r7
20005974:	fba3 890c 	umull	r8, r9, r3, ip
20005978:	4549      	cmp	r1, r9
2000597a:	d309      	bcc.n	20005990 <__divdi3+0x278>
2000597c:	d005      	beq.n	2000598a <__divdi3+0x272>
2000597e:	2200      	movs	r2, #0
20005980:	e71d      	b.n	200057be <__divdi3+0xa6>
20005982:	4696      	mov	lr, r2
20005984:	e6fe      	b.n	20005784 <__divdi3+0x6c>
20005986:	4613      	mov	r3, r2
20005988:	e711      	b.n	200057ae <__divdi3+0x96>
2000598a:	4094      	lsls	r4, r2
2000598c:	4544      	cmp	r4, r8
2000598e:	d2f6      	bcs.n	2000597e <__divdi3+0x266>
20005990:	3b01      	subs	r3, #1
20005992:	e7f4      	b.n	2000597e <__divdi3+0x266>
20005994:	4603      	mov	r3, r0
20005996:	e7ea      	b.n	2000596e <__divdi3+0x256>
20005998:	4688      	mov	r8, r1
2000599a:	e7a5      	b.n	200058e8 <__divdi3+0x1d0>
2000599c:	46c8      	mov	r8, r9
2000599e:	e7d1      	b.n	20005944 <__divdi3+0x22c>
200059a0:	4602      	mov	r2, r0
200059a2:	e78c      	b.n	200058be <__divdi3+0x1a6>
200059a4:	4613      	mov	r3, r2
200059a6:	e70a      	b.n	200057be <__divdi3+0xa6>
200059a8:	3b02      	subs	r3, #2
200059aa:	e757      	b.n	2000585c <__divdi3+0x144>
200059ac:	f1a8 0802 	sub.w	r8, r8, #2
200059b0:	442f      	add	r7, r5
200059b2:	e73f      	b.n	20005834 <__divdi3+0x11c>

200059b4 <__udivdi3>:
200059b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
200059b8:	2b00      	cmp	r3, #0
200059ba:	d144      	bne.n	20005a46 <__udivdi3+0x92>
200059bc:	428a      	cmp	r2, r1
200059be:	4615      	mov	r5, r2
200059c0:	4604      	mov	r4, r0
200059c2:	d94f      	bls.n	20005a64 <__udivdi3+0xb0>
200059c4:	fab2 f782 	clz	r7, r2
200059c8:	460e      	mov	r6, r1
200059ca:	b14f      	cbz	r7, 200059e0 <__udivdi3+0x2c>
200059cc:	f1c7 0320 	rsb	r3, r7, #32
200059d0:	40b9      	lsls	r1, r7
200059d2:	fa20 f603 	lsr.w	r6, r0, r3
200059d6:	fa02 f507 	lsl.w	r5, r2, r7
200059da:	430e      	orrs	r6, r1
200059dc:	fa00 f407 	lsl.w	r4, r0, r7
200059e0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
200059e4:	0c23      	lsrs	r3, r4, #16
200059e6:	fbb6 f0fe 	udiv	r0, r6, lr
200059ea:	b2af      	uxth	r7, r5
200059ec:	fb0e 6110 	mls	r1, lr, r0, r6
200059f0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
200059f4:	fb07 f100 	mul.w	r1, r7, r0
200059f8:	4299      	cmp	r1, r3
200059fa:	d909      	bls.n	20005a10 <__udivdi3+0x5c>
200059fc:	195b      	adds	r3, r3, r5
200059fe:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
20005a02:	f080 80ec 	bcs.w	20005bde <__udivdi3+0x22a>
20005a06:	4299      	cmp	r1, r3
20005a08:	f240 80e9 	bls.w	20005bde <__udivdi3+0x22a>
20005a0c:	3802      	subs	r0, #2
20005a0e:	442b      	add	r3, r5
20005a10:	1a5a      	subs	r2, r3, r1
20005a12:	b2a4      	uxth	r4, r4
20005a14:	fbb2 f3fe 	udiv	r3, r2, lr
20005a18:	fb0e 2213 	mls	r2, lr, r3, r2
20005a1c:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
20005a20:	fb07 f703 	mul.w	r7, r7, r3
20005a24:	4297      	cmp	r7, r2
20005a26:	d908      	bls.n	20005a3a <__udivdi3+0x86>
20005a28:	1952      	adds	r2, r2, r5
20005a2a:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
20005a2e:	f080 80d8 	bcs.w	20005be2 <__udivdi3+0x22e>
20005a32:	4297      	cmp	r7, r2
20005a34:	f240 80d5 	bls.w	20005be2 <__udivdi3+0x22e>
20005a38:	3b02      	subs	r3, #2
20005a3a:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
20005a3e:	2600      	movs	r6, #0
20005a40:	4631      	mov	r1, r6
20005a42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20005a46:	428b      	cmp	r3, r1
20005a48:	d847      	bhi.n	20005ada <__udivdi3+0x126>
20005a4a:	fab3 f683 	clz	r6, r3
20005a4e:	2e00      	cmp	r6, #0
20005a50:	d148      	bne.n	20005ae4 <__udivdi3+0x130>
20005a52:	428b      	cmp	r3, r1
20005a54:	d302      	bcc.n	20005a5c <__udivdi3+0xa8>
20005a56:	4282      	cmp	r2, r0
20005a58:	f200 80cd 	bhi.w	20005bf6 <__udivdi3+0x242>
20005a5c:	2001      	movs	r0, #1
20005a5e:	4631      	mov	r1, r6
20005a60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20005a64:	b912      	cbnz	r2, 20005a6c <__udivdi3+0xb8>
20005a66:	2501      	movs	r5, #1
20005a68:	fbb5 f5f2 	udiv	r5, r5, r2
20005a6c:	fab5 f885 	clz	r8, r5
20005a70:	f1b8 0f00 	cmp.w	r8, #0
20005a74:	d177      	bne.n	20005b66 <__udivdi3+0x1b2>
20005a76:	1b4a      	subs	r2, r1, r5
20005a78:	ea4f 4e15 	mov.w	lr, r5, lsr #16
20005a7c:	b2af      	uxth	r7, r5
20005a7e:	2601      	movs	r6, #1
20005a80:	fbb2 f0fe 	udiv	r0, r2, lr
20005a84:	0c23      	lsrs	r3, r4, #16
20005a86:	fb0e 2110 	mls	r1, lr, r0, r2
20005a8a:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
20005a8e:	fb07 f300 	mul.w	r3, r7, r0
20005a92:	428b      	cmp	r3, r1
20005a94:	d907      	bls.n	20005aa6 <__udivdi3+0xf2>
20005a96:	1949      	adds	r1, r1, r5
20005a98:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
20005a9c:	d202      	bcs.n	20005aa4 <__udivdi3+0xf0>
20005a9e:	428b      	cmp	r3, r1
20005aa0:	f200 80ba 	bhi.w	20005c18 <__udivdi3+0x264>
20005aa4:	4610      	mov	r0, r2
20005aa6:	1ac9      	subs	r1, r1, r3
20005aa8:	b2a4      	uxth	r4, r4
20005aaa:	fbb1 f3fe 	udiv	r3, r1, lr
20005aae:	fb0e 1113 	mls	r1, lr, r3, r1
20005ab2:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
20005ab6:	fb07 f703 	mul.w	r7, r7, r3
20005aba:	42a7      	cmp	r7, r4
20005abc:	d908      	bls.n	20005ad0 <__udivdi3+0x11c>
20005abe:	1964      	adds	r4, r4, r5
20005ac0:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
20005ac4:	f080 808f 	bcs.w	20005be6 <__udivdi3+0x232>
20005ac8:	42a7      	cmp	r7, r4
20005aca:	f240 808c 	bls.w	20005be6 <__udivdi3+0x232>
20005ace:	3b02      	subs	r3, #2
20005ad0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
20005ad4:	4631      	mov	r1, r6
20005ad6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20005ada:	2600      	movs	r6, #0
20005adc:	4630      	mov	r0, r6
20005ade:	4631      	mov	r1, r6
20005ae0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20005ae4:	f1c6 0420 	rsb	r4, r6, #32
20005ae8:	fa22 f504 	lsr.w	r5, r2, r4
20005aec:	40b3      	lsls	r3, r6
20005aee:	432b      	orrs	r3, r5
20005af0:	fa20 fc04 	lsr.w	ip, r0, r4
20005af4:	fa01 f706 	lsl.w	r7, r1, r6
20005af8:	fa21 f504 	lsr.w	r5, r1, r4
20005afc:	ea4f 4e13 	mov.w	lr, r3, lsr #16
20005b00:	ea4c 0707 	orr.w	r7, ip, r7
20005b04:	fbb5 f8fe 	udiv	r8, r5, lr
20005b08:	0c39      	lsrs	r1, r7, #16
20005b0a:	fb0e 5518 	mls	r5, lr, r8, r5
20005b0e:	fa1f fc83 	uxth.w	ip, r3
20005b12:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
20005b16:	fb0c f108 	mul.w	r1, ip, r8
20005b1a:	42a9      	cmp	r1, r5
20005b1c:	fa02 f206 	lsl.w	r2, r2, r6
20005b20:	d904      	bls.n	20005b2c <__udivdi3+0x178>
20005b22:	18ed      	adds	r5, r5, r3
20005b24:	f108 34ff 	add.w	r4, r8, #4294967295	; 0xffffffff
20005b28:	d367      	bcc.n	20005bfa <__udivdi3+0x246>
20005b2a:	46a0      	mov	r8, r4
20005b2c:	1a6d      	subs	r5, r5, r1
20005b2e:	b2bf      	uxth	r7, r7
20005b30:	fbb5 f4fe 	udiv	r4, r5, lr
20005b34:	fb0e 5514 	mls	r5, lr, r4, r5
20005b38:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
20005b3c:	fb0c fc04 	mul.w	ip, ip, r4
20005b40:	458c      	cmp	ip, r1
20005b42:	d904      	bls.n	20005b4e <__udivdi3+0x19a>
20005b44:	18c9      	adds	r1, r1, r3
20005b46:	f104 35ff 	add.w	r5, r4, #4294967295	; 0xffffffff
20005b4a:	d35c      	bcc.n	20005c06 <__udivdi3+0x252>
20005b4c:	462c      	mov	r4, r5
20005b4e:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
20005b52:	ebcc 0101 	rsb	r1, ip, r1
20005b56:	fba4 2302 	umull	r2, r3, r4, r2
20005b5a:	4299      	cmp	r1, r3
20005b5c:	d348      	bcc.n	20005bf0 <__udivdi3+0x23c>
20005b5e:	d044      	beq.n	20005bea <__udivdi3+0x236>
20005b60:	4620      	mov	r0, r4
20005b62:	2600      	movs	r6, #0
20005b64:	e76c      	b.n	20005a40 <__udivdi3+0x8c>
20005b66:	f1c8 0420 	rsb	r4, r8, #32
20005b6a:	fa01 f308 	lsl.w	r3, r1, r8
20005b6e:	fa05 f508 	lsl.w	r5, r5, r8
20005b72:	fa20 f704 	lsr.w	r7, r0, r4
20005b76:	40e1      	lsrs	r1, r4
20005b78:	ea4f 4e15 	mov.w	lr, r5, lsr #16
20005b7c:	431f      	orrs	r7, r3
20005b7e:	fbb1 f6fe 	udiv	r6, r1, lr
20005b82:	0c3a      	lsrs	r2, r7, #16
20005b84:	fb0e 1116 	mls	r1, lr, r6, r1
20005b88:	fa1f fc85 	uxth.w	ip, r5
20005b8c:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
20005b90:	fb0c f206 	mul.w	r2, ip, r6
20005b94:	429a      	cmp	r2, r3
20005b96:	fa00 f408 	lsl.w	r4, r0, r8
20005b9a:	d907      	bls.n	20005bac <__udivdi3+0x1f8>
20005b9c:	195b      	adds	r3, r3, r5
20005b9e:	f106 31ff 	add.w	r1, r6, #4294967295	; 0xffffffff
20005ba2:	d237      	bcs.n	20005c14 <__udivdi3+0x260>
20005ba4:	429a      	cmp	r2, r3
20005ba6:	d935      	bls.n	20005c14 <__udivdi3+0x260>
20005ba8:	3e02      	subs	r6, #2
20005baa:	442b      	add	r3, r5
20005bac:	1a9b      	subs	r3, r3, r2
20005bae:	b2bf      	uxth	r7, r7
20005bb0:	fbb3 f0fe 	udiv	r0, r3, lr
20005bb4:	fb0e 3310 	mls	r3, lr, r0, r3
20005bb8:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
20005bbc:	fb0c f100 	mul.w	r1, ip, r0
20005bc0:	4299      	cmp	r1, r3
20005bc2:	d907      	bls.n	20005bd4 <__udivdi3+0x220>
20005bc4:	195b      	adds	r3, r3, r5
20005bc6:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
20005bca:	d221      	bcs.n	20005c10 <__udivdi3+0x25c>
20005bcc:	4299      	cmp	r1, r3
20005bce:	d91f      	bls.n	20005c10 <__udivdi3+0x25c>
20005bd0:	3802      	subs	r0, #2
20005bd2:	442b      	add	r3, r5
20005bd4:	1a5a      	subs	r2, r3, r1
20005bd6:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
20005bda:	4667      	mov	r7, ip
20005bdc:	e750      	b.n	20005a80 <__udivdi3+0xcc>
20005bde:	4610      	mov	r0, r2
20005be0:	e716      	b.n	20005a10 <__udivdi3+0x5c>
20005be2:	460b      	mov	r3, r1
20005be4:	e729      	b.n	20005a3a <__udivdi3+0x86>
20005be6:	4613      	mov	r3, r2
20005be8:	e772      	b.n	20005ad0 <__udivdi3+0x11c>
20005bea:	40b0      	lsls	r0, r6
20005bec:	4290      	cmp	r0, r2
20005bee:	d2b7      	bcs.n	20005b60 <__udivdi3+0x1ac>
20005bf0:	1e60      	subs	r0, r4, #1
20005bf2:	2600      	movs	r6, #0
20005bf4:	e724      	b.n	20005a40 <__udivdi3+0x8c>
20005bf6:	4630      	mov	r0, r6
20005bf8:	e722      	b.n	20005a40 <__udivdi3+0x8c>
20005bfa:	42a9      	cmp	r1, r5
20005bfc:	d995      	bls.n	20005b2a <__udivdi3+0x176>
20005bfe:	f1a8 0802 	sub.w	r8, r8, #2
20005c02:	441d      	add	r5, r3
20005c04:	e792      	b.n	20005b2c <__udivdi3+0x178>
20005c06:	458c      	cmp	ip, r1
20005c08:	d9a0      	bls.n	20005b4c <__udivdi3+0x198>
20005c0a:	3c02      	subs	r4, #2
20005c0c:	4419      	add	r1, r3
20005c0e:	e79e      	b.n	20005b4e <__udivdi3+0x19a>
20005c10:	4610      	mov	r0, r2
20005c12:	e7df      	b.n	20005bd4 <__udivdi3+0x220>
20005c14:	460e      	mov	r6, r1
20005c16:	e7c9      	b.n	20005bac <__udivdi3+0x1f8>
20005c18:	3802      	subs	r0, #2
20005c1a:	4429      	add	r1, r5
20005c1c:	e743      	b.n	20005aa6 <__udivdi3+0xf2>
20005c1e:	bf00      	nop

20005c20 <memcmp>:
20005c20:	2a03      	cmp	r2, #3
20005c22:	b470      	push	{r4, r5, r6}
20005c24:	d926      	bls.n	20005c74 <memcmp+0x54>
20005c26:	ea40 0301 	orr.w	r3, r0, r1
20005c2a:	079b      	lsls	r3, r3, #30
20005c2c:	d011      	beq.n	20005c52 <memcmp+0x32>
20005c2e:	7804      	ldrb	r4, [r0, #0]
20005c30:	780d      	ldrb	r5, [r1, #0]
20005c32:	42ac      	cmp	r4, r5
20005c34:	d122      	bne.n	20005c7c <memcmp+0x5c>
20005c36:	4402      	add	r2, r0
20005c38:	1c43      	adds	r3, r0, #1
20005c3a:	e005      	b.n	20005c48 <memcmp+0x28>
20005c3c:	f813 4b01 	ldrb.w	r4, [r3], #1
20005c40:	f811 5f01 	ldrb.w	r5, [r1, #1]!
20005c44:	42ac      	cmp	r4, r5
20005c46:	d119      	bne.n	20005c7c <memcmp+0x5c>
20005c48:	4293      	cmp	r3, r2
20005c4a:	d1f7      	bne.n	20005c3c <memcmp+0x1c>
20005c4c:	2000      	movs	r0, #0
20005c4e:	bc70      	pop	{r4, r5, r6}
20005c50:	4770      	bx	lr
20005c52:	460c      	mov	r4, r1
20005c54:	4603      	mov	r3, r0
20005c56:	681e      	ldr	r6, [r3, #0]
20005c58:	6825      	ldr	r5, [r4, #0]
20005c5a:	42ae      	cmp	r6, r5
20005c5c:	4618      	mov	r0, r3
20005c5e:	4621      	mov	r1, r4
20005c60:	f103 0304 	add.w	r3, r3, #4
20005c64:	f104 0404 	add.w	r4, r4, #4
20005c68:	d104      	bne.n	20005c74 <memcmp+0x54>
20005c6a:	3a04      	subs	r2, #4
20005c6c:	2a03      	cmp	r2, #3
20005c6e:	4618      	mov	r0, r3
20005c70:	4621      	mov	r1, r4
20005c72:	d8f0      	bhi.n	20005c56 <memcmp+0x36>
20005c74:	2a00      	cmp	r2, #0
20005c76:	d1da      	bne.n	20005c2e <memcmp+0xe>
20005c78:	4610      	mov	r0, r2
20005c7a:	e7e8      	b.n	20005c4e <memcmp+0x2e>
20005c7c:	1b60      	subs	r0, r4, r5
20005c7e:	bc70      	pop	{r4, r5, r6}
20005c80:	4770      	bx	lr
20005c82:	bf00      	nop

20005c84 <memcpy>:
20005c84:	4684      	mov	ip, r0
20005c86:	ea41 0300 	orr.w	r3, r1, r0
20005c8a:	f013 0303 	ands.w	r3, r3, #3
20005c8e:	d16d      	bne.n	20005d6c <memcpy+0xe8>
20005c90:	3a40      	subs	r2, #64	; 0x40
20005c92:	d341      	bcc.n	20005d18 <memcpy+0x94>
20005c94:	f851 3b04 	ldr.w	r3, [r1], #4
20005c98:	f840 3b04 	str.w	r3, [r0], #4
20005c9c:	f851 3b04 	ldr.w	r3, [r1], #4
20005ca0:	f840 3b04 	str.w	r3, [r0], #4
20005ca4:	f851 3b04 	ldr.w	r3, [r1], #4
20005ca8:	f840 3b04 	str.w	r3, [r0], #4
20005cac:	f851 3b04 	ldr.w	r3, [r1], #4
20005cb0:	f840 3b04 	str.w	r3, [r0], #4
20005cb4:	f851 3b04 	ldr.w	r3, [r1], #4
20005cb8:	f840 3b04 	str.w	r3, [r0], #4
20005cbc:	f851 3b04 	ldr.w	r3, [r1], #4
20005cc0:	f840 3b04 	str.w	r3, [r0], #4
20005cc4:	f851 3b04 	ldr.w	r3, [r1], #4
20005cc8:	f840 3b04 	str.w	r3, [r0], #4
20005ccc:	f851 3b04 	ldr.w	r3, [r1], #4
20005cd0:	f840 3b04 	str.w	r3, [r0], #4
20005cd4:	f851 3b04 	ldr.w	r3, [r1], #4
20005cd8:	f840 3b04 	str.w	r3, [r0], #4
20005cdc:	f851 3b04 	ldr.w	r3, [r1], #4
20005ce0:	f840 3b04 	str.w	r3, [r0], #4
20005ce4:	f851 3b04 	ldr.w	r3, [r1], #4
20005ce8:	f840 3b04 	str.w	r3, [r0], #4
20005cec:	f851 3b04 	ldr.w	r3, [r1], #4
20005cf0:	f840 3b04 	str.w	r3, [r0], #4
20005cf4:	f851 3b04 	ldr.w	r3, [r1], #4
20005cf8:	f840 3b04 	str.w	r3, [r0], #4
20005cfc:	f851 3b04 	ldr.w	r3, [r1], #4
20005d00:	f840 3b04 	str.w	r3, [r0], #4
20005d04:	f851 3b04 	ldr.w	r3, [r1], #4
20005d08:	f840 3b04 	str.w	r3, [r0], #4
20005d0c:	f851 3b04 	ldr.w	r3, [r1], #4
20005d10:	f840 3b04 	str.w	r3, [r0], #4
20005d14:	3a40      	subs	r2, #64	; 0x40
20005d16:	d2bd      	bcs.n	20005c94 <memcpy+0x10>
20005d18:	3230      	adds	r2, #48	; 0x30
20005d1a:	d311      	bcc.n	20005d40 <memcpy+0xbc>
20005d1c:	f851 3b04 	ldr.w	r3, [r1], #4
20005d20:	f840 3b04 	str.w	r3, [r0], #4
20005d24:	f851 3b04 	ldr.w	r3, [r1], #4
20005d28:	f840 3b04 	str.w	r3, [r0], #4
20005d2c:	f851 3b04 	ldr.w	r3, [r1], #4
20005d30:	f840 3b04 	str.w	r3, [r0], #4
20005d34:	f851 3b04 	ldr.w	r3, [r1], #4
20005d38:	f840 3b04 	str.w	r3, [r0], #4
20005d3c:	3a10      	subs	r2, #16
20005d3e:	d2ed      	bcs.n	20005d1c <memcpy+0x98>
20005d40:	320c      	adds	r2, #12
20005d42:	d305      	bcc.n	20005d50 <memcpy+0xcc>
20005d44:	f851 3b04 	ldr.w	r3, [r1], #4
20005d48:	f840 3b04 	str.w	r3, [r0], #4
20005d4c:	3a04      	subs	r2, #4
20005d4e:	d2f9      	bcs.n	20005d44 <memcpy+0xc0>
20005d50:	3204      	adds	r2, #4
20005d52:	d008      	beq.n	20005d66 <memcpy+0xe2>
20005d54:	07d2      	lsls	r2, r2, #31
20005d56:	bf1c      	itt	ne
20005d58:	f811 3b01 	ldrbne.w	r3, [r1], #1
20005d5c:	f800 3b01 	strbne.w	r3, [r0], #1
20005d60:	d301      	bcc.n	20005d66 <memcpy+0xe2>
20005d62:	880b      	ldrh	r3, [r1, #0]
20005d64:	8003      	strh	r3, [r0, #0]
20005d66:	4660      	mov	r0, ip
20005d68:	4770      	bx	lr
20005d6a:	bf00      	nop
20005d6c:	2a08      	cmp	r2, #8
20005d6e:	d313      	bcc.n	20005d98 <memcpy+0x114>
20005d70:	078b      	lsls	r3, r1, #30
20005d72:	d08d      	beq.n	20005c90 <memcpy+0xc>
20005d74:	f010 0303 	ands.w	r3, r0, #3
20005d78:	d08a      	beq.n	20005c90 <memcpy+0xc>
20005d7a:	f1c3 0304 	rsb	r3, r3, #4
20005d7e:	1ad2      	subs	r2, r2, r3
20005d80:	07db      	lsls	r3, r3, #31
20005d82:	bf1c      	itt	ne
20005d84:	f811 3b01 	ldrbne.w	r3, [r1], #1
20005d88:	f800 3b01 	strbne.w	r3, [r0], #1
20005d8c:	d380      	bcc.n	20005c90 <memcpy+0xc>
20005d8e:	f831 3b02 	ldrh.w	r3, [r1], #2
20005d92:	f820 3b02 	strh.w	r3, [r0], #2
20005d96:	e77b      	b.n	20005c90 <memcpy+0xc>
20005d98:	3a04      	subs	r2, #4
20005d9a:	d3d9      	bcc.n	20005d50 <memcpy+0xcc>
20005d9c:	3a01      	subs	r2, #1
20005d9e:	f811 3b01 	ldrb.w	r3, [r1], #1
20005da2:	f800 3b01 	strb.w	r3, [r0], #1
20005da6:	d2f9      	bcs.n	20005d9c <memcpy+0x118>
20005da8:	780b      	ldrb	r3, [r1, #0]
20005daa:	7003      	strb	r3, [r0, #0]
20005dac:	784b      	ldrb	r3, [r1, #1]
20005dae:	7043      	strb	r3, [r0, #1]
20005db0:	788b      	ldrb	r3, [r1, #2]
20005db2:	7083      	strb	r3, [r0, #2]
20005db4:	4660      	mov	r0, ip
20005db6:	4770      	bx	lr

20005db8 <bootmode_flag>:
20005db8:	4f42 544f 4f4d 4544 6176 696c 5f64 6674     BOOTMODEvalid_tf
20005dc8:	6674 685f 6165 6564 2072 6166 6c69 6465     tf_header failed
20005dd8:	0a0d 0d00 2d0a 5b2d 754d 2043 6f4c 6461     .....--[MuC Load
20005de8:	7265 7620 2e30 3a31 3931 3164 3933 5d61     er v0.1:19d139a]
20005df8:	0a0d 2d00 6c46 7361 2068 6f4d 6564 2820     ...-Flash Mode (
20005e08:	2900 0a0d 2000 2020 2020 2020 5420 5446     .)...        TFT
20005e18:	2046 2020 4220 4f4f 4c54 414f 4544 2052     F    BOOTLOADER 
20005e28:	4320 4548 4b43 4445 2020 2020 0a0d 5600      CHECKED    ...V
20005e38:	4449 203a 7830 0900 2000 2020 4559 0d53     ID: 0x...   YES.
20005e48:	000a 4950 3a44 3020 0078 2020 4e20 0d4f     ..PID: 0x.   NO.
20005e58:	000a 6544 6174 6863 6465 2d20 5320 4950     ..Detached - SPI
20005e68:	4e4e 4e49 0d47 000a 6142 6b63 0a0d 4500     NNING...Back...E
20005e78:	5252 4920 766e 6c61 6469 6820 7073 2069     RR Invalid hspi 
20005e88:	5400 5278 2078 6e49 6176 696c 2064 7368     .TxRx Invalid hs
20005e98:	6970 0020                                   pi .

20005e9c <flashing_flag>:
20005e9c:	4c46 5341 4948 474e                         FLASHING

20005ea4 <AHBPrescTable>:
	...
20005eac:	0201 0403 0706 0908                         ........

20005eb4 <MSIRangeTable>:
20005eb4:	86a0 0001 0d40 0003 1a80 0006 3500 000c     ....@........5..
20005ec4:	4240 000f 8480 001e 0900 003d 1200 007a     @B........=...z.
20005ed4:	2400 00f4 3600 016e 4800 01e8 6c00 02dc     .$...6n..H...l..
20005ee4:	7270 676f 6172 5f6d 6c66 7361 5f68 7764     program_flash_dw
20005ef4:	726f 2064 6300 6e6f 7274 6c6f 635f 6f70     ord .control_cpo
20005f04:	7472 685f 6e61 6c64 7265 203a 5852 6420     rt_handler: RX d
20005f14:	7461 2061 656c 676e 6874 6520 7272 726f     ata length error
20005f24:	0a0d 6d00 646f 5f73 6f63 746e 6f72 5f6c     ...mods_control_
20005f34:	6168 646e 656c 3a72 5220 2058 6164 6174     handler: RX data
20005f44:	6c20 6e65 7467 2068 7265 6f72 0d72 000a      length error...
20005f54:	2e30 2031 3931 3164 3933 0061 4552 4f42     0.1 19d139a.REBO
20005f64:	544f 525f 5345 5445 0a0d 5200 4245 4f4f     OT_RESET...REBOO
20005f74:	5f54 4f42 544f 4f4c 4441 5245 0a0d 5200     T_BOOTLOADER...R
20005f84:	4245 4f4f 2054 6600 5f77 7063 726f 5f74     EBOOT .fw_cport_
20005f94:	6168 646e 656c 3a72 6920 636e 726f 6572     handler: incorre
20005fa4:	7463 4320 6f50 7472 2320 0a0d 6600 5f77     ct CPort #...fw_
20005fb4:	7063 726f 5f74 6168 646e 656c 3a72 5220     cport_handler: R
20005fc4:	2058 6164 6174 6c20 6e65 7467 2068 7265     X data length er
20005fd4:	6f72 0d72 000a 7766 635f 6f70 7472 685f     ror...fw_cport_h
20005fe4:	6e61 6c64 7265 203a 6170 6c79 616f 2064     andler: payload 
20005ff4:	6973 657a 3e20 7420 746f 6c61 7320 7a69     size > total siz
20006004:	2e65 0a0d 2000 7420 746f 6c61 735f 7a69     e....  total_siz
20006014:	2065 6c28 6e65 2029 203d 7830 2000 2020     e (len) = 0x.   
20006024:	2020 7020 7961 6f6c 6461 735f 7a69 2065        payload_size 
20006034:	203d 7830 6600 5f77 7063 726f 5f74 6168     = 0x.fw_cport_ha
20006044:	646e 656c 3a72 4720 6572 6279 7375 7220     ndler: Greybus r
20006054:	7365 6f70 736e 2c65 7320 6174 7574 2073     esponse, status 
20006064:	7830 6700 6662 5f77 6966 6d72 6177 6572     0x.gbfw_firmware
20006074:	735f 7a69 5f65 6572 7073 6e6f 6573 203a     _size_response: 
20006084:	6162 2064 6572 7073 6e6f 6573 7320 7a69     bad response siz
20006094:	0d65 000a 6b73 7069 6520 706d 7974 6620     e...skip empty f
200060a4:	7269 776d 7261 0065 4e49 4156 494c 5f44     irmware.INVALID_
200060b4:	4654 4654 4e00 206f 6573 7463 6f69 736e     TFTF.No sections
200060c4:	7420 206f 6c66 7361 0068 6146 6c69 6465      to flash.Failed
200060d4:	7420 206f 6573 2074 6c66 7361 6968 676e      to set flashing
200060e4:	6620 616c 0d67 000a 7073 5f69 7277 7469      flag...spi_writ
200060f4:	5f65 6f74 665f 616c 6873 685f 6165 6564     e_to_flash_heade
20006104:	2072 7265 6f72 0d72 000a 7270 676f 6172     r error...progra
20006114:	5f6d 6c66 7361 5f68 6164 6174 2820 6468     m_flash_data (hd
20006124:	2972 6520 7272 726f 0a0d 7300 6970 775f     r) error...spi_w
20006134:	6972 6574 745f 5f6f 6c66 7361 5f68 6164     rite_to_flash_da
20006144:	6174 6520 7272 726f 0a0d 7000 6f72 7267     ta error...progr
20006154:	6d61 665f 616c 6873 645f 7461 2061 7265     am_flash_data er
20006164:	6f72 0d72 000a 6267 7766 725f 6165 7964     ror...gbfw_ready
20006174:	745f 5f6f 6f62 746f 725f 7365 6f70 736e     _to_boot_respons
20006184:	2865 3a29 6720 746f 6520 7272 726f 7320     e(): got error s
20006194:	6174 7574 0d73 000a 5746 4644 544c 0a0d     tatus...FWDFLT..
200061a4:	6d00 646f 5f73 6f63 746e 6f72 5f6c 6168     .mods_control_ha
200061b4:	646e 656c 2072 6166 6c69 6465 0a0d 6600     ndler failed...f
200061c4:	5f77 7063 726f 5f74 6168 646e 656c 2072     w_cport_handler 
200061d4:	6166 6c69 6465 0a0d 4500 5252 524f 7220     failed...ERROR r
200061e4:	6365 6965 6576 2064 656d 7373 6761 2065     eceived message 
200061f4:	6f66 2072 7063 726f 2074 4200 4552 545f     for cport .BRE_T
20006204:	5446 5f46 4548 4441 5245 545f 5059 0d45     FTF_HEADER_TYPE.
20006214:	000a 5242 5f45 4654 4654 435f 4d4f 5250     ..BRE_TFTF_COMPR
20006224:	5345 4953 4e4f 425f 4441 0a0d 4200 4552     ESSION_BAD...BRE
20006234:	545f 5446 5f46 4f43 4c4c 5349 4f49 0d4e     _TFTF_COLLISION.
20006244:	000a 5242 5f45 4654 4654 535f 4e45 4954     ..BRE_TFTF_SENTI
20006254:	454e 0d4c 000a 5242 5f45 4654 4654 485f     NEL...BRE_TFTF_H
20006264:	4145 4544 5f52 4953 455a 0a0d 4200 4552     EADER_SIZE...BRE
20006274:	545f 5446 5f46 4f4e 545f 4241 454c 455f     _TFTF_NO_TABLE_E
20006284:	444e 0a0d 4200 4552 545f 5446 5f46 5453     ND...BRE_TFTF_ST
20006294:	5241 5f54 4f4e 5f54 4e49 435f 444f 0d45     ART_NOT_IN_CODE.
200062a4:	000a 5242 5f45 4654 4654 4e5f 4e4f 5a5f     ..BRE_TFTF_NON_Z
200062b4:	5245 5f4f 4150 0d44 000a 6f6e 7320 6769     ERO_PAD...no sig
200062c4:	616e 7574 6572 0a0d 6400                         nature...

200062cd <manifest>:
200062cd:	0064 0200 0008 0001 0201 0000 001c 0002     d...............
200062dd:	0116 6f4d 6f74 6f72 616c 4d20 626f 6c69     ..Motorola Mobil
200062ed:	7469 2c79 4c20 434c 0010 0002 0208 6946     ity, LLC......Fi
200062fd:	6d72 6177 6572 0000 0008 0004 0000 0000     rmware..........
2000630d:	0008 0003 0000 0000 0008 0004 0001 1501     ................
2000631d:	0008 0003 ff01 0000 000c 0005 fffe ffff     ................
2000632d:	0128 0000 aa06 42d2 e262 7dc2 ffab d37f     (......Bb..}....
2000633d:	e4ba 83db 8f86 84a8 b4c6 5672 aa27 65a5     ..........rV'..e
2000634d:	b6c1 c41a 6f8e d117 79ea 3b30 47d2 a969     .....o...y0;.Gi.
2000635d:	0a2e 0238 bc36 d442 ce0d baff d536 4109     ..8.6.B.....6..A
2000636d:	4737 ba10 2ac8 a238 4f61 8ee4 362d fbe6     7G...*8.aO..-6..
2000637d:	b92a 8c1a 64e7 7fd3 7b8a 5ecd c9d1 11db     *....d...{.^....
2000638d:	f886 0e23 e0d0 d7fb d3a4 de6d 67a0 da3f     ..#.......m..g?.
2000639d:	d75f 291f dc47 2086 99f2 390e cffc be4b     _..)G.. ...9..K.
200063ad:	c168 b602 2447 517c f7d0 4535 66f6 0bf8     h...G$|Q..5E.f..
200063bd:	c010 e64a fb5d 570d f87e 01f8 2e03 58b6     ..J.]..W~......X
200063cd:	6a81 34d5 43d8 d8d9 bcac 48c4 a8cc 8516     .j.4.C.....H....
200063dd:	a8b4 85cd bd3f c285 3cbe b66e 90c3 89da     ....?....<n.....
200063ed:	4c48 cbb9 4117 6c28 2762 5387 add6 ee2d     HL...A(lb'.S..-.
200063fd:	55b0 eb85 7899 0770 43e8 fb52 cf76 ca77     .U...xp..CR.v.w.
2000640d:	5771 cb18 1f9e 8f93 dea3 286f 1d58 2d96     qW........o(X..-
2000641d:	240a 57eb 8125 1fe2 f0f3 3159 18d8 5ceb     .$.W%.....Y1...\
2000642d:	462f c013 5244 203a 2020 2020 7830 4900     /F..DR:     0x.I
2000643d:	544e 203a 2020 2020 0020 4652 3a52 2020     NT:      .RFR:  
2000644d:	2020 2020 6200 6675 735f 207a 3020 0078         .buf_sz  0x.
2000645d:	6572 7073 6552 6461 2079 6100 6d72 4d44     respReady .armDM
2000646d:	2041 2020 0020 5053 4549 5252 3a20 3020     A    .SPIERR : 0
2000647d:	0078 4341 204b 6572 7571 7269 7365 6e20     x.ACK requires n
2000648d:	7765 7265 7020 6f72 6f74 6f63 206c 6576     ewer protocol ve
2000649d:	7372 6f69 0d6e 000a 4c44 4644 544c 0a0d     rsion...DLDFLT..
200064ad:	5500 454e 5058 4345 4554 2044 534d 2147     .UNEXPECTED MSG!
200064bd:	0d21 000a 0000 ef00                              !......

200064c4 <SPI_FLASH_DEVICES>:
200064c4:	50ef 0013 0003 0000 0000 0001 0008 0000     .P..............
200064d4:	0100 0000 1000 0000 3600 016e 000a 0000     .........6n.....
200064e4:	0190 0000 60ef 0013 0003 0000 0000 0001     .....`..........
200064f4:	0008 0000 0100 0000 1000 0000 3600 016e     .............6n.
20006504:	000a 0000 0190 0000 7073 5f69 6c66 7361     ........spi_flas
20006514:	5f68 6572 6461 695f 2064 2e2e 5700 5241     h_read_id ...WAR
20006524:	494e 474e 203a 454a 4544 2043 4449 6e20     NING: JEDEC ID n
20006534:	746f 6620 756f 646e 000a 5245 4f52 3a52     ot found..ERROR:
20006544:	6920 766e 6c61 6469 6120 6464 6572 7373      invalid address
20006554:	7720 6469 6874 4500 5252 524f 203a 6c66      width.ERROR: fl
20006564:	7361 2068 6576 6972 7966 6620 6961 656c     ash verify faile
20006574:	0a64 6500 6172 6973 676e 0020 6220 7479     d..erasing . byt
20006584:	7365 0a0d 0000 0000                         es......

2000658c <spi_write_ops>:
2000658c:	1ffd 2000 1fd9 2000 21a1 2000 210d 2000     ... ... .!. .!. 
2000659c:	20a5 2000 1f49 2000 1f55 2000 1f69 2000     . . I.. U.. i.. 
200065ac:	5053 2049 6c46 7361 2068 6544 6e49 7469     SPI Flash DeInit
200065bc:	0a0d 5300 4950 4620 616c 6873 5220 2d65     ...SPI Flash Re-
200065cc:	6e49 7469 0a0d 4600 616c 6873 6f46 6d72     Init...FlashForm
200065dc:	7461 6f46 4672 0057 7073 5f69 7277 7469     atForFW.spi_writ
200065ec:	5f65 6f74 665f 616c 6873 665f 6e69 7369     e_to_flash_finis
200065fc:	0d68 000a 7073 5f69 6c66 7361 5f68 7274     h...spi_flash_tr
2000660c:	6e61 6673 7265 655f 7272 726f 0a0d 6300     ansfer_error...c
2000661c:	6968 5f70 7073 5f69 7865 6863 6e61 6567     hip_spi_exchange
2000662c:	4820 4c41 535f 4950 545f 6172 736e 696d      HAL_SPI_Transmi
2000663c:	5274 6365 6965 6576 445f 414d 6520 7272     tReceive_DMA err
2000664c:	726f 0a0d 0000                                   or...

20006651 <APBAHBPrescTable>:
20006651:	0000 0000 0201 0403                         ........

20006659 <CSWTCH.36>:
20006659:	1000 1010 1004 1010 1002 1010 0108               .............

20006666 <CSWTCH.35>:
20006666:	0401 0802 2d2d 4d5b 4375 4c20 616f 6564     ....--[MuC Loade
20006676:	5d72 2d2d 5220 6165 6f73 3a6e 0020          r]-- Reason: .

20006684 <_init>:
20006684:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20006686:	bf00      	nop
20006688:	bcf8      	pop	{r3, r4, r5, r6, r7}
2000668a:	bc08      	pop	{r3}
2000668c:	469e      	mov	lr, r3
2000668e:	4770      	bx	lr

20006690 <_fini>:
20006690:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20006692:	bf00      	nop
20006694:	bcf8      	pop	{r3, r4, r5, r6, r7}
20006696:	bc08      	pop	{r3}
20006698:	469e      	mov	lr, r3
2000669a:	4770      	bx	lr

2000669c <_ids>:
2000669c:	0042 0000 0001 0000 0104 0000 6415 0000     B............d..
200066ac:	0000 0000                                   ....
